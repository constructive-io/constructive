/**
 * ORM Client - Runtime GraphQL executor
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

export interface OrmClientConfig {
  endpoint: string;
  headers?: Record<string, string>;
}

export interface GraphQLError {
  message: string;
  locations?: { line: number; column: number }[];
  path?: (string | number)[];
  extensions?: Record<string, unknown>;
}

/**
 * Error thrown when GraphQL request fails
 */
export class GraphQLRequestError extends Error {
  constructor(
    public readonly errors: GraphQLError[],
    public readonly data: unknown = null,
  ) {
    const messages = errors.map((e) => e.message).join("; ");
    super(`GraphQL Error: ${messages}`);
    this.name = "GraphQLRequestError";
  }
}

/**
 * Discriminated union for query results
 * Use .ok to check success, or use .unwrap() to get data or throw
 */
export type QueryResult<T> =
  | { ok: true; data: T; errors: undefined }
  | { ok: false; data: null; errors: GraphQLError[] };

/**
 * Legacy QueryResult type for backwards compatibility
 * @deprecated Use QueryResult discriminated union instead
 */
export interface LegacyQueryResult<T> {
  data: T | null;
  errors?: GraphQLError[];
}

export class OrmClient {
  private endpoint: string;
  private headers: Record<string, string>;

  constructor(config: OrmClientConfig) {
    this.endpoint = config.endpoint;
    this.headers = config.headers ?? {};
  }

  async execute<T>(
    document: string,
    variables?: Record<string, unknown>,
  ): Promise<QueryResult<T>> {
    const response = await fetch(this.endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...this.headers,
      },
      body: JSON.stringify({
        query: document,
        variables: variables ?? {},
      }),
    });

    if (!response.ok) {
      return {
        ok: false,
        data: null,
        errors: [
          { message: `HTTP ${response.status}: ${response.statusText}` },
        ],
      };
    }

    const json = (await response.json()) as {
      data?: T;
      errors?: GraphQLError[];
    };

    // Return discriminated union based on presence of errors
    if (json.errors && json.errors.length > 0) {
      return {
        ok: false,
        data: null,
        errors: json.errors,
      };
    }

    return {
      ok: true,
      data: json.data as T,
      errors: undefined,
    };
  }

  setHeaders(headers: Record<string, string>): void {
    this.headers = { ...this.headers, ...headers };
  }

  getEndpoint(): string {
    return this.endpoint;
  }
}
