/**
 * Query Builder - Builds and executes GraphQL operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { OrmClient, QueryResult, GraphQLRequestError } from './client';

export interface QueryBuilderConfig {
  client: OrmClient;
  operation: 'query' | 'mutation';
  operationName: string;
  fieldName: string;
  document: string;
  variables?: Record<string, unknown>;
}

export class QueryBuilder<TResult> {
  private config: QueryBuilderConfig;

  constructor(config: QueryBuilderConfig) {
    this.config = config;
  }

  /**
   * Execute the query and return a discriminated union result
   * Use result.ok to check success, or .unwrap() to throw on error
   */
  async execute(): Promise<QueryResult<TResult>> {
    return this.config.client.execute<TResult>(
      this.config.document,
      this.config.variables
    );
  }

  /**
   * Execute and unwrap the result, throwing GraphQLRequestError on failure
   * @throws {GraphQLRequestError} If the query returns errors
   */
  async unwrap(): Promise<TResult> {
    const result = await this.execute();
    if (!result.ok) {
      throw new GraphQLRequestError(result.errors, result.data);
    }
    return result.data;
  }

  /**
   * Execute and unwrap, returning defaultValue on error instead of throwing
   */
  async unwrapOr<D>(defaultValue: D): Promise<TResult | D> {
    const result = await this.execute();
    if (!result.ok) {
      return defaultValue;
    }
    return result.data;
  }

  /**
   * Execute and unwrap, calling onError callback on failure
   */
  async unwrapOrElse<D>(
    onError: (errors: import('./client').GraphQLError[]) => D
  ): Promise<TResult | D> {
    const result = await this.execute();
    if (!result.ok) {
      return onError(result.errors);
    }
    return result.data;
  }

  toGraphQL(): string {
    return this.config.document;
  }

  getVariables(): Record<string, unknown> | undefined {
    return this.config.variables;
  }
}

// ============================================================================
// Document Builders
// ============================================================================

export function buildSelections<T>(select: T): string {
  if (!select) return '';

  const fields: string[] = [];

  for (const [key, value] of Object.entries(select)) {
    if (value === false || value === undefined) continue;

    if (value === true) {
      fields.push(key);
      continue;
    }

    if (typeof value === 'object' && value !== null) {
      const nested = value as {
        select?: Record<string, unknown>;
        first?: number;
        filter?: Record<string, unknown>;
        orderBy?: string[];
        // New: connection flag to differentiate connection types from regular objects
        connection?: boolean;
      };

      if (nested.select) {
        const nestedSelections = buildSelections(nested.select);

        // Check if this is a connection type (has pagination args or explicit connection flag)
        const isConnection =
          nested.connection === true ||
          nested.first !== undefined ||
          nested.filter !== undefined;

        if (isConnection) {
          // Connection type - wrap in nodes/totalCount/pageInfo
          const args: string[] = [];
          if (nested.first !== undefined) args.push(`first: ${nested.first}`);
          if (nested.orderBy?.length)
            args.push(`orderBy: [${nested.orderBy.join(', ')}]`);
          const argsStr = args.length > 0 ? `(${args.join(', ')})` : '';

          fields.push(`${key}${argsStr} {
      nodes { ${nestedSelections} }
      totalCount
      pageInfo { hasNextPage hasPreviousPage startCursor endCursor }
    }`);
        } else {
          // Regular nested object - just wrap in braces
          fields.push(`${key} { ${nestedSelections} }`);
        }
      }
    }
  }

  return fields.join('\n    ');
}

export function buildFindManyDocument<TSelect, TWhere>(
  operationName: string,
  queryField: string,
  select: TSelect,
  args: {
    where?: TWhere;
    orderBy?: string[];
    first?: number;
    last?: number;
    after?: string;
    before?: string;
    offset?: number;
  },
  filterTypeName: string,
  orderByTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const varDefs: string[] = [];
  const queryArgs: string[] = [];
  const variables: Record<string, unknown> = {};

  if (args.where) {
    varDefs.push(`$where: ${filterTypeName}`);
    queryArgs.push('filter: $where');
    variables.where = args.where;
  }
  if (args.orderBy?.length) {
    varDefs.push(`$orderBy: [${orderByTypeName}!]`);
    queryArgs.push('orderBy: $orderBy');
    variables.orderBy = args.orderBy;
  }
  if (args.first !== undefined) {
    varDefs.push('$first: Int');
    queryArgs.push('first: $first');
    variables.first = args.first;
  }
  if (args.last !== undefined) {
    varDefs.push('$last: Int');
    queryArgs.push('last: $last');
    variables.last = args.last;
  }
  if (args.after) {
    varDefs.push('$after: Cursor');
    queryArgs.push('after: $after');
    variables.after = args.after;
  }
  if (args.before) {
    varDefs.push('$before: Cursor');
    queryArgs.push('before: $before');
    variables.before = args.before;
  }
  if (args.offset !== undefined) {
    varDefs.push('$offset: Int');
    queryArgs.push('offset: $offset');
    variables.offset = args.offset;
  }

  const varDefsStr = varDefs.length > 0 ? `(${varDefs.join(', ')})` : '';
  const queryArgsStr = queryArgs.length > 0 ? `(${queryArgs.join(', ')})` : '';

  const document = `query ${operationName}Query${varDefsStr} {
  ${queryField}${queryArgsStr} {
    nodes { ${selections} }
    totalCount
    pageInfo { hasNextPage hasPreviousPage startCursor endCursor }
  }
}`;

  return { document, variables };
}

export function buildFindFirstDocument<TSelect, TWhere>(
  operationName: string,
  queryField: string,
  select: TSelect,
  args: { where?: TWhere },
  filterTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const varDefs: string[] = ['$first: Int'];
  const queryArgs: string[] = ['first: $first'];
  const variables: Record<string, unknown> = { first: 1 };

  if (args.where) {
    varDefs.push(`$where: ${filterTypeName}`);
    queryArgs.push('filter: $where');
    variables.where = args.where;
  }

  const document = `query ${operationName}Query(${varDefs.join(', ')}) {
  ${queryField}(${queryArgs.join(', ')}) {
    nodes { ${selections} }
  }
}`;

  return { document, variables };
}

export function buildCreateDocument<TSelect, TData>(
  operationName: string,
  mutationField: string,
  entityField: string,
  select: TSelect,
  data: TData,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const document = `mutation ${operationName}Mutation($input: ${inputTypeName}!) {
  ${mutationField}(input: $input) {
    ${entityField} { ${selections} }
  }
}`;

  return {
    document,
    variables: { input: { [entityField]: data } },
  };
}

export function buildUpdateDocument<
  TSelect,
  TWhere extends { id: string },
  TData,
>(
  operationName: string,
  mutationField: string,
  entityField: string,
  select: TSelect,
  where: TWhere,
  data: TData,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const document = `mutation ${operationName}Mutation($input: ${inputTypeName}!) {
  ${mutationField}(input: $input) {
    ${entityField} { ${selections} }
  }
}`;

  return {
    document,
    variables: { input: { id: where.id, patch: data } },
  };
}

export function buildDeleteDocument<TWhere extends { id: string }>(
  operationName: string,
  mutationField: string,
  entityField: string,
  where: TWhere,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const document = `mutation ${operationName}Mutation($input: ${inputTypeName}!) {
  ${mutationField}(input: $input) {
    ${entityField} { id }
  }
}`;

  return {
    document,
    variables: { input: { id: where.id } },
  };
}

export function buildCustomDocument<TSelect, TArgs>(
  operationType: 'query' | 'mutation',
  operationName: string,
  fieldName: string,
  select: TSelect,
  args: TArgs,
  variableDefinitions: Array<{ name: string; type: string }>
): { document: string; variables: Record<string, unknown> } {
  // Check if select is wrapped with connection metadata
  let actualSelect = select;
  let isConnection = false;
  
  if (select && typeof select === 'object' && 'select' in select) {
    const wrapper = select as { select?: any; connection?: boolean };
    if (wrapper.select) {
      actualSelect = wrapper.select as TSelect;
      isConnection = wrapper.connection === true;
    }
  }
  
  const selections = actualSelect ? buildSelections(actualSelect) : '';

  const varDefs = variableDefinitions.map((v) => `$${v.name}: ${v.type}`);
  const fieldArgs = variableDefinitions.map((v) => `${v.name}: $${v.name}`);

  const varDefsStr = varDefs.length > 0 ? `(${varDefs.join(', ')})` : '';
  const fieldArgsStr = fieldArgs.length > 0 ? `(${fieldArgs.join(', ')})` : '';
  
  let selectionsBlock: string;
  if (isConnection) {
    // Wrap in connection structure
    selectionsBlock = ` {
    nodes { ${selections} }
    totalCount
    pageInfo { hasNextPage hasPreviousPage startCursor endCursor }
  }`;
  } else {
    selectionsBlock = selections ? ` { ${selections} }` : '';
  }

  const opType = operationType === 'query' ? 'query' : 'mutation';
  const document = `${opType} ${operationName}${varDefsStr} {
  ${fieldName}${fieldArgsStr}${selectionsBlock}
}`;

  return { document, variables: (args ?? {}) as Record<string, unknown> };
}
