/**
 * Mutation hook generators using Babel AST-based code generation
 *
 * Output structure:
 * mutations/
 *   useCreateCarMutation.ts
 *   useUpdateCarMutation.ts
 *   useDeleteCarMutation.ts
 */
import type { CleanTable } from '../../types/schema';
import * as t from '@babel/types';
import { generateCode, addJSDocComment, typedParam, createTypedCallExpression } from './babel-ast';
import {
  buildCreateMutationAST,
  buildUpdateMutationAST,
  buildDeleteMutationAST,
  printGraphQL,
} from './gql-ast';
import {
  getTableNames,
  getCreateMutationHookName,
  getUpdateMutationHookName,
  getDeleteMutationHookName,
  getCreateMutationFileName,
  getUpdateMutationFileName,
  getDeleteMutationFileName,
  getCreateMutationName,
  getUpdateMutationName,
  getDeleteMutationName,
  getScalarFields,
  getPrimaryKeyInfo,
  fieldTypeToTs,
  ucFirst,
  lcFirst,
  getGeneratedFileHeader,
} from './utils';

function isAutoGeneratedField(fieldName: string, pkFieldNames: Set<string>): boolean {
  const name = fieldName.toLowerCase();
  if (pkFieldNames.has(fieldName)) return true;
  const timestampPatterns = [
    'createdat', 'created_at', 'createddate', 'created_date',
    'updatedat', 'updated_at', 'updateddate', 'updated_date',
    'deletedat', 'deleted_at',
  ];
  return timestampPatterns.includes(name);
}

export interface GeneratedMutationFile {
  fileName: string;
  content: string;
}

export interface MutationGeneratorOptions {
  reactQueryEnabled?: boolean;
  enumsFromSchemaTypes?: string[];
  useCentralizedKeys?: boolean;
  hasRelationships?: boolean;
  /** All table type names for determining which types to import from types.ts vs schema-types.ts */
  tableTypeNames?: Set<string>;
}

export function generateCreateMutationHook(
  table: CleanTable,
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile | null {
  const {
    reactQueryEnabled = true,
    enumsFromSchemaTypes = [],
    useCentralizedKeys = true,
    hasRelationships = false,
    tableTypeNames = new Set<string>(),
  } = options;

  if (!reactQueryEnabled) {
    return null;
  }

  const enumSet = new Set(enumsFromSchemaTypes);
  const { typeName, singularName } = getTableNames(table);
  const hookName = getCreateMutationHookName(table);
  const keysName = `${lcFirst(typeName)}Keys`;
  const mutationKeysName = `${lcFirst(typeName)}MutationKeys`;
  const scopeTypeName = `${typeName}Scope`;
  const mutationName = getCreateMutationName(table);
  const scalarFields = getScalarFields(table);

  const pkFieldNames = new Set(getPrimaryKeyInfo(table).map((pk) => pk.name));

  const usedEnums = new Set<string>();
  const usedTableTypes = new Set<string>();
  for (const field of scalarFields) {
    const cleanType = field.type.gqlType.replace(/!/g, '');
    if (enumSet.has(cleanType)) {
      usedEnums.add(cleanType);
    } else if (tableTypeNames.has(cleanType) && cleanType !== typeName) {
      // Track table types used in scalar fields (excluding the main type which is already imported)
      usedTableTypes.add(cleanType);
    }
  }

  const mutationAST = buildCreateMutationAST({ table });
  const mutationDocument = printGraphQL(mutationAST);

  const statements: t.Statement[] = [];

  const reactQueryImport = t.importDeclaration(
    [
      t.importSpecifier(t.identifier('useMutation'), t.identifier('useMutation')),
      t.importSpecifier(t.identifier('useQueryClient'), t.identifier('useQueryClient')),
    ],
    t.stringLiteral('@tanstack/react-query')
  );
  statements.push(reactQueryImport);

  const reactQueryTypeImport = t.importDeclaration(
    [t.importSpecifier(t.identifier('UseMutationOptions'), t.identifier('UseMutationOptions'))],
    t.stringLiteral('@tanstack/react-query')
  );
  reactQueryTypeImport.importKind = 'type';
  statements.push(reactQueryTypeImport);

  const clientImport = t.importDeclaration(
    [t.importSpecifier(t.identifier('execute'), t.identifier('execute'))],
    t.stringLiteral('../client')
  );
  statements.push(clientImport);

  // Import the main type and any other table types used in scalar fields
  const allTypesToImport = [typeName, ...Array.from(usedTableTypes)].sort();
  const typesImport = t.importDeclaration(
    allTypesToImport.map((t_) => t.importSpecifier(t.identifier(t_), t.identifier(t_))),
    t.stringLiteral('../types')
  );
  typesImport.importKind = 'type';
  statements.push(typesImport);

  if (usedEnums.size > 0) {
    const enumImport = t.importDeclaration(
      Array.from(usedEnums).sort().map((e) => t.importSpecifier(t.identifier(e), t.identifier(e))),
      t.stringLiteral('../schema-types')
    );
    enumImport.importKind = 'type';
    statements.push(enumImport);
  }

  if (useCentralizedKeys) {
    const queryKeyImport = t.importDeclaration(
      [t.importSpecifier(t.identifier(keysName), t.identifier(keysName))],
      t.stringLiteral('../query-keys')
    );
    statements.push(queryKeyImport);
    if (hasRelationships) {
      const scopeTypeImport = t.importDeclaration(
        [t.importSpecifier(t.identifier(scopeTypeName), t.identifier(scopeTypeName))],
        t.stringLiteral('../query-keys')
      );
      scopeTypeImport.importKind = 'type';
      statements.push(scopeTypeImport);
    }
    const mutationKeyImport = t.importDeclaration(
      [t.importSpecifier(t.identifier(mutationKeysName), t.identifier(mutationKeysName))],
      t.stringLiteral('../mutation-keys')
    );
    statements.push(mutationKeyImport);
  }

  const reExportDecl = t.exportNamedDeclaration(
    null,
    [t.exportSpecifier(t.identifier(typeName), t.identifier(typeName))],
    t.stringLiteral('../types')
  );
  reExportDecl.exportKind = 'type';
  statements.push(reExportDecl);

  const mutationDocConst = t.variableDeclaration('const', [
    t.variableDeclarator(
      t.identifier(`${mutationName}MutationDocument`),
      t.templateLiteral(
        [t.templateElement({ raw: '\n' + mutationDocument, cooked: '\n' + mutationDocument }, true)],
        []
      )
    ),
  ]);
  statements.push(t.exportNamedDeclaration(mutationDocConst));

  const inputFields = scalarFields
    .filter((f) => !isAutoGeneratedField(f.name, pkFieldNames))
    .map((f) => {
      const prop = t.tsPropertySignature(
        t.identifier(f.name),
        t.tsTypeAnnotation(
          t.tsUnionType([
            t.tsTypeReference(t.identifier(fieldTypeToTs(f.type))),
            t.tsNullKeyword(),
          ])
        )
      );
      prop.optional = true;
      return prop;
    });

  const createInputInterface = t.tsInterfaceDeclaration(
    t.identifier(`${typeName}CreateInput`),
    null,
    null,
    t.tsInterfaceBody(inputFields)
  );
  addJSDocComment(createInputInterface, [`Input type for creating a ${typeName}`]);
  statements.push(createInputInterface);

  const variablesInterfaceBody = t.tsInterfaceBody([
    t.tsPropertySignature(
      t.identifier('input'),
      t.tsTypeAnnotation(
        t.tsTypeLiteral([
          t.tsPropertySignature(
            t.identifier(lcFirst(typeName)),
            t.tsTypeAnnotation(t.tsTypeReference(t.identifier(`${typeName}CreateInput`)))
          ),
        ])
      )
    ),
  ]);
  const variablesInterface = t.tsInterfaceDeclaration(
    t.identifier(`${ucFirst(mutationName)}MutationVariables`),
    null,
    null,
    variablesInterfaceBody
  );
  statements.push(t.exportNamedDeclaration(variablesInterface));

  const resultInterfaceBody = t.tsInterfaceBody([
    t.tsPropertySignature(
      t.identifier(mutationName),
      t.tsTypeAnnotation(
        t.tsTypeLiteral([
          t.tsPropertySignature(
            t.identifier(singularName),
            t.tsTypeAnnotation(t.tsTypeReference(t.identifier(typeName)))
          ),
        ])
      )
    ),
  ]);
  const resultInterface = t.tsInterfaceDeclaration(
    t.identifier(`${ucFirst(mutationName)}MutationResult`),
    null,
    null,
    resultInterfaceBody
  );
  statements.push(t.exportNamedDeclaration(resultInterface));

  const hookBodyStatements: t.Statement[] = [];
  hookBodyStatements.push(
    t.variableDeclaration('const', [
      t.variableDeclarator(
        t.identifier('queryClient'),
        t.callExpression(t.identifier('useQueryClient'), [])
      ),
    ])
  );

    const mutationOptions: (t.ObjectProperty | t.SpreadElement)[] = [];
    if (useCentralizedKeys) {
      mutationOptions.push(
        t.objectProperty(
          t.identifier('mutationKey'),
          t.callExpression(
            t.memberExpression(t.identifier(mutationKeysName), t.identifier('create')),
            []
          )
        )
      );
    }
    mutationOptions.push(
      t.objectProperty(
        t.identifier('mutationFn'),
        t.arrowFunctionExpression(
          [typedParam('variables', t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationVariables`)))],
          createTypedCallExpression(
            t.identifier('execute'),
            [t.identifier(`${mutationName}MutationDocument`), t.identifier('variables')],
            [
              t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationResult`)),
              t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationVariables`)),
            ]
          )
        )
      )
    );

  const invalidateQueryKey = useCentralizedKeys
    ? t.callExpression(t.memberExpression(t.identifier(keysName), t.identifier('lists')), [])
    : t.arrayExpression([t.stringLiteral(typeName.toLowerCase()), t.stringLiteral('list')]);

  mutationOptions.push(
    t.objectProperty(
      t.identifier('onSuccess'),
      t.arrowFunctionExpression(
        [],
        t.blockStatement([
          t.expressionStatement(
            t.callExpression(
              t.memberExpression(t.identifier('queryClient'), t.identifier('invalidateQueries')),
              [t.objectExpression([t.objectProperty(t.identifier('queryKey'), invalidateQueryKey)])]
            )
          ),
        ])
      )
    )
  );
  mutationOptions.push(t.spreadElement(t.identifier('options')));

  hookBodyStatements.push(
    t.returnStatement(
      t.callExpression(t.identifier('useMutation'), [t.objectExpression(mutationOptions)])
    )
  );

  const optionsTypeStr = `Omit<UseMutationOptions<${ucFirst(mutationName)}MutationResult, Error, ${ucFirst(mutationName)}MutationVariables>, 'mutationFn'>`;
  const optionsParam = t.identifier('options');
  optionsParam.optional = true;
  optionsParam.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(optionsTypeStr)));

  const hookFunc = t.functionDeclaration(
    t.identifier(hookName),
    [optionsParam],
    t.blockStatement(hookBodyStatements)
  );
  const hookExport = t.exportNamedDeclaration(hookFunc);
  addJSDocComment(hookExport, [
    `Mutation hook for creating a ${typeName}`,
    '',
    '@example',
    '```tsx',
    `const { mutate, isPending } = ${hookName}();`,
    '',
    'mutate({',
    '  input: {',
    `    ${lcFirst(typeName)}: {`,
    '      // ... fields',
    '    },',
    '  },',
    '});',
    '```',
  ]);
  statements.push(hookExport);

  const code = generateCode(statements);
  const content = getGeneratedFileHeader(`Create mutation hook for ${typeName}`) + '\n\n' + code;

  return {
    fileName: getCreateMutationFileName(table),
    content,
  };
}

export function generateUpdateMutationHook(
  table: CleanTable,
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile | null {
  const {
    reactQueryEnabled = true,
    enumsFromSchemaTypes = [],
    useCentralizedKeys = true,
    hasRelationships = false,
    tableTypeNames = new Set<string>(),
  } = options;

  if (!reactQueryEnabled) {
    return null;
  }

  if (table.query?.update === null) {
    return null;
  }

  const enumSet = new Set(enumsFromSchemaTypes);
  const { typeName, singularName } = getTableNames(table);
  const hookName = getUpdateMutationHookName(table);
  const mutationName = getUpdateMutationName(table);
  const scalarFields = getScalarFields(table);
  const keysName = `${lcFirst(typeName)}Keys`;
  const mutationKeysName = `${lcFirst(typeName)}MutationKeys`;
  const scopeTypeName = `${typeName}Scope`;

  const pkFields = getPrimaryKeyInfo(table);
  const pkField = pkFields[0];
  const pkFieldNames = new Set(pkFields.map((pk) => pk.name));

  const usedEnums = new Set<string>();
  const usedTableTypes = new Set<string>();
  for (const field of scalarFields) {
    const cleanType = field.type.gqlType.replace(/!/g, '');
    if (enumSet.has(cleanType)) {
      usedEnums.add(cleanType);
    } else if (tableTypeNames.has(cleanType) && cleanType !== typeName) {
      usedTableTypes.add(cleanType);
    }
  }

  const mutationAST = buildUpdateMutationAST({ table });
  const mutationDocument = printGraphQL(mutationAST);

  const statements: t.Statement[] = [];

  const reactQueryImport = t.importDeclaration(
    [
      t.importSpecifier(t.identifier('useMutation'), t.identifier('useMutation')),
      t.importSpecifier(t.identifier('useQueryClient'), t.identifier('useQueryClient')),
    ],
    t.stringLiteral('@tanstack/react-query')
  );
  statements.push(reactQueryImport);

  const reactQueryTypeImport = t.importDeclaration(
    [t.importSpecifier(t.identifier('UseMutationOptions'), t.identifier('UseMutationOptions'))],
    t.stringLiteral('@tanstack/react-query')
  );
  reactQueryTypeImport.importKind = 'type';
  statements.push(reactQueryTypeImport);

  const clientImport = t.importDeclaration(
    [t.importSpecifier(t.identifier('execute'), t.identifier('execute'))],
    t.stringLiteral('../client')
  );
  statements.push(clientImport);

  // Import the main type and any other table types used in scalar fields
  const allTypesToImportUpdate = [typeName, ...Array.from(usedTableTypes)].sort();
  const typesImport = t.importDeclaration(
    allTypesToImportUpdate.map((t_) => t.importSpecifier(t.identifier(t_), t.identifier(t_))),
    t.stringLiteral('../types')
  );
  typesImport.importKind = 'type';
  statements.push(typesImport);

  if (usedEnums.size > 0) {
    const enumImport = t.importDeclaration(
      Array.from(usedEnums).sort().map((e) => t.importSpecifier(t.identifier(e), t.identifier(e))),
      t.stringLiteral('../schema-types')
    );
    enumImport.importKind = 'type';
    statements.push(enumImport);
  }

  if (useCentralizedKeys) {
    const queryKeyImport = t.importDeclaration(
      [t.importSpecifier(t.identifier(keysName), t.identifier(keysName))],
      t.stringLiteral('../query-keys')
    );
    statements.push(queryKeyImport);
    if (hasRelationships) {
      const scopeTypeImport = t.importDeclaration(
        [t.importSpecifier(t.identifier(scopeTypeName), t.identifier(scopeTypeName))],
        t.stringLiteral('../query-keys')
      );
      scopeTypeImport.importKind = 'type';
      statements.push(scopeTypeImport);
    }
    const mutationKeyImport = t.importDeclaration(
      [t.importSpecifier(t.identifier(mutationKeysName), t.identifier(mutationKeysName))],
      t.stringLiteral('../mutation-keys')
    );
    statements.push(mutationKeyImport);
  }

  const reExportDecl = t.exportNamedDeclaration(
    null,
    [t.exportSpecifier(t.identifier(typeName), t.identifier(typeName))],
    t.stringLiteral('../types')
  );
  reExportDecl.exportKind = 'type';
  statements.push(reExportDecl);

  const mutationDocConst = t.variableDeclaration('const', [
    t.variableDeclarator(
      t.identifier(`${mutationName}MutationDocument`),
      t.templateLiteral(
        [t.templateElement({ raw: '\n' + mutationDocument, cooked: '\n' + mutationDocument }, true)],
        []
      )
    ),
  ]);
  statements.push(t.exportNamedDeclaration(mutationDocConst));

  const patchFields = scalarFields
    .filter((f) => !pkFieldNames.has(f.name))
    .map((f) => {
      const prop = t.tsPropertySignature(
        t.identifier(f.name),
        t.tsTypeAnnotation(
          t.tsUnionType([
            t.tsTypeReference(t.identifier(fieldTypeToTs(f.type))),
            t.tsNullKeyword(),
          ])
        )
      );
      prop.optional = true;
      return prop;
    });

  const patchInterface = t.tsInterfaceDeclaration(
    t.identifier(`${typeName}Patch`),
    null,
    null,
    t.tsInterfaceBody(patchFields)
  );
  addJSDocComment(patchInterface, [`Patch type for updating a ${typeName} - all fields optional`]);
  statements.push(patchInterface);

  const pkTypeAnnotation =
    pkField.tsType === 'string'
      ? t.tsStringKeyword()
      : pkField.tsType === 'number'
        ? t.tsNumberKeyword()
        : t.tsTypeReference(t.identifier(pkField.tsType));

  const variablesInterfaceBody = t.tsInterfaceBody([
    t.tsPropertySignature(
      t.identifier('input'),
      t.tsTypeAnnotation(
        t.tsTypeLiteral([
          t.tsPropertySignature(t.identifier(pkField.name), t.tsTypeAnnotation(pkTypeAnnotation)),
          t.tsPropertySignature(
            t.identifier('patch'),
            t.tsTypeAnnotation(t.tsTypeReference(t.identifier(`${typeName}Patch`)))
          ),
        ])
      )
    ),
  ]);
  const variablesInterface = t.tsInterfaceDeclaration(
    t.identifier(`${ucFirst(mutationName)}MutationVariables`),
    null,
    null,
    variablesInterfaceBody
  );
  statements.push(t.exportNamedDeclaration(variablesInterface));

  const resultInterfaceBody = t.tsInterfaceBody([
    t.tsPropertySignature(
      t.identifier(mutationName),
      t.tsTypeAnnotation(
        t.tsTypeLiteral([
          t.tsPropertySignature(
            t.identifier(singularName),
            t.tsTypeAnnotation(t.tsTypeReference(t.identifier(typeName)))
          ),
        ])
      )
    ),
  ]);
  const resultInterface = t.tsInterfaceDeclaration(
    t.identifier(`${ucFirst(mutationName)}MutationResult`),
    null,
    null,
    resultInterfaceBody
  );
  statements.push(t.exportNamedDeclaration(resultInterface));

  const hookBodyStatements: t.Statement[] = [];
  hookBodyStatements.push(
    t.variableDeclaration('const', [
      t.variableDeclarator(
        t.identifier('queryClient'),
        t.callExpression(t.identifier('useQueryClient'), [])
      ),
    ])
  );

  const mutationOptions: (t.ObjectProperty | t.SpreadElement)[] = [];
  if (useCentralizedKeys) {
    mutationOptions.push(
      t.objectProperty(
        t.identifier('mutationKey'),
        t.memberExpression(t.identifier(mutationKeysName), t.identifier('all'))
      )
    );
  }
  mutationOptions.push(
    t.objectProperty(
      t.identifier('mutationFn'),
      t.arrowFunctionExpression(
        [typedParam('variables', t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationVariables`)))],
        createTypedCallExpression(
          t.identifier('execute'),
          [t.identifier(`${mutationName}MutationDocument`), t.identifier('variables')],
          [
            t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationResult`)),
            t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationVariables`)),
          ]
        )
      )
    )
  );

  const detailQueryKey = useCentralizedKeys
    ? t.callExpression(
        t.memberExpression(t.identifier(keysName), t.identifier('detail')),
        [t.memberExpression(t.memberExpression(t.identifier('variables'), t.identifier('input')), t.identifier(pkField.name))]
      )
    : t.arrayExpression([
        t.stringLiteral(typeName.toLowerCase()),
        t.stringLiteral('detail'),
        t.memberExpression(t.memberExpression(t.identifier('variables'), t.identifier('input')), t.identifier(pkField.name)),
      ]);

  const listQueryKey = useCentralizedKeys
    ? t.callExpression(t.memberExpression(t.identifier(keysName), t.identifier('lists')), [])
    : t.arrayExpression([t.stringLiteral(typeName.toLowerCase()), t.stringLiteral('list')]);

  mutationOptions.push(
    t.objectProperty(
      t.identifier('onSuccess'),
      t.arrowFunctionExpression(
        [t.identifier('_'), t.identifier('variables')],
        t.blockStatement([
          t.expressionStatement(
            t.callExpression(
              t.memberExpression(t.identifier('queryClient'), t.identifier('invalidateQueries')),
              [t.objectExpression([t.objectProperty(t.identifier('queryKey'), detailQueryKey)])]
            )
          ),
          t.expressionStatement(
            t.callExpression(
              t.memberExpression(t.identifier('queryClient'), t.identifier('invalidateQueries')),
              [t.objectExpression([t.objectProperty(t.identifier('queryKey'), listQueryKey)])]
            )
          ),
        ])
      )
    )
  );
  mutationOptions.push(t.spreadElement(t.identifier('options')));

  hookBodyStatements.push(
    t.returnStatement(
      t.callExpression(t.identifier('useMutation'), [t.objectExpression(mutationOptions)])
    )
  );

  const optionsTypeStr = `Omit<UseMutationOptions<${ucFirst(mutationName)}MutationResult, Error, ${ucFirst(mutationName)}MutationVariables>, 'mutationFn'>`;
  const optionsParam = t.identifier('options');
  optionsParam.optional = true;
  optionsParam.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(optionsTypeStr)));

  const hookFunc = t.functionDeclaration(
    t.identifier(hookName),
    [optionsParam],
    t.blockStatement(hookBodyStatements)
  );
  const hookExport = t.exportNamedDeclaration(hookFunc);
  addJSDocComment(hookExport, [
    `Mutation hook for updating a ${typeName}`,
    '',
    '@example',
    '```tsx',
    `const { mutate, isPending } = ${hookName}();`,
    '',
    'mutate({',
    '  input: {',
    `    ${pkField.name}: ${pkField.tsType === 'string' ? "'value-here'" : '123'},`,
    '    patch: {',
    '      // ... fields to update',
    '    },',
    '  },',
    '});',
    '```',
  ]);
  statements.push(hookExport);

  const code = generateCode(statements);
  const content = getGeneratedFileHeader(`Update mutation hook for ${typeName}`) + '\n\n' + code;

  return {
    fileName: getUpdateMutationFileName(table),
    content,
  };
}

export function generateDeleteMutationHook(
  table: CleanTable,
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile | null {
  const {
    reactQueryEnabled = true,
    useCentralizedKeys = true,
    hasRelationships = false,
  } = options;

  if (!reactQueryEnabled) {
    return null;
  }

  if (table.query?.delete === null) {
    return null;
  }

  const { typeName } = getTableNames(table);
  const hookName = getDeleteMutationHookName(table);
  const mutationName = getDeleteMutationName(table);
  const keysName = `${lcFirst(typeName)}Keys`;
  const mutationKeysName = `${lcFirst(typeName)}MutationKeys`;
  const scopeTypeName = `${typeName}Scope`;

  const pkFields = getPrimaryKeyInfo(table);
  const pkField = pkFields[0];

  const mutationAST = buildDeleteMutationAST({ table });
  const mutationDocument = printGraphQL(mutationAST);

  const statements: t.Statement[] = [];

  const reactQueryImport = t.importDeclaration(
    [
      t.importSpecifier(t.identifier('useMutation'), t.identifier('useMutation')),
      t.importSpecifier(t.identifier('useQueryClient'), t.identifier('useQueryClient')),
    ],
    t.stringLiteral('@tanstack/react-query')
  );
  statements.push(reactQueryImport);

  const reactQueryTypeImport = t.importDeclaration(
    [t.importSpecifier(t.identifier('UseMutationOptions'), t.identifier('UseMutationOptions'))],
    t.stringLiteral('@tanstack/react-query')
  );
  reactQueryTypeImport.importKind = 'type';
  statements.push(reactQueryTypeImport);

  const clientImport = t.importDeclaration(
    [t.importSpecifier(t.identifier('execute'), t.identifier('execute'))],
    t.stringLiteral('../client')
  );
  statements.push(clientImport);

  if (useCentralizedKeys) {
    const queryKeyImport = t.importDeclaration(
      [t.importSpecifier(t.identifier(keysName), t.identifier(keysName))],
      t.stringLiteral('../query-keys')
    );
    statements.push(queryKeyImport);
    if (hasRelationships) {
      const scopeTypeImport = t.importDeclaration(
        [t.importSpecifier(t.identifier(scopeTypeName), t.identifier(scopeTypeName))],
        t.stringLiteral('../query-keys')
      );
      scopeTypeImport.importKind = 'type';
      statements.push(scopeTypeImport);
    }
    const mutationKeyImport = t.importDeclaration(
      [t.importSpecifier(t.identifier(mutationKeysName), t.identifier(mutationKeysName))],
      t.stringLiteral('../mutation-keys')
    );
    statements.push(mutationKeyImport);
  }

  const mutationDocConst = t.variableDeclaration('const', [
    t.variableDeclarator(
      t.identifier(`${mutationName}MutationDocument`),
      t.templateLiteral(
        [t.templateElement({ raw: '\n' + mutationDocument, cooked: '\n' + mutationDocument }, true)],
        []
      )
    ),
  ]);
  statements.push(t.exportNamedDeclaration(mutationDocConst));

  const pkTypeAnnotation =
    pkField.tsType === 'string'
      ? t.tsStringKeyword()
      : pkField.tsType === 'number'
        ? t.tsNumberKeyword()
        : t.tsTypeReference(t.identifier(pkField.tsType));

  const variablesInterfaceBody = t.tsInterfaceBody([
    t.tsPropertySignature(
      t.identifier('input'),
      t.tsTypeAnnotation(
        t.tsTypeLiteral([
          t.tsPropertySignature(t.identifier(pkField.name), t.tsTypeAnnotation(pkTypeAnnotation)),
        ])
      )
    ),
  ]);
  const variablesInterface = t.tsInterfaceDeclaration(
    t.identifier(`${ucFirst(mutationName)}MutationVariables`),
    null,
    null,
    variablesInterfaceBody
  );
  statements.push(t.exportNamedDeclaration(variablesInterface));

  const clientMutationIdProp = t.tsPropertySignature(
    t.identifier('clientMutationId'),
    t.tsTypeAnnotation(t.tsUnionType([t.tsStringKeyword(), t.tsNullKeyword()]))
  );

  const resultInterfaceBody = t.tsInterfaceBody([
    t.tsPropertySignature(
      t.identifier(mutationName),
      t.tsTypeAnnotation(t.tsTypeLiteral([clientMutationIdProp]))
    ),
  ]);
  const resultInterface = t.tsInterfaceDeclaration(
    t.identifier(`${ucFirst(mutationName)}MutationResult`),
    null,
    null,
    resultInterfaceBody
  );
  statements.push(t.exportNamedDeclaration(resultInterface));

  const hookBodyStatements: t.Statement[] = [];
  hookBodyStatements.push(
    t.variableDeclaration('const', [
      t.variableDeclarator(
        t.identifier('queryClient'),
        t.callExpression(t.identifier('useQueryClient'), [])
      ),
    ])
  );

  const mutationOptions: (t.ObjectProperty | t.SpreadElement)[] = [];
  if (useCentralizedKeys) {
    mutationOptions.push(
      t.objectProperty(
        t.identifier('mutationKey'),
        t.memberExpression(t.identifier(mutationKeysName), t.identifier('all'))
      )
    );
  }
  mutationOptions.push(
    t.objectProperty(
      t.identifier('mutationFn'),
      t.arrowFunctionExpression(
        [typedParam('variables', t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationVariables`)))],
        createTypedCallExpression(
          t.identifier('execute'),
          [t.identifier(`${mutationName}MutationDocument`), t.identifier('variables')],
          [
            t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationResult`)),
            t.tsTypeReference(t.identifier(`${ucFirst(mutationName)}MutationVariables`)),
          ]
        )
      )
    )
  );

  const detailQueryKey = useCentralizedKeys
    ? t.callExpression(
        t.memberExpression(t.identifier(keysName), t.identifier('detail')),
        [t.memberExpression(t.memberExpression(t.identifier('variables'), t.identifier('input')), t.identifier(pkField.name))]
      )
    : t.arrayExpression([
        t.stringLiteral(typeName.toLowerCase()),
        t.stringLiteral('detail'),
        t.memberExpression(t.memberExpression(t.identifier('variables'), t.identifier('input')), t.identifier(pkField.name)),
      ]);

  const listQueryKey = useCentralizedKeys
    ? t.callExpression(t.memberExpression(t.identifier(keysName), t.identifier('lists')), [])
    : t.arrayExpression([t.stringLiteral(typeName.toLowerCase()), t.stringLiteral('list')]);

  mutationOptions.push(
    t.objectProperty(
      t.identifier('onSuccess'),
      t.arrowFunctionExpression(
        [t.identifier('_'), t.identifier('variables')],
        t.blockStatement([
          t.expressionStatement(
            t.callExpression(
              t.memberExpression(t.identifier('queryClient'), t.identifier('removeQueries')),
              [t.objectExpression([t.objectProperty(t.identifier('queryKey'), detailQueryKey)])]
            )
          ),
          t.expressionStatement(
            t.callExpression(
              t.memberExpression(t.identifier('queryClient'), t.identifier('invalidateQueries')),
              [t.objectExpression([t.objectProperty(t.identifier('queryKey'), listQueryKey)])]
            )
          ),
        ])
      )
    )
  );
  mutationOptions.push(t.spreadElement(t.identifier('options')));

  hookBodyStatements.push(
    t.returnStatement(
      t.callExpression(t.identifier('useMutation'), [t.objectExpression(mutationOptions)])
    )
  );

  const optionsTypeStr = `Omit<UseMutationOptions<${ucFirst(mutationName)}MutationResult, Error, ${ucFirst(mutationName)}MutationVariables>, 'mutationFn'>`;
  const optionsParam = t.identifier('options');
  optionsParam.optional = true;
  optionsParam.typeAnnotation = t.tsTypeAnnotation(t.tsTypeReference(t.identifier(optionsTypeStr)));

  const hookFunc = t.functionDeclaration(
    t.identifier(hookName),
    [optionsParam],
    t.blockStatement(hookBodyStatements)
  );
  const hookExport = t.exportNamedDeclaration(hookFunc);
  addJSDocComment(hookExport, [
    `Mutation hook for deleting a ${typeName}`,
    '',
    '@example',
    '```tsx',
    `const { mutate, isPending } = ${hookName}();`,
    '',
    'mutate({',
    '  input: {',
    `    ${pkField.name}: ${pkField.tsType === 'string' ? "'value-to-delete'" : '123'},`,
    '  },',
    '});',
    '```',
  ]);
  statements.push(hookExport);

  const code = generateCode(statements);
  const content = getGeneratedFileHeader(`Delete mutation hook for ${typeName}`) + '\n\n' + code;

  return {
    fileName: getDeleteMutationFileName(table),
    content,
  };
}

export function generateAllMutationHooks(
  tables: CleanTable[],
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile[] {
  const files: GeneratedMutationFile[] = [];

  for (const table of tables) {
    const createHook = generateCreateMutationHook(table, options);
    if (createHook) {
      files.push(createHook);
    }

    const updateHook = generateUpdateMutationHook(table, options);
    if (updateHook) {
      files.push(updateHook);
    }

    const deleteHook = generateDeleteMutationHook(table, options);
    if (deleteHook) {
      files.push(deleteHook);
    }
  }

  return files;
}
