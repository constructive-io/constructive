/**
 * Mutation hook generators using AST-based code generation
 *
 * Output structure:
 * mutations/
 *   useCreateCarMutation.ts
 *   useUpdateCarMutation.ts
 *   useDeleteCarMutation.ts
 */
import type { CleanTable } from '../../types/schema';
import {
  createProject,
  createSourceFile,
  getFormattedOutput,
  createFileHeader,
  createImport,
  createInterface,
  createConst,
  type InterfaceProperty,
} from './ts-ast';
import {
  buildCreateMutationAST,
  buildUpdateMutationAST,
  buildDeleteMutationAST,
  printGraphQL,
} from './gql-ast';
import {
  getTableNames,
  getCreateMutationHookName,
  getUpdateMutationHookName,
  getDeleteMutationHookName,
  getCreateMutationFileName,
  getUpdateMutationFileName,
  getDeleteMutationFileName,
  getCreateMutationName,
  getUpdateMutationName,
  getDeleteMutationName,
  getScalarFields,
  getPrimaryKeyInfo,
  fieldTypeToTs,
  ucFirst,
  lcFirst,
} from './utils';

/**
 * Check if a field is auto-generated and should be excluded from create inputs
 * Uses primary key from constraints and common timestamp patterns
 */
function isAutoGeneratedField(fieldName: string, pkFieldNames: Set<string>): boolean {
  const name = fieldName.toLowerCase();

  // Exclude primary key fields (from constraints)
  if (pkFieldNames.has(fieldName)) return true;

  // Exclude common timestamp patterns (case-insensitive)
  // These are typically auto-set by database triggers or defaults
  const timestampPatterns = [
    'createdat', 'created_at', 'createddate', 'created_date',
    'updatedat', 'updated_at', 'updateddate', 'updated_date',
    'deletedat', 'deleted_at', // soft delete timestamps
  ];

  return timestampPatterns.includes(name);
}

export interface GeneratedMutationFile {
  fileName: string;
  content: string;
}

export interface MutationGeneratorOptions {
  /** Whether to generate React Query hooks (default: true for backwards compatibility) */
  reactQueryEnabled?: boolean;
  /** Enum type names that are available from schema-types.ts */
  enumsFromSchemaTypes?: string[];
}

// ============================================================================
// Create mutation hook generator
// ============================================================================

/**
 * Generate create mutation hook file content using AST
 * When reactQueryEnabled is false, returns null since mutations require React Query
 */
export function generateCreateMutationHook(
  table: CleanTable,
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile | null {
  const { reactQueryEnabled = true, enumsFromSchemaTypes = [] } = options;

  // Mutations require React Query - skip generation when disabled
  if (!reactQueryEnabled) {
    return null;
  }

  const enumSet = new Set(enumsFromSchemaTypes);

  const project = createProject();
  const { typeName, singularName } = getTableNames(table);
  const hookName = getCreateMutationHookName(table);
  const mutationName = getCreateMutationName(table);
  const scalarFields = getScalarFields(table);

  // Get primary key field names dynamically from table constraints
  const pkFieldNames = new Set(getPrimaryKeyInfo(table).map(pk => pk.name));

  // Collect which enums are used by this table's fields
  const usedEnums = new Set<string>();
  for (const field of scalarFields) {
    const cleanType = field.type.gqlType.replace(/!/g, '');
    if (enumSet.has(cleanType)) {
      usedEnums.add(cleanType);
    }
  }

  // Generate GraphQL document via AST
  const mutationAST = buildCreateMutationAST({ table });
  const mutationDocument = printGraphQL(mutationAST);

  const sourceFile = createSourceFile(project, getCreateMutationFileName(table));

  // Add file header
  sourceFile.insertText(0, createFileHeader(`Create mutation hook for ${typeName}`) + '\n\n');

  // Build import declarations
  const imports = [
    createImport({
      moduleSpecifier: '@tanstack/react-query',
      namedImports: ['useMutation', 'useQueryClient'],
      typeOnlyNamedImports: ['UseMutationOptions'],
    }),
    createImport({
      moduleSpecifier: '../client',
      namedImports: ['execute'],
    }),
    createImport({
      moduleSpecifier: '../types',
      typeOnlyNamedImports: [typeName],
    }),
  ];

  // Add import for enum types from schema-types if any are used
  if (usedEnums.size > 0) {
    imports.push(
      createImport({
        moduleSpecifier: '../schema-types',
        typeOnlyNamedImports: Array.from(usedEnums).sort(),
      })
    );
  }

  // Add imports
  sourceFile.addImportDeclarations(imports);

  // Re-export entity type
  sourceFile.addStatements(`\n// Re-export entity type for convenience\nexport type { ${typeName} };\n`);

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// GraphQL Document');
  sourceFile.addStatements('// ============================================================================\n');

  // Add mutation document constant
  sourceFile.addVariableStatement(
    createConst(`${mutationName}MutationDocument`, '`\n' + mutationDocument + '`')
  );

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// Types');
  sourceFile.addStatements('// ============================================================================\n');

  // Generate CreateInput type - exclude auto-generated fields
  // Note: Not exported to avoid conflicts with schema-types
  const inputFields: InterfaceProperty[] = scalarFields
    .filter((f) => !isAutoGeneratedField(f.name, pkFieldNames))
    .map((f) => ({
      name: f.name,
      type: `${fieldTypeToTs(f.type)} | null`,
      optional: true,
    }));

  sourceFile.addInterface(
    createInterface(`${typeName}CreateInput`, inputFields, {
      docs: [`Input type for creating a ${typeName}`],
      isExported: false,
    })
  );

  // Variables interface
  sourceFile.addInterface(
    createInterface(`${ucFirst(mutationName)}MutationVariables`, [
      {
        name: 'input',
        type: `{
    ${lcFirst(typeName)}: ${typeName}CreateInput;
  }`,
      },
    ])
  );

  // Result interface
  sourceFile.addInterface(
    createInterface(`${ucFirst(mutationName)}MutationResult`, [
      {
        name: mutationName,
        type: `{
    ${singularName}: ${typeName};
  }`,
      },
    ])
  );

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// Hook');
  sourceFile.addStatements('// ============================================================================\n');

  // Hook function
  sourceFile.addFunction({
    name: hookName,
    isExported: true,
    parameters: [
      {
        name: 'options',
        type: `Omit<UseMutationOptions<${ucFirst(mutationName)}MutationResult, Error, ${ucFirst(mutationName)}MutationVariables>, 'mutationFn'>`,
        hasQuestionToken: true,
      },
    ],
    statements: `const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (variables: ${ucFirst(mutationName)}MutationVariables) =>
      execute<${ucFirst(mutationName)}MutationResult, ${ucFirst(mutationName)}MutationVariables>(
        ${mutationName}MutationDocument,
        variables
      ),
    onSuccess: () => {
      // Invalidate list queries to refetch
      queryClient.invalidateQueries({ queryKey: ['${typeName.toLowerCase()}', 'list'] });
    },
    ...options,
  });`,
    docs: [
      {
        description: `Mutation hook for creating a ${typeName}

@example
\`\`\`tsx
const { mutate, isPending } = ${hookName}();

mutate({
  input: {
    ${lcFirst(typeName)}: {
      // ... fields
    },
  },
});
\`\`\``,
      },
    ],
  });

  return {
    fileName: getCreateMutationFileName(table),
    content: getFormattedOutput(sourceFile),
  };
}

// ============================================================================
// Update mutation hook generator
// ============================================================================

/**
 * Generate update mutation hook file content using AST
 * When reactQueryEnabled is false, returns null since mutations require React Query
 */
export function generateUpdateMutationHook(
  table: CleanTable,
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile | null {
  const { reactQueryEnabled = true, enumsFromSchemaTypes = [] } = options;

  // Mutations require React Query - skip generation when disabled
  if (!reactQueryEnabled) {
    return null;
  }

  // Check if update mutation exists
  if (table.query?.update === null) {
    return null;
  }

  const enumSet = new Set(enumsFromSchemaTypes);

  const project = createProject();
  const { typeName, singularName } = getTableNames(table);
  const hookName = getUpdateMutationHookName(table);
  const mutationName = getUpdateMutationName(table);
  const scalarFields = getScalarFields(table);

  // Get primary key info dynamically from table constraints
  const pkFields = getPrimaryKeyInfo(table);
  const pkField = pkFields[0]; // Use first PK field
  const pkFieldNames = new Set(pkFields.map(pk => pk.name));

  // Collect which enums are used by this table's fields
  const usedEnums = new Set<string>();
  for (const field of scalarFields) {
    const cleanType = field.type.gqlType.replace(/!/g, '');
    if (enumSet.has(cleanType)) {
      usedEnums.add(cleanType);
    }
  }

  // Generate GraphQL document via AST
  const mutationAST = buildUpdateMutationAST({ table });
  const mutationDocument = printGraphQL(mutationAST);

  const sourceFile = createSourceFile(project, getUpdateMutationFileName(table));

  // Add file header
  sourceFile.insertText(0, createFileHeader(`Update mutation hook for ${typeName}`) + '\n\n');

  // Build import declarations
  const imports = [
    createImport({
      moduleSpecifier: '@tanstack/react-query',
      namedImports: ['useMutation', 'useQueryClient'],
      typeOnlyNamedImports: ['UseMutationOptions'],
    }),
    createImport({
      moduleSpecifier: '../client',
      namedImports: ['execute'],
    }),
    createImport({
      moduleSpecifier: '../types',
      typeOnlyNamedImports: [typeName],
    }),
  ];

  // Add import for enum types from schema-types if any are used
  if (usedEnums.size > 0) {
    imports.push(
      createImport({
        moduleSpecifier: '../schema-types',
        typeOnlyNamedImports: Array.from(usedEnums).sort(),
      })
    );
  }

  // Add imports
  sourceFile.addImportDeclarations(imports);

  // Re-export entity type
  sourceFile.addStatements(`\n// Re-export entity type for convenience\nexport type { ${typeName} };\n`);

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// GraphQL Document');
  sourceFile.addStatements('// ============================================================================\n');

  // Add mutation document constant
  sourceFile.addVariableStatement(
    createConst(`${mutationName}MutationDocument`, '`\n' + mutationDocument + '`')
  );

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// Types');
  sourceFile.addStatements('// ============================================================================\n');

  // Generate Patch type - all fields optional, exclude primary key
  // Note: Not exported to avoid conflicts with schema-types
  const patchFields: InterfaceProperty[] = scalarFields
    .filter((f) => !pkFieldNames.has(f.name))
    .map((f) => ({
      name: f.name,
      type: `${fieldTypeToTs(f.type)} | null`,
      optional: true,
    }));

  sourceFile.addInterface(
    createInterface(`${typeName}Patch`, patchFields, {
      docs: [`Patch type for updating a ${typeName} - all fields optional`],
      isExported: false,
    })
  );

  // Variables interface - use dynamic PK field name and type
  sourceFile.addInterface(
    createInterface(`${ucFirst(mutationName)}MutationVariables`, [
      {
        name: 'input',
        type: `{
    ${pkField.name}: ${pkField.tsType};
    patch: ${typeName}Patch;
  }`,
      },
    ])
  );

  // Result interface
  sourceFile.addInterface(
    createInterface(`${ucFirst(mutationName)}MutationResult`, [
      {
        name: mutationName,
        type: `{
    ${singularName}: ${typeName};
  }`,
      },
    ])
  );

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// Hook');
  sourceFile.addStatements('// ============================================================================\n');

  // Hook function
  sourceFile.addFunction({
    name: hookName,
    isExported: true,
    parameters: [
      {
        name: 'options',
        type: `Omit<UseMutationOptions<${ucFirst(mutationName)}MutationResult, Error, ${ucFirst(mutationName)}MutationVariables>, 'mutationFn'>`,
        hasQuestionToken: true,
      },
    ],
    statements: `const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (variables: ${ucFirst(mutationName)}MutationVariables) =>
      execute<${ucFirst(mutationName)}MutationResult, ${ucFirst(mutationName)}MutationVariables>(
        ${mutationName}MutationDocument,
        variables
      ),
    onSuccess: (_, variables) => {
      // Invalidate specific item and list queries
      queryClient.invalidateQueries({ queryKey: ['${typeName.toLowerCase()}', 'detail', variables.input.${pkField.name}] });
      queryClient.invalidateQueries({ queryKey: ['${typeName.toLowerCase()}', 'list'] });
    },
    ...options,
  });`,
    docs: [
      {
        description: `Mutation hook for updating a ${typeName}

@example
\`\`\`tsx
const { mutate, isPending } = ${hookName}();

mutate({
  input: {
    ${pkField.name}: ${pkField.tsType === 'string' ? "'value-here'" : '123'},
    patch: {
      // ... fields to update
    },
  },
});
\`\`\``,
      },
    ],
  });

  return {
    fileName: getUpdateMutationFileName(table),
    content: getFormattedOutput(sourceFile),
  };
}

// ============================================================================
// Delete mutation hook generator
// ============================================================================

/**
 * Generate delete mutation hook file content using AST
 * When reactQueryEnabled is false, returns null since mutations require React Query
 */
export function generateDeleteMutationHook(
  table: CleanTable,
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile | null {
  const { reactQueryEnabled = true } = options;

  // Mutations require React Query - skip generation when disabled
  if (!reactQueryEnabled) {
    return null;
  }

  // Check if delete mutation exists
  if (table.query?.delete === null) {
    return null;
  }

  const project = createProject();
  const { typeName } = getTableNames(table);
  const hookName = getDeleteMutationHookName(table);
  const mutationName = getDeleteMutationName(table);

  // Get primary key info dynamically from table constraints
  const pkFields = getPrimaryKeyInfo(table);
  const pkField = pkFields[0]; // Use first PK field

  // Generate GraphQL document via AST
  const mutationAST = buildDeleteMutationAST({ table });
  const mutationDocument = printGraphQL(mutationAST);

  const sourceFile = createSourceFile(project, getDeleteMutationFileName(table));

  // Add file header
  sourceFile.insertText(0, createFileHeader(`Delete mutation hook for ${typeName}`) + '\n\n');

  // Add imports
  sourceFile.addImportDeclarations([
    createImport({
      moduleSpecifier: '@tanstack/react-query',
      namedImports: ['useMutation', 'useQueryClient'],
      typeOnlyNamedImports: ['UseMutationOptions'],
    }),
    createImport({
      moduleSpecifier: '../client',
      namedImports: ['execute'],
    }),
  ]);

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// GraphQL Document');
  sourceFile.addStatements('// ============================================================================\n');

  // Add mutation document constant
  sourceFile.addVariableStatement(
    createConst(`${mutationName}MutationDocument`, '`\n' + mutationDocument + '`')
  );

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// Types');
  sourceFile.addStatements('// ============================================================================\n');

  // Variables interface - use dynamic PK field name and type
  sourceFile.addInterface(
    createInterface(`${ucFirst(mutationName)}MutationVariables`, [
      {
        name: 'input',
        type: `{
    ${pkField.name}: ${pkField.tsType};
  }`,
      },
    ])
  );

  // Result interface
  sourceFile.addInterface(
    createInterface(`${ucFirst(mutationName)}MutationResult`, [
      {
        name: mutationName,
        type: `{
    clientMutationId: string | null;
    deleted${ucFirst(pkField.name)}: ${pkField.tsType} | null;
  }`,
      },
    ])
  );

  // Add section comment
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// Hook');
  sourceFile.addStatements('// ============================================================================\n');

  // Hook function
  sourceFile.addFunction({
    name: hookName,
    isExported: true,
    parameters: [
      {
        name: 'options',
        type: `Omit<UseMutationOptions<${ucFirst(mutationName)}MutationResult, Error, ${ucFirst(mutationName)}MutationVariables>, 'mutationFn'>`,
        hasQuestionToken: true,
      },
    ],
    statements: `const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (variables: ${ucFirst(mutationName)}MutationVariables) =>
      execute<${ucFirst(mutationName)}MutationResult, ${ucFirst(mutationName)}MutationVariables>(
        ${mutationName}MutationDocument,
        variables
      ),
    onSuccess: (_, variables) => {
      // Remove from cache and invalidate list
      queryClient.removeQueries({ queryKey: ['${typeName.toLowerCase()}', 'detail', variables.input.${pkField.name}] });
      queryClient.invalidateQueries({ queryKey: ['${typeName.toLowerCase()}', 'list'] });
    },
    ...options,
  });`,
    docs: [
      {
        description: `Mutation hook for deleting a ${typeName}

@example
\`\`\`tsx
const { mutate, isPending } = ${hookName}();

mutate({
  input: {
    ${pkField.name}: ${pkField.tsType === 'string' ? "'value-to-delete'" : '123'},
  },
});
\`\`\``,
      },
    ],
  });

  return {
    fileName: getDeleteMutationFileName(table),
    content: getFormattedOutput(sourceFile),
  };
}

// ============================================================================
// Batch generator
// ============================================================================

/**
 * Generate all mutation hook files for all tables
 * When reactQueryEnabled is false, returns empty array since mutations require React Query
 */
export function generateAllMutationHooks(
  tables: CleanTable[],
  options: MutationGeneratorOptions = {}
): GeneratedMutationFile[] {
  const files: GeneratedMutationFile[] = [];

  for (const table of tables) {
    const createHook = generateCreateMutationHook(table, options);
    if (createHook) {
      files.push(createHook);
    }

    const updateHook = generateUpdateMutationHook(table, options);
    if (updateHook) {
      files.push(updateHook);
    }

    const deleteHook = generateDeleteMutationHook(table, options);
    if (deleteHook) {
      files.push(deleteHook);
    }
  }

  return files;
}
