/**
 * Barrel file generators - creates index.ts files for exports
 *
 * Using simple string generation for barrel files since they're straightforward
 * and ts-morph has issues with insertText + addStatements combination.
 */
import type { CleanTable } from '../../types/schema';
import { createFileHeader } from './ts-ast';
import {
  getListQueryHookName,
  getSingleQueryHookName,
  getCreateMutationHookName,
  getUpdateMutationHookName,
  getDeleteMutationHookName,
} from './utils';
import { getOperationHookName } from './type-resolver';

/**
 * Generate the queries/index.ts barrel file
 */
export function generateQueriesBarrel(tables: CleanTable[]): string {
  const lines: string[] = [createFileHeader('Query hooks barrel export'), ''];

  // Export all query hooks
  for (const table of tables) {
    const listHookName = getListQueryHookName(table);
    const singleHookName = getSingleQueryHookName(table);

    lines.push(`export * from './${listHookName}';`);
    lines.push(`export * from './${singleHookName}';`);
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate the mutations/index.ts barrel file
 */
export function generateMutationsBarrel(tables: CleanTable[]): string {
  const lines: string[] = [
    createFileHeader('Mutation hooks barrel export'),
    '',
  ];

  // Export all mutation hooks
  for (const table of tables) {
    const createHookName = getCreateMutationHookName(table);
    const updateHookName = getUpdateMutationHookName(table);
    const deleteHookName = getDeleteMutationHookName(table);

    lines.push(`export * from './${createHookName}';`);

    // Only add update/delete if they exist
    if (table.query?.update !== null) {
      lines.push(`export * from './${updateHookName}';`);
    }
    if (table.query?.delete !== null) {
      lines.push(`export * from './${deleteHookName}';`);
    }
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate the main index.ts barrel file
 *
 * @param tables - The tables to include in the SDK
 * @param hasSchemaTypes - Whether schema-types.ts was generated
 */
export function generateMainBarrel(
  tables: CleanTable[],
  hasSchemaTypes: boolean = false
): string {
  const tableNames = tables.map((t) => t.name).join(', ');

  const schemaTypesExport = hasSchemaTypes
    ? `
// Schema types (input, payload, enum types)
export * from './schema-types';
`
    : '';

  return `/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 *
 * Tables: ${tableNames}
 *
 * Usage:
 *
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 *
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 *
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 *
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({ first: 10 });
 *   const { mutate } = useCreateCarMutation();
 *   // ...
 * }
 * \`\`\`
 */

// Client configuration
export * from './client';

// Entity and filter types
export * from './types';
${schemaTypesExport}
// Query hooks
export * from './queries';

// Mutation hooks
export * from './mutations';
`;
}

// ============================================================================
// Custom operation barrels (includes both table and custom hooks)
// ============================================================================

/**
 * Generate queries barrel including custom query operations
 */
export function generateCustomQueriesBarrel(
  tables: CleanTable[],
  customQueryNames: string[]
): string {
  const lines: string[] = [
    createFileHeader('Query hooks barrel export'),
    '',
    '// Table-based query hooks',
  ];

  // Export all table query hooks
  for (const table of tables) {
    const listHookName = getListQueryHookName(table);
    const singleHookName = getSingleQueryHookName(table);

    lines.push(`export * from './${listHookName}';`);
    lines.push(`export * from './${singleHookName}';`);
  }

  // Add custom query hooks
  if (customQueryNames.length > 0) {
    lines.push('');
    lines.push('// Custom query hooks');
    for (const name of customQueryNames) {
      const hookName = getOperationHookName(name, 'query');
      lines.push(`export * from './${hookName}';`);
    }
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate mutations barrel including custom mutation operations
 */
export function generateCustomMutationsBarrel(
  tables: CleanTable[],
  customMutationNames: string[]
): string {
  const lines: string[] = [
    createFileHeader('Mutation hooks barrel export'),
    '',
    '// Table-based mutation hooks',
  ];

  // Export all table mutation hooks
  for (const table of tables) {
    const createHookName = getCreateMutationHookName(table);
    const updateHookName = getUpdateMutationHookName(table);
    const deleteHookName = getDeleteMutationHookName(table);

    lines.push(`export * from './${createHookName}';`);

    // Only add update/delete if they exist
    if (table.query?.update !== null) {
      lines.push(`export * from './${updateHookName}';`);
    }
    if (table.query?.delete !== null) {
      lines.push(`export * from './${deleteHookName}';`);
    }
  }

  // Add custom mutation hooks
  if (customMutationNames.length > 0) {
    lines.push('');
    lines.push('// Custom mutation hooks');
    for (const name of customMutationNames) {
      const hookName = getOperationHookName(name, 'mutation');
      lines.push(`export * from './${hookName}';`);
    }
  }

  return lines.join('\n') + '\n';
}
