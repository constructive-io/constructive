/**
 * Barrel file generators - creates index.ts files for exports
 *
 * Using Babel AST for generating barrel (index.ts) files with re-exports.
 */
import type { CleanTable } from '../../types/schema';
import * as t from '@babel/types';
import { generateCode, addJSDocComment } from './babel-ast';
import {
  getListQueryHookName,
  getSingleQueryHookName,
  getCreateMutationHookName,
  getUpdateMutationHookName,
  getDeleteMutationHookName,
} from './utils';
import { getOperationHookName } from './type-resolver';

/**
 * Helper to create export * from './module' statement
 */
function exportAllFrom(modulePath: string): t.ExportAllDeclaration {
  return t.exportAllDeclaration(t.stringLiteral(modulePath));
}

/**
 * Generate the queries/index.ts barrel file
 */
export function generateQueriesBarrel(tables: CleanTable[]): string {
  const statements: t.Statement[] = [];

  // Export all query hooks
  for (const table of tables) {
    const listHookName = getListQueryHookName(table);
    const singleHookName = getSingleQueryHookName(table);

    statements.push(exportAllFrom(`./${listHookName}`));
    statements.push(exportAllFrom(`./${singleHookName}`));
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Query hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}

/**
 * Generate the mutations/index.ts barrel file
 */
export function generateMutationsBarrel(tables: CleanTable[]): string {
  const statements: t.Statement[] = [];

  // Export all mutation hooks
  for (const table of tables) {
    const createHookName = getCreateMutationHookName(table);
    const updateHookName = getUpdateMutationHookName(table);
    const deleteHookName = getDeleteMutationHookName(table);

    statements.push(exportAllFrom(`./${createHookName}`));

    // Only add update/delete if they exist
    if (table.query?.update !== null) {
      statements.push(exportAllFrom(`./${updateHookName}`));
    }
    if (table.query?.delete !== null) {
      statements.push(exportAllFrom(`./${deleteHookName}`));
    }
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Mutation hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}

/**
 * Generate the main index.ts barrel file
 *
 * @param tables - The tables to include in the SDK
 * @param hasSchemaTypes - Whether schema-types.ts was generated
 */
export interface MainBarrelOptions {
  hasSchemaTypes?: boolean;
  hasMutations?: boolean;
  /** Whether query-keys.ts was generated */
  hasQueryKeys?: boolean;
  /** Whether mutation-keys.ts was generated */
  hasMutationKeys?: boolean;
  /** Whether invalidation.ts was generated */
  hasInvalidation?: boolean;
}

export function generateMainBarrel(
  tables: CleanTable[],
  options: MainBarrelOptions | boolean = {}
): string {
  // Support legacy signature where second arg was just hasSchemaTypes boolean
  const opts: MainBarrelOptions =
    typeof options === 'boolean'
      ? { hasSchemaTypes: options, hasMutations: true }
      : options;

  const {
    hasSchemaTypes = false,
    hasMutations = true,
    hasQueryKeys = false,
    hasMutationKeys = false,
    hasInvalidation = false,
  } = opts;
  const tableNames = tables.map((tbl) => tbl.name).join(', ');

  const statements: t.Statement[] = [];

  // Client configuration
  statements.push(exportAllFrom('./client'));

  // Entity and filter types
  statements.push(exportAllFrom('./types'));

  // Schema types (input, payload, enum types)
  if (hasSchemaTypes) {
    statements.push(exportAllFrom('./schema-types'));
  }

  // Centralized query keys (for cache management)
  if (hasQueryKeys) {
    statements.push(exportAllFrom('./query-keys'));
  }

  // Centralized mutation keys (for tracking in-flight mutations)
  if (hasMutationKeys) {
    statements.push(exportAllFrom('./mutation-keys'));
  }

  // Cache invalidation helpers
  if (hasInvalidation) {
    statements.push(exportAllFrom('./invalidation'));
  }

  // Query hooks
  statements.push(exportAllFrom('./queries'));

  // Mutation hooks
  if (hasMutations) {
    statements.push(exportAllFrom('./mutations'));
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Auto-generated GraphQL SDK',
      '@generated by @constructive-io/graphql-codegen',
      '',
      `Tables: ${tableNames}`,
      '',
      'Usage:',
      '',
      '1. Configure the client:',
      '```ts',
      "import { configure } from './generated';",
      '',
      'configure({',
      "  endpoint: 'https://api.example.com/graphql',",
      "  headers: { Authorization: 'Bearer <token>' },",
      '});',
      '```',
      '',
      '2. Use the hooks:',
      '```tsx',
      "import { useCarsQuery, useCreateCarMutation } from './generated';",
      '',
      'function MyComponent() {',
      '  const { data, isLoading } = useCarsQuery({ first: 10 });',
      '  const { mutate } = useCreateCarMutation();',
      '  // ...',
      '}',
      '```',
    ]);
  }

  return generateCode(statements);
}

// ============================================================================
// Custom operation barrels (includes both table and custom hooks)
// ============================================================================

/**
 * Generate queries barrel including custom query operations
 */
export function generateCustomQueriesBarrel(
  tables: CleanTable[],
  customQueryNames: string[]
): string {
  const statements: t.Statement[] = [];

  // Export all table query hooks
  for (const table of tables) {
    const listHookName = getListQueryHookName(table);
    const singleHookName = getSingleQueryHookName(table);

    statements.push(exportAllFrom(`./${listHookName}`));
    statements.push(exportAllFrom(`./${singleHookName}`));
  }

  // Add custom query hooks
  for (const name of customQueryNames) {
    const hookName = getOperationHookName(name, 'query');
    statements.push(exportAllFrom(`./${hookName}`));
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Query hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}

/**
 * Generate mutations barrel including custom mutation operations
 */
export function generateCustomMutationsBarrel(
  tables: CleanTable[],
  customMutationNames: string[]
): string {
  const statements: t.Statement[] = [];

  // Export all table mutation hooks
  for (const table of tables) {
    const createHookName = getCreateMutationHookName(table);
    const updateHookName = getUpdateMutationHookName(table);
    const deleteHookName = getDeleteMutationHookName(table);

    statements.push(exportAllFrom(`./${createHookName}`));

    // Only add update/delete if they exist
    if (table.query?.update !== null) {
      statements.push(exportAllFrom(`./${updateHookName}`));
    }
    if (table.query?.delete !== null) {
      statements.push(exportAllFrom(`./${deleteHookName}`));
    }
  }

  // Add custom mutation hooks
  for (const name of customMutationNames) {
    const hookName = getOperationHookName(name, 'mutation');
    statements.push(exportAllFrom(`./${hookName}`));
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Mutation hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}
