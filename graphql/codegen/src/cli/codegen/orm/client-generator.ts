/**
 * ORM Client generator (Babel AST-based)
 *
 * Generates the createClient() factory function and main client file.
 */
import type { CleanTable } from '../../../types/schema';
import * as t from '@babel/types';
import { generateCode, commentBlock } from '../babel-ast';
import { getTableNames, lcFirst, getGeneratedFileHeader } from '../utils';
export interface GeneratedClientFile {
  fileName: string;
  content: string;
}

/**
 * Generate the main client.ts file (OrmClient class)
 * This is the runtime client that handles GraphQL execution
 */
export function generateOrmClientFile(): GeneratedClientFile {
  // This is runtime code that doesn't change based on schema
  // We generate it as a static file
  const content = `/**
 * ORM Client - Runtime GraphQL executor
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

export interface OrmClientConfig {
  endpoint: string;
  headers?: Record<string, string>;
}

export interface GraphQLError {
  message: string;
  locations?: { line: number; column: number }[];
  path?: (string | number)[];
  extensions?: Record<string, unknown>;
}

/**
 * Error thrown when GraphQL request fails
 */
export class GraphQLRequestError extends Error {
  constructor(
    public readonly errors: GraphQLError[],
    public readonly data: unknown = null
  ) {
    const messages = errors.map(e => e.message).join('; ');
    super(\`GraphQL Error: \${messages}\`);
    this.name = 'GraphQLRequestError';
  }
}

/**
 * Discriminated union for query results
 * Use .ok to check success, or use .unwrap() to get data or throw
 */
export type QueryResult<T> =
  | { ok: true; data: T; errors: undefined }
  | { ok: false; data: null; errors: GraphQLError[] };

/**
 * Legacy QueryResult type for backwards compatibility
 * @deprecated Use QueryResult discriminated union instead
 */
export interface LegacyQueryResult<T> {
  data: T | null;
  errors?: GraphQLError[];
}

export class OrmClient {
  private endpoint: string;
  private headers: Record<string, string>;

  constructor(config: OrmClientConfig) {
    this.endpoint = config.endpoint;
    this.headers = config.headers ?? {};
  }

  async execute<T>(
    document: string,
    variables?: Record<string, unknown>
  ): Promise<QueryResult<T>> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
        ...this.headers,
      },
      body: JSON.stringify({
        query: document,
        variables: variables ?? {},
      }),
    });

    if (!response.ok) {
      return {
        ok: false,
        data: null,
        errors: [{ message: \`HTTP \${response.status}: \${response.statusText}\` }],
      };
    }

    const json = (await response.json()) as {
      data?: T;
      errors?: GraphQLError[];
    };

    // Return discriminated union based on presence of errors
    if (json.errors && json.errors.length > 0) {
      return {
        ok: false,
        data: null,
        errors: json.errors,
      };
    }

    return {
      ok: true,
      data: json.data as T,
      errors: undefined,
    };
  }

  setHeaders(headers: Record<string, string>): void {
    this.headers = { ...this.headers, ...headers };
  }

  getEndpoint(): string {
    return this.endpoint;
  }
}
`;

  return {
    fileName: 'client.ts',
    content,
  };
}

/**
 * Generate the query-builder.ts file (runtime query builder)
 */
export function generateQueryBuilderFile(): GeneratedClientFile {
  const content = `/**
 * Query Builder - Builds and executes GraphQL operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import * as t from 'gql-ast';
import { parseType, print } from 'graphql';
import type {
  ArgumentNode,
  FieldNode,
  VariableDefinitionNode,
  EnumValueNode,
} from 'graphql';
import { OrmClient, QueryResult, GraphQLRequestError } from './client';

export interface QueryBuilderConfig {
  client: OrmClient;
  operation: 'query' | 'mutation';
  operationName: string;
  fieldName: string;
  document: string;
  variables?: Record<string, unknown>;
}

export class QueryBuilder<TResult> {
  private config: QueryBuilderConfig;

  constructor(config: QueryBuilderConfig) {
    this.config = config;
  }

  /**
   * Execute the query and return a discriminated union result
   * Use result.ok to check success, or .unwrap() to throw on error
   */
  async execute(): Promise<QueryResult<TResult>> {
    return this.config.client.execute<TResult>(
      this.config.document,
      this.config.variables
    );
  }

  /**
   * Execute and unwrap the result, throwing GraphQLRequestError on failure
   * @throws {GraphQLRequestError} If the query returns errors
   */
  async unwrap(): Promise<TResult> {
    const result = await this.execute();
    if (!result.ok) {
      throw new GraphQLRequestError(result.errors, result.data);
    }
    return result.data;
  }

  /**
   * Execute and unwrap, returning defaultValue on error instead of throwing
   */
  async unwrapOr<D>(defaultValue: D): Promise<TResult | D> {
    const result = await this.execute();
    if (!result.ok) {
      return defaultValue;
    }
    return result.data;
  }

  /**
   * Execute and unwrap, calling onError callback on failure
   */
  async unwrapOrElse<D>(onError: (errors: import('./client').GraphQLError[]) => D): Promise<TResult | D> {
    const result = await this.execute();
    if (!result.ok) {
      return onError(result.errors);
    }
    return result.data;
  }

  toGraphQL(): string {
    return this.config.document;
  }

  getVariables(): Record<string, unknown> | undefined {
    return this.config.variables;
  }
}

// ============================================================================
// Selection Builders
// ============================================================================

export function buildSelections(
  select: Record<string, unknown> | undefined
): FieldNode[] {
  if (!select) {
    return [];
  }

  const fields: FieldNode[] = [];

  for (const [key, value] of Object.entries(select)) {
    if (value === false || value === undefined) {
      continue;
    }

    if (value === true) {
      fields.push(t.field({ name: key }));
      continue;
    }

    if (typeof value === 'object' && value !== null) {
      const nested = value as {
        select?: Record<string, unknown>;
        first?: number;
        filter?: Record<string, unknown>;
        orderBy?: string[];
        connection?: boolean;
      };

      if (nested.select) {
        const nestedSelections = buildSelections(nested.select);
        const isConnection =
          nested.connection === true ||
          nested.first !== undefined ||
          nested.filter !== undefined;
        const args = buildArgs([
          buildOptionalArg('first', nested.first),
          nested.filter
            ? t.argument({ name: 'filter', value: buildValueAst(nested.filter) })
            : null,
          buildEnumListArg('orderBy', nested.orderBy),
        ]);

        if (isConnection) {
          fields.push(
            t.field({
              name: key,
              args,
              selectionSet: t.selectionSet({
                selections: buildConnectionSelections(nestedSelections),
              }),
            })
          );
        } else {
          fields.push(
            t.field({
              name: key,
              args,
              selectionSet: t.selectionSet({ selections: nestedSelections }),
            })
          );
        }
      }
    }
  }

  return fields;
}

// ============================================================================
// Document Builders
// ============================================================================

export function buildFindManyDocument<TSelect, TWhere>(
  operationName: string,
  queryField: string,
  select: TSelect,
  args: {
    where?: TWhere;
    orderBy?: string[];
    first?: number;
    last?: number;
    after?: string;
    before?: string;
    offset?: number;
  },
  filterTypeName: string,
  orderByTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select
    ? buildSelections(select as Record<string, unknown>)
    : [t.field({ name: 'id' })];

  const variableDefinitions: VariableDefinitionNode[] = [];
  const queryArgs: ArgumentNode[] = [];
  const variables: Record<string, unknown> = {};

  addVariable({ varName: 'where', argName: 'filter', typeName: filterTypeName, value: args.where }, variableDefinitions, queryArgs, variables);
  addVariable({ varName: 'orderBy', typeName: '[' + orderByTypeName + '!]', value: args.orderBy?.length ? args.orderBy : undefined }, variableDefinitions, queryArgs, variables);
  addVariable({ varName: 'first', typeName: 'Int', value: args.first }, variableDefinitions, queryArgs, variables);
  addVariable({ varName: 'last', typeName: 'Int', value: args.last }, variableDefinitions, queryArgs, variables);
  addVariable({ varName: 'after', typeName: 'Cursor', value: args.after }, variableDefinitions, queryArgs, variables);
  addVariable({ varName: 'before', typeName: 'Cursor', value: args.before }, variableDefinitions, queryArgs, variables);
  addVariable({ varName: 'offset', typeName: 'Int', value: args.offset }, variableDefinitions, queryArgs, variables);

  const document = t.document({
    definitions: [
      t.operationDefinition({
        operation: 'query',
        name: operationName + 'Query',
        variableDefinitions: variableDefinitions.length ? variableDefinitions : undefined,
        selectionSet: t.selectionSet({
          selections: [
            t.field({
              name: queryField,
              args: queryArgs.length ? queryArgs : undefined,
              selectionSet: t.selectionSet({
                selections: buildConnectionSelections(selections),
              }),
            }),
          ],
        }),
      }),
    ],
  });

  return { document: print(document), variables };
}

export function buildFindFirstDocument<TSelect, TWhere>(
  operationName: string,
  queryField: string,
  select: TSelect,
  args: { where?: TWhere },
  filterTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select
    ? buildSelections(select as Record<string, unknown>)
    : [t.field({ name: 'id' })];

  const variableDefinitions: VariableDefinitionNode[] = [];
  const queryArgs: ArgumentNode[] = [];
  const variables: Record<string, unknown> = {};

  // Always add first: 1 for findFirst
  addVariable({ varName: 'first', typeName: 'Int', value: 1 }, variableDefinitions, queryArgs, variables);
  addVariable({ varName: 'where', argName: 'filter', typeName: filterTypeName, value: args.where }, variableDefinitions, queryArgs, variables);

  const document = t.document({
    definitions: [
      t.operationDefinition({
        operation: 'query',
        name: operationName + 'Query',
        variableDefinitions,
        selectionSet: t.selectionSet({
          selections: [
            t.field({
              name: queryField,
              args: queryArgs,
              selectionSet: t.selectionSet({
                selections: [
                  t.field({
                    name: 'nodes',
                    selectionSet: t.selectionSet({ selections }),
                  }),
                ],
              }),
            }),
          ],
        }),
      }),
    ],
  });

  return { document: print(document), variables };
}

export function buildCreateDocument<TSelect, TData>(
  operationName: string,
  mutationField: string,
  entityField: string,
  select: TSelect,
  data: TData,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select
    ? buildSelections(select as Record<string, unknown>)
    : [t.field({ name: 'id' })];

  return {
    document: buildInputMutationDocument({
      operationName,
      mutationField,
      inputTypeName,
      resultSelections: [
        t.field({
          name: entityField,
          selectionSet: t.selectionSet({ selections }),
        }),
      ],
    }),
    variables: {
      input: {
        [entityField]: data,
      },
    },
  };
}

export function buildUpdateDocument<TSelect, TWhere extends { id: string }, TData>(
  operationName: string,
  mutationField: string,
  entityField: string,
  select: TSelect,
  where: TWhere,
  data: TData,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select
    ? buildSelections(select as Record<string, unknown>)
    : [t.field({ name: 'id' })];

  return {
    document: buildInputMutationDocument({
      operationName,
      mutationField,
      inputTypeName,
      resultSelections: [
        t.field({
          name: entityField,
          selectionSet: t.selectionSet({ selections }),
        }),
      ],
    }),
    variables: {
      input: {
        id: where.id,
        patch: data,
      },
    },
  };
}

export function buildDeleteDocument<TWhere extends { id: string }>(
  operationName: string,
  mutationField: string,
  entityField: string,
  where: TWhere,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  return {
    document: buildInputMutationDocument({
      operationName,
      mutationField,
      inputTypeName,
      resultSelections: [
        t.field({
          name: entityField,
          selectionSet: t.selectionSet({
            selections: [t.field({ name: 'id' })],
          }),
        }),
      ],
    }),
    variables: {
      input: {
        id: where.id,
      },
    },
  };
}

export function buildCustomDocument<TSelect, TArgs>(
  operationType: 'query' | 'mutation',
  operationName: string,
  fieldName: string,
  select: TSelect,
  args: TArgs,
  variableDefinitions: Array<{ name: string; type: string }>
): { document: string; variables: Record<string, unknown> } {
  let actualSelect = select;
  let isConnection = false;

  if (select && typeof select === 'object' && 'select' in select) {
    const wrapper = select as { select?: TSelect; connection?: boolean };
    if (wrapper.select) {
      actualSelect = wrapper.select;
      isConnection = wrapper.connection === true;
    }
  }

  const selections = actualSelect
    ? buildSelections(actualSelect as Record<string, unknown>)
    : [];

  const variableDefs = variableDefinitions.map((definition) =>
    t.variableDefinition({
      variable: t.variable({ name: definition.name }),
      type: parseType(definition.type),
    })
  );
  const fieldArgs = variableDefinitions.map((definition) =>
    t.argument({
      name: definition.name,
      value: t.variable({ name: definition.name }),
    })
  );

  const fieldSelections = isConnection
    ? buildConnectionSelections(selections)
    : selections;

  const document = t.document({
    definitions: [
      t.operationDefinition({
        operation: operationType,
        name: operationName,
        variableDefinitions: variableDefs.length ? variableDefs : undefined,
        selectionSet: t.selectionSet({
          selections: [
            t.field({
              name: fieldName,
              args: fieldArgs.length ? fieldArgs : undefined,
              selectionSet: fieldSelections.length
                ? t.selectionSet({ selections: fieldSelections })
                : undefined,
            }),
          ],
        }),
      }),
    ],
  });

  return {
    document: print(document),
    variables: (args ?? {}) as Record<string, unknown>,
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

function buildArgs(args: Array<ArgumentNode | null>): ArgumentNode[] {
  return args.filter((arg): arg is ArgumentNode => arg !== null);
}

function buildOptionalArg(
  name: string,
  value: number | string | undefined
): ArgumentNode | null {
  if (value === undefined) {
    return null;
  }
  const valueNode =
    typeof value === 'number'
      ? t.intValue({ value: value.toString() })
      : t.stringValue({ value });
  return t.argument({ name, value: valueNode });
}

function buildEnumListArg(
  name: string,
  values: string[] | undefined
): ArgumentNode | null {
  if (!values || values.length === 0) {
    return null;
  }
  return t.argument({
    name,
    value: t.listValue({
      values: values.map((value) => buildEnumValue(value)),
    }),
  });
}

function buildEnumValue(value: string): EnumValueNode {
  return {
    kind: 'EnumValue',
    value,
  };
}

function buildPageInfoSelections(): FieldNode[] {
  return [
    t.field({ name: 'hasNextPage' }),
    t.field({ name: 'hasPreviousPage' }),
    t.field({ name: 'startCursor' }),
    t.field({ name: 'endCursor' }),
  ];
}

function buildConnectionSelections(nodeSelections: FieldNode[]): FieldNode[] {
  return [
    t.field({
      name: 'nodes',
      selectionSet: t.selectionSet({ selections: nodeSelections }),
    }),
    t.field({ name: 'totalCount' }),
    t.field({
      name: 'pageInfo',
      selectionSet: t.selectionSet({ selections: buildPageInfoSelections() }),
    }),
  ];
}

interface VariableSpec {
  varName: string;
  argName?: string;
  typeName: string;
  value: unknown;
}

interface InputMutationConfig {
  operationName: string;
  mutationField: string;
  inputTypeName: string;
  resultSelections: FieldNode[];
}

function buildInputMutationDocument(config: InputMutationConfig): string {
  const document = t.document({
    definitions: [
      t.operationDefinition({
        operation: 'mutation',
        name: config.operationName + 'Mutation',
        variableDefinitions: [
          t.variableDefinition({
            variable: t.variable({ name: 'input' }),
            type: parseType(config.inputTypeName + '!'),
          }),
        ],
        selectionSet: t.selectionSet({
          selections: [
            t.field({
              name: config.mutationField,
              args: [
                t.argument({
                  name: 'input',
                  value: t.variable({ name: 'input' }),
                }),
              ],
              selectionSet: t.selectionSet({
                selections: config.resultSelections,
              }),
            }),
          ],
        }),
      }),
    ],
  });
  return print(document);
}

function addVariable(
  spec: VariableSpec,
  definitions: VariableDefinitionNode[],
  args: ArgumentNode[],
  variables: Record<string, unknown>
): void {
  if (spec.value === undefined) return;

  definitions.push(
    t.variableDefinition({
      variable: t.variable({ name: spec.varName }),
      type: parseType(spec.typeName),
    })
  );
  args.push(
    t.argument({
      name: spec.argName ?? spec.varName,
      value: t.variable({ name: spec.varName }),
    })
  );
  variables[spec.varName] = spec.value;
}

function buildValueAst(
  value: unknown
):
  | ReturnType<typeof t.stringValue>
  | ReturnType<typeof t.intValue>
  | ReturnType<typeof t.floatValue>
  | ReturnType<typeof t.booleanValue>
  | ReturnType<typeof t.listValue>
  | ReturnType<typeof t.objectValue>
  | ReturnType<typeof t.nullValue>
  | EnumValueNode {
  if (value === null) {
    return t.nullValue();
  }

  if (typeof value === 'boolean') {
    return t.booleanValue({ value });
  }

  if (typeof value === 'number') {
    return Number.isInteger(value)
      ? t.intValue({ value: value.toString() })
      : t.floatValue({ value: value.toString() });
  }

  if (typeof value === 'string') {
    return t.stringValue({ value });
  }

  if (Array.isArray(value)) {
    return t.listValue({
      values: value.map((item) => buildValueAst(item)),
    });
  }

  if (typeof value === 'object' && value !== null) {
    const obj = value as Record<string, unknown>;
    return t.objectValue({
      fields: Object.entries(obj).map(([key, val]) =>
        t.objectField({
          name: key,
          value: buildValueAst(val),
        })
      ),
    });
  }

  throw new Error('Unsupported value type: ' + typeof value);
}
`;

  return {
    fileName: 'query-builder.ts',
    content,
  };
}

/**
 * Generate the select-types.ts file
 */
export function generateSelectTypesFile(): GeneratedClientFile {
  const content = `/**
 * Type utilities for select inference
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

export interface ConnectionResult<T> {
  nodes: T[];
  totalCount: number;
  pageInfo: PageInfo;
}

export interface PageInfo {
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: string | null;
  endCursor?: string | null;
}

export interface FindManyArgs<TSelect, TWhere, TOrderBy> {
  select?: TSelect;
  where?: TWhere;
  orderBy?: TOrderBy[];
  first?: number;
  last?: number;
  after?: string;
  before?: string;
  offset?: number;
}

export interface FindFirstArgs<TSelect, TWhere> {
  select?: TSelect;
  where?: TWhere;
}

export interface CreateArgs<TSelect, TData> {
  data: TData;
  select?: TSelect;
}

export interface UpdateArgs<TSelect, TWhere, TData> {
  where: TWhere;
  data: TData;
  select?: TSelect;
}

export interface DeleteArgs<TWhere> {
  where: TWhere;
}

/**
 * Recursively validates select objects, rejecting unknown keys.
 *
 * This type ensures that users can only select fields that actually exist
 * in the GraphQL schema. It returns \`never\` if any excess keys are found
 * at any nesting level, causing a TypeScript compile error.
 *
 * Why this is needed:
 * TypeScript's excess property checking has a quirk where it only catches
 * invalid fields when they are the ONLY fields. When mixed with valid fields
 * (e.g., \`{ id: true, invalidField: true }\`), the structural typing allows
 * the excess property through. This type explicitly checks for and rejects
 * such cases.
 *
 * @example
 * // This will cause a type error because 'invalid' doesn't exist:
 * type Result = DeepExact<{ id: true, invalid: true }, { id?: boolean }>;
 * // Result = never (causes assignment error)
 *
 * @example
 * // This works because all fields are valid:
 * type Result = DeepExact<{ id: true }, { id?: boolean; name?: boolean }>;
 * // Result = { id: true }
 */
export type DeepExact<T, Shape> = T extends Shape
  ? Exclude<keyof T, keyof Shape> extends never
    ? {
        [K in keyof T]: K extends keyof Shape
          ? T[K] extends { select: infer NS }
            ? Shape[K] extends { select?: infer ShapeNS }
              ? { select: DeepExact<NS, NonNullable<ShapeNS>> }
              : T[K]
            : T[K]
          : never;
      }
    : never
  : never;

/**
 * Infer result type from select configuration
 */
export type InferSelectResult<TEntity, TSelect> = TSelect extends undefined
  ? TEntity
  : {
      [K in keyof TSelect as TSelect[K] extends false | undefined ? never : K]: TSelect[K] extends true
        ? K extends keyof TEntity
          ? TEntity[K]
          : never
        : TSelect[K] extends { select: infer NestedSelect }
          ? K extends keyof TEntity
            ? NonNullable<TEntity[K]> extends ConnectionResult<infer NodeType>
              ? ConnectionResult<InferSelectResult<NodeType, NestedSelect>>
              : InferSelectResult<NonNullable<TEntity[K]>, NestedSelect> | (null extends TEntity[K] ? null : never)
            : never
          : K extends keyof TEntity
            ? TEntity[K]
            : never;
    };
`;

  return {
    fileName: 'select-types.ts',
    content,
  };
}

function createImportDeclaration(
  moduleSpecifier: string,
  namedImports: string[],
  typeOnly: boolean = false
): t.ImportDeclaration {
  const specifiers = namedImports.map((name) =>
    t.importSpecifier(t.identifier(name), t.identifier(name))
  );
  const decl = t.importDeclaration(
    specifiers,
    t.stringLiteral(moduleSpecifier)
  );
  decl.importKind = typeOnly ? 'type' : 'value';
  return decl;
}

/**
 * Generate the main index.ts with createClient factory
 */
export function generateCreateClientFile(
  tables: CleanTable[],
  hasCustomQueries: boolean,
  hasCustomMutations: boolean
): GeneratedClientFile {
  const statements: t.Statement[] = [];

  // Add imports
  // Import OrmClient (value) and OrmClientConfig (type) separately
  statements.push(createImportDeclaration('./client', ['OrmClient']));
  statements.push(
    createImportDeclaration('./client', ['OrmClientConfig'], true)
  );

  // Import models
  for (const table of tables) {
    const { typeName } = getTableNames(table);
    const modelName = `${typeName}Model`;
    const fileName = lcFirst(typeName);
    statements.push(
      createImportDeclaration(`./models/${fileName}`, [modelName])
    );
  }

  // Import custom operations
  if (hasCustomQueries) {
    statements.push(
      createImportDeclaration('./query', ['createQueryOperations'])
    );
  }
  if (hasCustomMutations) {
    statements.push(
      createImportDeclaration('./mutation', ['createMutationOperations'])
    );
  }

  // Re-export types and classes
  // export type { OrmClientConfig, QueryResult, GraphQLError } from './client';
  const typeExportDecl = t.exportNamedDeclaration(
    null,
    [
      t.exportSpecifier(
        t.identifier('OrmClientConfig'),
        t.identifier('OrmClientConfig')
      ),
      t.exportSpecifier(
        t.identifier('QueryResult'),
        t.identifier('QueryResult')
      ),
      t.exportSpecifier(
        t.identifier('GraphQLError'),
        t.identifier('GraphQLError')
      ),
    ],
    t.stringLiteral('./client')
  );
  typeExportDecl.exportKind = 'type';
  statements.push(typeExportDecl);

  // export { GraphQLRequestError } from './client';
  statements.push(
    t.exportNamedDeclaration(
      null,
      [
        t.exportSpecifier(
          t.identifier('GraphQLRequestError'),
          t.identifier('GraphQLRequestError')
        ),
      ],
      t.stringLiteral('./client')
    )
  );

  // export { QueryBuilder } from './query-builder';
  statements.push(
    t.exportNamedDeclaration(
      null,
      [
        t.exportSpecifier(
          t.identifier('QueryBuilder'),
          t.identifier('QueryBuilder')
        ),
      ],
      t.stringLiteral('./query-builder')
    )
  );

  // export * from './select-types';
  statements.push(t.exportAllDeclaration(t.stringLiteral('./select-types')));

  // Build the return object properties
  const returnProperties: t.ObjectProperty[] = [];

  for (const table of tables) {
    const { typeName, singularName } = getTableNames(table);
    const modelName = `${typeName}Model`;
    returnProperties.push(
      t.objectProperty(
        t.identifier(singularName),
        t.newExpression(t.identifier(modelName), [t.identifier('client')])
      )
    );
  }

  if (hasCustomQueries) {
    returnProperties.push(
      t.objectProperty(
        t.identifier('query'),
        t.callExpression(t.identifier('createQueryOperations'), [
          t.identifier('client'),
        ])
      )
    );
  }

  if (hasCustomMutations) {
    returnProperties.push(
      t.objectProperty(
        t.identifier('mutation'),
        t.callExpression(t.identifier('createMutationOperations'), [
          t.identifier('client'),
        ])
      )
    );
  }

  // Build the createClient function body
  const clientDecl = t.variableDeclaration('const', [
    t.variableDeclarator(
      t.identifier('client'),
      t.newExpression(t.identifier('OrmClient'), [t.identifier('config')])
    ),
  ]);

  const returnStmt = t.returnStatement(t.objectExpression(returnProperties));

  const configParam = t.identifier('config');
  configParam.typeAnnotation = t.tsTypeAnnotation(
    t.tsTypeReference(t.identifier('OrmClientConfig'))
  );

  const createClientFunc = t.functionDeclaration(
    t.identifier('createClient'),
    [configParam],
    t.blockStatement([clientDecl, returnStmt])
  );

  // Add JSDoc comment
  const jsdocComment = commentBlock(`*
 * Create an ORM client instance
 *
 * @example
 * \`\`\`typescript
 * const db = createClient({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer token' },
 * });
 *
 * // Query users
 * const users = await db.user.findMany({
 *   select: { id: true, name: true },
 *   first: 10,
 * }).execute();
 *
 * // Create a user
 * const newUser = await db.user.create({
 *   data: { name: 'John', email: 'john@example.com' },
 *   select: { id: true },
 * }).execute();
 * \`\`\`
 `);

  const exportedFunc = t.exportNamedDeclaration(createClientFunc);
  exportedFunc.leadingComments = [jsdocComment];
  statements.push(exportedFunc);

  const header = getGeneratedFileHeader('ORM Client - createClient factory');
  const code = generateCode(statements);

  return {
    fileName: 'index.ts',
    content: header + '\n' + code,
  };
}
