/**
 * ORM Client generator
 *
 * Generates the createClient() factory function and main client file.
 *
 * Example output:
 * ```typescript
 * import { OrmClient, OrmClientConfig } from './client';
 * import { UserModel } from './models/user';
 * import { queryOperations } from './query';
 * import { mutationOperations } from './mutation';
 *
 * export function createClient(config: OrmClientConfig) {
 *   const client = new OrmClient(config);
 *   return {
 *     user: new UserModel(client),
 *     post: new PostModel(client),
 *     query: queryOperations(client),
 *     mutation: mutationOperations(client),
 *   };
 * }
 * ```
 */
import type { CleanTable } from '../../../types/schema';
import {
  createProject,
  createSourceFile,
  getFormattedOutput,
  createFileHeader,
  createImport,
} from '../ts-ast';
import { getTableNames, lcFirst } from '../utils';

export interface GeneratedClientFile {
  fileName: string;
  content: string;
}

/**
 * Generate the main client.ts file (OrmClient class)
 * This is the runtime client that handles GraphQL execution
 */
export function generateOrmClientFile(): GeneratedClientFile {
  // This is runtime code that doesn't change based on schema
  // We generate it as a static file
  const content = `/**
 * ORM Client - Runtime GraphQL executor
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

export interface OrmClientConfig {
  endpoint: string;
  headers?: Record<string, string>;
}

export interface GraphQLError {
  message: string;
  locations?: { line: number; column: number }[];
  path?: (string | number)[];
  extensions?: Record<string, unknown>;
}

/**
 * Error thrown when GraphQL request fails
 */
export class GraphQLRequestError extends Error {
  constructor(
    public readonly errors: GraphQLError[],
    public readonly data: unknown = null
  ) {
    const messages = errors.map(e => e.message).join('; ');
    super(\`GraphQL Error: \${messages}\`);
    this.name = 'GraphQLRequestError';
  }
}

/**
 * Discriminated union for query results
 * Use .ok to check success, or use .unwrap() to get data or throw
 */
export type QueryResult<T> =
  | { ok: true; data: T; errors: undefined }
  | { ok: false; data: null; errors: GraphQLError[] };

/**
 * Legacy QueryResult type for backwards compatibility
 * @deprecated Use QueryResult discriminated union instead
 */
export interface LegacyQueryResult<T> {
  data: T | null;
  errors?: GraphQLError[];
}

export class OrmClient {
  private endpoint: string;
  private headers: Record<string, string>;

  constructor(config: OrmClientConfig) {
    this.endpoint = config.endpoint;
    this.headers = config.headers ?? {};
  }

  async execute<T>(
    document: string,
    variables?: Record<string, unknown>
  ): Promise<QueryResult<T>> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
        ...this.headers,
      },
      body: JSON.stringify({
        query: document,
        variables: variables ?? {},
      }),
    });

    if (!response.ok) {
      return {
        ok: false,
        data: null,
        errors: [{ message: \`HTTP \${response.status}: \${response.statusText}\` }],
      };
    }

    const json = (await response.json()) as {
      data?: T;
      errors?: GraphQLError[];
    };

    // Return discriminated union based on presence of errors
    if (json.errors && json.errors.length > 0) {
      return {
        ok: false,
        data: null,
        errors: json.errors,
      };
    }

    return {
      ok: true,
      data: json.data as T,
      errors: undefined,
    };
  }

  setHeaders(headers: Record<string, string>): void {
    this.headers = { ...this.headers, ...headers };
  }

  getEndpoint(): string {
    return this.endpoint;
  }
}
`;

  return {
    fileName: 'client.ts',
    content,
  };
}

/**
 * Generate the query-builder.ts file (runtime query builder)
 */
export function generateQueryBuilderFile(): GeneratedClientFile {
  const content = `/**
 * Query Builder - Builds and executes GraphQL operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { OrmClient, QueryResult, GraphQLRequestError } from './client';

export interface QueryBuilderConfig {
  client: OrmClient;
  operation: 'query' | 'mutation';
  operationName: string;
  fieldName: string;
  document: string;
  variables?: Record<string, unknown>;
}

export class QueryBuilder<TResult> {
  private config: QueryBuilderConfig;

  constructor(config: QueryBuilderConfig) {
    this.config = config;
  }

  /**
   * Execute the query and return a discriminated union result
   * Use result.ok to check success, or .unwrap() to throw on error
   */
  async execute(): Promise<QueryResult<TResult>> {
    return this.config.client.execute<TResult>(
      this.config.document,
      this.config.variables
    );
  }

  /**
   * Execute and unwrap the result, throwing GraphQLRequestError on failure
   * @throws {GraphQLRequestError} If the query returns errors
   */
  async unwrap(): Promise<TResult> {
    const result = await this.execute();
    if (!result.ok) {
      throw new GraphQLRequestError(result.errors, result.data);
    }
    return result.data;
  }

  /**
   * Execute and unwrap, returning defaultValue on error instead of throwing
   */
  async unwrapOr<D>(defaultValue: D): Promise<TResult | D> {
    const result = await this.execute();
    if (!result.ok) {
      return defaultValue;
    }
    return result.data;
  }

  /**
   * Execute and unwrap, calling onError callback on failure
   */
  async unwrapOrElse<D>(onError: (errors: import('./client').GraphQLError[]) => D): Promise<TResult | D> {
    const result = await this.execute();
    if (!result.ok) {
      return onError(result.errors);
    }
    return result.data;
  }

  toGraphQL(): string {
    return this.config.document;
  }

  getVariables(): Record<string, unknown> | undefined {
    return this.config.variables;
  }
}

// ============================================================================
// Document Builders
// ============================================================================

export function buildSelections<T>(select: T): string {
  if (!select) return '';

  const fields: string[] = [];

  for (const [key, value] of Object.entries(select)) {
    if (value === false || value === undefined) continue;

    if (value === true) {
      fields.push(key);
      continue;
    }

    if (typeof value === 'object' && value !== null) {
      const nested = value as {
        select?: Record<string, unknown>;
        first?: number;
        filter?: Record<string, unknown>;
        orderBy?: string[];
        // New: connection flag to differentiate connection types from regular objects
        connection?: boolean;
      };

      if (nested.select) {
        const nestedSelections = buildSelections(nested.select);
        
        // Check if this is a connection type (has pagination args or explicit connection flag)
        const isConnection = nested.connection === true || nested.first !== undefined || nested.filter !== undefined;
        
        if (isConnection) {
          // Connection type - wrap in nodes/totalCount/pageInfo
          const args: string[] = [];
          if (nested.first !== undefined) args.push(\`first: \${nested.first}\`);
          if (nested.orderBy?.length) args.push(\`orderBy: [\${nested.orderBy.join(', ')}]\`);
          const argsStr = args.length > 0 ? \`(\${args.join(', ')})\` : '';

          fields.push(\`\${key}\${argsStr} {
      nodes { \${nestedSelections} }
      totalCount
      pageInfo { hasNextPage hasPreviousPage startCursor endCursor }
    }\`);
        } else {
          // Regular nested object - just wrap in braces
          fields.push(\`\${key} { \${nestedSelections} }\`);
        }
      }
    }
  }

  return fields.join('\\n    ');
}

export function buildFindManyDocument<TSelect, TWhere>(
  operationName: string,
  queryField: string,
  select: TSelect,
  args: {
    where?: TWhere;
    orderBy?: string[];
    first?: number;
    last?: number;
    after?: string;
    before?: string;
    offset?: number;
  },
  filterTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const varDefs: string[] = [];
  const queryArgs: string[] = [];
  const variables: Record<string, unknown> = {};

  if (args.where) {
    varDefs.push(\`$where: \${filterTypeName}\`);
    queryArgs.push('filter: $where');
    variables.where = args.where;
  }
  if (args.orderBy?.length) {
    varDefs.push(\`$orderBy: [\${operationName}sOrderBy!]\`);
    queryArgs.push('orderBy: $orderBy');
    variables.orderBy = args.orderBy;
  }
  if (args.first !== undefined) {
    varDefs.push('$first: Int');
    queryArgs.push('first: $first');
    variables.first = args.first;
  }
  if (args.last !== undefined) {
    varDefs.push('$last: Int');
    queryArgs.push('last: $last');
    variables.last = args.last;
  }
  if (args.after) {
    varDefs.push('$after: Cursor');
    queryArgs.push('after: $after');
    variables.after = args.after;
  }
  if (args.before) {
    varDefs.push('$before: Cursor');
    queryArgs.push('before: $before');
    variables.before = args.before;
  }
  if (args.offset !== undefined) {
    varDefs.push('$offset: Int');
    queryArgs.push('offset: $offset');
    variables.offset = args.offset;
  }

  const varDefsStr = varDefs.length > 0 ? \`(\${varDefs.join(', ')})\` : '';
  const queryArgsStr = queryArgs.length > 0 ? \`(\${queryArgs.join(', ')})\` : '';

  const document = \`query \${operationName}Query\${varDefsStr} {
  \${queryField}\${queryArgsStr} {
    nodes { \${selections} }
    totalCount
    pageInfo { hasNextPage hasPreviousPage startCursor endCursor }
  }
}\`;

  return { document, variables };
}

export function buildFindFirstDocument<TSelect, TWhere>(
  operationName: string,
  queryField: string,
  select: TSelect,
  args: { where?: TWhere },
  filterTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const varDefs: string[] = ['$first: Int'];
  const queryArgs: string[] = ['first: $first'];
  const variables: Record<string, unknown> = { first: 1 };

  if (args.where) {
    varDefs.push(\`$where: \${filterTypeName}\`);
    queryArgs.push('filter: $where');
    variables.where = args.where;
  }

  const document = \`query \${operationName}Query(\${varDefs.join(', ')}) {
  \${queryField}(\${queryArgs.join(', ')}) {
    nodes { \${selections} }
  }
}\`;

  return { document, variables };
}

export function buildCreateDocument<TSelect, TData>(
  operationName: string,
  mutationField: string,
  entityField: string,
  select: TSelect,
  data: TData,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const document = \`mutation \${operationName}Mutation($input: \${inputTypeName}!) {
  \${mutationField}(input: $input) {
    \${entityField} { \${selections} }
  }
}\`;

  return {
    document,
    variables: { input: { [entityField]: data } },
  };
}

export function buildUpdateDocument<TSelect, TWhere extends { id: string }, TData>(
  operationName: string,
  mutationField: string,
  entityField: string,
  select: TSelect,
  where: TWhere,
  data: TData,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : 'id';

  const document = \`mutation \${operationName}Mutation($input: \${inputTypeName}!) {
  \${mutationField}(input: $input) {
    \${entityField} { \${selections} }
  }
}\`;

  return {
    document,
    variables: { input: { id: where.id, patch: data } },
  };
}

export function buildDeleteDocument<TWhere extends { id: string }>(
  operationName: string,
  mutationField: string,
  entityField: string,
  where: TWhere,
  inputTypeName: string
): { document: string; variables: Record<string, unknown> } {
  const document = \`mutation \${operationName}Mutation($input: \${inputTypeName}!) {
  \${mutationField}(input: $input) {
    \${entityField} { id }
  }
}\`;

  return {
    document,
    variables: { input: { id: where.id } },
  };
}

export function buildCustomDocument<TSelect, TArgs>(
  operationType: 'query' | 'mutation',
  operationName: string,
  fieldName: string,
  select: TSelect,
  args: TArgs,
  variableDefinitions: Array<{ name: string; type: string }>
): { document: string; variables: Record<string, unknown> } {
  const selections = select ? buildSelections(select) : '';
  
  const varDefs = variableDefinitions.map(v => \`$\${v.name}: \${v.type}\`);
  const fieldArgs = variableDefinitions.map(v => \`\${v.name}: $\${v.name}\`);
  
  const varDefsStr = varDefs.length > 0 ? \`(\${varDefs.join(', ')})\` : '';
  const fieldArgsStr = fieldArgs.length > 0 ? \`(\${fieldArgs.join(', ')})\` : '';
  const selectionsBlock = selections ? \` { \${selections} }\` : '';
  
  const opType = operationType === 'query' ? 'query' : 'mutation';
  const document = \`\${opType} \${operationName}\${varDefsStr} {
  \${fieldName}\${fieldArgsStr}\${selectionsBlock}
}\`;

  return { document, variables: (args ?? {}) as Record<string, unknown> };
}
`;

  return {
    fileName: 'query-builder.ts',
    content,
  };
}

/**
 * Generate the select-types.ts file
 */
export function generateSelectTypesFile(): GeneratedClientFile {
  const content = `/**
 * Type utilities for select inference
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

export interface ConnectionResult<T> {
  nodes: T[];
  totalCount: number;
  pageInfo: PageInfo;
}

export interface PageInfo {
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: string | null;
  endCursor?: string | null;
}

export interface FindManyArgs<TSelect, TWhere, TOrderBy> {
  select?: TSelect;
  where?: TWhere;
  orderBy?: TOrderBy[];
  first?: number;
  last?: number;
  after?: string;
  before?: string;
  offset?: number;
}

export interface FindFirstArgs<TSelect, TWhere> {
  select?: TSelect;
  where?: TWhere;
}

export interface CreateArgs<TSelect, TData> {
  data: TData;
  select?: TSelect;
}

export interface UpdateArgs<TSelect, TWhere, TData> {
  where: TWhere;
  data: TData;
  select?: TSelect;
}

export interface DeleteArgs<TWhere> {
  where: TWhere;
}

/**
 * Infer result type from select configuration
 */
export type InferSelectResult<TEntity, TSelect> = TSelect extends undefined
  ? TEntity
  : {
      [K in keyof TSelect as TSelect[K] extends false | undefined ? never : K]: TSelect[K] extends true
        ? K extends keyof TEntity
          ? TEntity[K]
          : never
        : TSelect[K] extends { select: infer NestedSelect }
          ? K extends keyof TEntity
            ? NonNullable<TEntity[K]> extends ConnectionResult<infer NodeType>
              ? ConnectionResult<InferSelectResult<NodeType, NestedSelect>>
              : InferSelectResult<NonNullable<TEntity[K]>, NestedSelect> | (null extends TEntity[K] ? null : never)
            : never
          : K extends keyof TEntity
            ? TEntity[K]
            : never;
    };
`;

  return {
    fileName: 'select-types.ts',
    content,
  };
}

/**
 * Generate the main index.ts with createClient factory
 */
export function generateCreateClientFile(
  tables: CleanTable[],
  hasCustomQueries: boolean,
  hasCustomMutations: boolean
): GeneratedClientFile {
  const project = createProject();
  const sourceFile = createSourceFile(project, 'index.ts');

  // Add file header
  sourceFile.insertText(
    0,
    createFileHeader('ORM Client - createClient factory') + '\n\n'
  );

  // Add imports
  const imports = [
    createImport({
      moduleSpecifier: './client',
      namedImports: ['OrmClient'],
      typeOnlyNamedImports: ['OrmClientConfig'],
    }),
  ];

  // Import models
  for (const table of tables) {
    const { typeName } = getTableNames(table);
    const modelName = `${typeName}Model`;
    const fileName = lcFirst(typeName);
    imports.push(
      createImport({
        moduleSpecifier: `./models/${fileName}`,
        namedImports: [modelName],
      })
    );
  }

  // Import custom operations
  if (hasCustomQueries) {
    imports.push(
      createImport({
        moduleSpecifier: './query',
        namedImports: ['createQueryOperations'],
      })
    );
  }
  if (hasCustomMutations) {
    imports.push(
      createImport({
        moduleSpecifier: './mutation',
        namedImports: ['createMutationOperations'],
      })
    );
  }

  sourceFile.addImportDeclarations(imports);

  // Re-export types and classes
  sourceFile.addStatements('\n// Re-export types and classes');
  sourceFile.addStatements("export type { OrmClientConfig, QueryResult, GraphQLError } from './client';");
  sourceFile.addStatements("export { GraphQLRequestError } from './client';");
  sourceFile.addStatements("export { QueryBuilder } from './query-builder';");
  sourceFile.addStatements("export * from './select-types';");

  // Generate createClient function
  sourceFile.addStatements('\n// ============================================================================');
  sourceFile.addStatements('// Client Factory');
  sourceFile.addStatements('// ============================================================================\n');

  // Build the return object
  const modelEntries = tables.map((table) => {
    const { typeName, singularName } = getTableNames(table);
    return `${singularName}: new ${typeName}Model(client)`;
  });

  let returnObject = modelEntries.join(',\n    ');
  if (hasCustomQueries) {
    returnObject += ',\n    query: createQueryOperations(client)';
  }
  if (hasCustomMutations) {
    returnObject += ',\n    mutation: createMutationOperations(client)';
  }

  sourceFile.addFunction({
    name: 'createClient',
    isExported: true,
    parameters: [{ name: 'config', type: 'OrmClientConfig' }],
    statements: `const client = new OrmClient(config);
  
  return {
    ${returnObject},
  };`,
    docs: [
      {
        description: `Create an ORM client instance

@example
\`\`\`typescript
const db = createClient({
  endpoint: 'https://api.example.com/graphql',
  headers: { Authorization: 'Bearer token' },
});

// Query users
const users = await db.user.findMany({
  select: { id: true, name: true },
  first: 10,
}).execute();

// Create a user
const newUser = await db.user.create({
  data: { name: 'John', email: 'john@example.com' },
  select: { id: true },
}).execute();
\`\`\``,
      },
    ],
  });

  return {
    fileName: 'index.ts',
    content: getFormattedOutput(sourceFile),
  };
}
