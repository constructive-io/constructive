/**
 * TypeScript AST builders using ts-morph
 * 
 * Provides utilities for generating TypeScript code via AST manipulation
 * instead of string concatenation.
 */
import {
  Project,
  SourceFile,
  StructureKind,
  VariableDeclarationKind,
  ScriptTarget,
  ModuleKind,
  type InterfaceDeclarationStructure,
  type PropertySignatureStructure,
  type FunctionDeclarationStructure,
  type VariableStatementStructure,
  type ImportDeclarationStructure,
  type TypeAliasDeclarationStructure,
} from 'ts-morph';

// ============================================================================
// Project management
// ============================================================================

/**
 * Create a new ts-morph project for code generation
 */
export function createProject(): Project {
  return new Project({
    useInMemoryFileSystem: true,
    compilerOptions: {
      declaration: true,
      strict: true,
      target: ScriptTarget.ESNext,
      module: ModuleKind.ESNext,
    },
  });
}

/**
 * Create a source file in the project
 */
export function createSourceFile(project: Project, fileName: string): SourceFile {
  return project.createSourceFile(fileName, '', { overwrite: true });
}

/**
 * Get formatted output from source file
 */
export function getFormattedOutput(sourceFile: SourceFile): string {
  sourceFile.formatText({
    indentSize: 2,
    convertTabsToSpaces: true,
  });
  return sourceFile.getFullText();
}

/**
 * Get output with minimal formatting (preserves intentional blank lines)
 * Post-processes to fix indentation and section comment spacing
 * 
 * ts-morph generates type alias bodies with extra indentation:
 * - Properties get 6 spaces (we want 2)
 * - Closing brace gets 4 spaces (we want 0)
 * 
 * For interfaces it uses 4 spaces which we convert to 2.
 */
export function getMinimalFormattedOutput(sourceFile: SourceFile): string {
  let text = sourceFile.getFullText();
  
  // Process each line to fix indentation
  // ts-morph uses inconsistent indentation for type alias bodies
  // We halve all indentation: 4->2, 6->3 (rounds to 2), 8->4, etc.
  text = text.split('\n').map(line => {
    // Match leading whitespace
    const match = line.match(/^(\s*)/);
    if (!match) return line;
    
    const spaces = match[1].length;
    const content = line.slice(spaces);
    
    // Skip empty lines
    if (content === '') return line;
    
    // No indentation - keep as-is
    if (spaces === 0) return line;
    
    // Halve the indentation (minimum 0)
    const newSpaces = Math.floor(spaces / 2);
    return ' '.repeat(newSpaces) + content;
  }).join('\n');
  
  // Ensure blank line after section comment blocks
  text = text.replace(
    /(\/\/ =+\n\/\/ .+\n\/\/ =+)\n(export|\/\/)/g,
    '$1\n\n$2'
  );
  
  // Add blank line between consecutive export declarations (type aliases, interfaces)
  // Pattern: "}\nexport" or ";\nexport" should become "}\n\nexport" or ";\n\nexport"
  text = text.replace(/(\}|\;)\n(export )/g, '$1\n\n$2');
  
  // Remove trailing extra blank lines at end of file
  text = text.replace(/\n\n+$/, '\n');
  
  return text;
}

// ============================================================================
// Comment helpers
// ============================================================================

/**
 * Create a file header comment
 */
export function createFileHeader(description: string): string {
  return [
    '/**',
    ` * ${description}`,
    ' * @generated by @constructive-io/graphql-codegen',
    ' * DO NOT EDIT - changes will be overwritten',
    ' */',
  ].join('\n');
}

/**
 * Create JSDoc comment for a declaration
 */
export function createJsDoc(lines: string[]): string {
  if (lines.length === 1) {
    return `/** ${lines[0]} */`;
  }
  return ['/**', ...lines.map((l) => ` * ${l}`), ' */'].join('\n');
}

// ============================================================================
// Import builders
// ============================================================================

export interface ImportSpec {
  moduleSpecifier: string;
  namedImports?: string[];
  typeOnlyNamedImports?: string[];
  defaultImport?: string;
}

/**
 * Create import declaration structure
 */
export function createImport(spec: ImportSpec): ImportDeclarationStructure {
  const namedImports: Array<{ name: string; isTypeOnly?: boolean }> = [];

  if (spec.namedImports) {
    namedImports.push(...spec.namedImports.map((name) => ({ name })));
  }

  if (spec.typeOnlyNamedImports) {
    namedImports.push(
      ...spec.typeOnlyNamedImports.map((name) => ({ name, isTypeOnly: true }))
    );
  }

  return {
    kind: StructureKind.ImportDeclaration,
    moduleSpecifier: spec.moduleSpecifier,
    defaultImport: spec.defaultImport,
    namedImports: namedImports.length > 0 ? namedImports : undefined,
  };
}

// ============================================================================
// Interface builders
// ============================================================================

export interface InterfaceProperty {
  name: string;
  type: string;
  optional?: boolean;
  docs?: string[];
}

/**
 * Create interface declaration structure
 */
export function createInterface(
  name: string,
  properties: InterfaceProperty[],
  options?: {
    docs?: string[];
    isExported?: boolean;
    extends?: string[];
  }
): InterfaceDeclarationStructure {
  return {
    kind: StructureKind.Interface,
    name,
    isExported: options?.isExported ?? true,
    extends: options?.extends,
    docs: options?.docs ? [{ description: options.docs.join('\n') }] : undefined,
    properties: properties.map(
      (prop): PropertySignatureStructure => ({
        kind: StructureKind.PropertySignature,
        name: prop.name,
        type: prop.type,
        hasQuestionToken: prop.optional,
        docs: prop.docs ? [{ description: prop.docs.join('\n') }] : undefined,
      })
    ),
  };
}

/**
 * Create filter interface with standard PostGraphile operators
 */
export function createFilterInterface(
  name: string,
  fieldFilters: Array<{ fieldName: string; filterType: string }>
): InterfaceDeclarationStructure {
  const properties: InterfaceProperty[] = [
    ...fieldFilters.map((f) => ({
      name: f.fieldName,
      type: f.filterType,
      optional: true,
    })),
    { name: 'and', type: `${name}[]`, optional: true, docs: ['Logical AND'] },
    { name: 'or', type: `${name}[]`, optional: true, docs: ['Logical OR'] },
    { name: 'not', type: name, optional: true, docs: ['Logical NOT'] },
  ];

  return createInterface(name, properties);
}

// ============================================================================
// Type alias builders
// ============================================================================

/**
 * Create type alias declaration structure
 */
export function createTypeAlias(
  name: string,
  type: string,
  options?: {
    docs?: string[];
    isExported?: boolean;
  }
): TypeAliasDeclarationStructure {
  return {
    kind: StructureKind.TypeAlias,
    name,
    type,
    isExported: options?.isExported ?? true,
    docs: options?.docs ? [{ description: options.docs.join('\n') }] : undefined,
  };
}

/**
 * Create union type from string literals
 */
export function createUnionType(values: string[]): string {
  return values.map((v) => `'${v}'`).join(' | ');
}

// ============================================================================
// Variable/constant builders
// ============================================================================

/**
 * Create const variable statement structure
 */
export function createConst(
  name: string,
  initializer: string,
  options?: {
    docs?: string[];
    isExported?: boolean;
    type?: string;
  }
): VariableStatementStructure {
  return {
    kind: StructureKind.VariableStatement,
    declarationKind: VariableDeclarationKind.Const,
    isExported: options?.isExported ?? true,
    docs: options?.docs ? [{ description: options.docs.join('\n') }] : undefined,
    declarations: [
      {
        name,
        type: options?.type,
        initializer,
      },
    ],
  };
}

/**
 * Create a template literal string (for GraphQL documents)
 */
export function createTemplateLiteral(content: string): string {
  return '`\n' + content + '\n`';
}

// ============================================================================
// Function builders
// ============================================================================

export interface FunctionParameter {
  name: string;
  type: string;
  optional?: boolean;
  initializer?: string;
}

/**
 * Create function declaration structure
 */
export function createFunction(
  name: string,
  parameters: FunctionParameter[],
  returnType: string,
  body: string,
  options?: {
    docs?: string[];
    isExported?: boolean;
    isAsync?: boolean;
  }
): FunctionDeclarationStructure {
  return {
    kind: StructureKind.Function,
    name,
    isExported: options?.isExported ?? true,
    isAsync: options?.isAsync,
    parameters: parameters.map((p) => ({
      name: p.name,
      type: p.type,
      hasQuestionToken: p.optional,
      initializer: p.initializer,
    })),
    returnType,
    statements: body,
  };
}

// ============================================================================
// Export builders
// ============================================================================

/**
 * Create re-export statement
 */
export function createReExport(
  names: string[],
  moduleSpecifier: string,
  isTypeOnly: boolean = false
): string {
  const typePrefix = isTypeOnly ? 'type ' : '';
  return `export ${typePrefix}{ ${names.join(', ')} } from '${moduleSpecifier}';`;
}

/**
 * Create barrel export statement
 */
export function createBarrelExport(moduleSpecifier: string): string {
  return `export * from '${moduleSpecifier}';`;
}

// ============================================================================
// Section comment helpers
// ============================================================================

/**
 * Create a section divider comment for generated code
 */
export function createSectionComment(title: string): string {
  return [
    '// ============================================================================',
    `// ${title}`,
    '// ============================================================================',
  ].join('\n');
}

/**
 * Add a section comment to source file with proper spacing
 */
export function addSectionComment(sourceFile: SourceFile, title: string): void {
  sourceFile.addStatements(`\n${createSectionComment(title)}\n\n`);
}


