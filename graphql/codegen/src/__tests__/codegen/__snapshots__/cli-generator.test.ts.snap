// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`cli-generator docs: true (all formats) generates mcp.json 1`] = `
"{
  "name": "myapp",
  "version": "1.0.0",
  "description": "MCP tool definitions for myapp CLI (auto-generated from GraphQL schema)",
  "tools": [
    {
      "name": "myapp_context_create",
      "description": "Create a named API context pointing at a GraphQL endpoint",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Context name"
          },
          "endpoint": {
            "type": "string",
            "description": "GraphQL endpoint URL"
          }
        },
        "required": [
          "name",
          "endpoint"
        ]
      }
    },
    {
      "name": "myapp_context_list",
      "description": "List all configured API contexts",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_context_use",
      "description": "Set the active API context",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Context name to activate"
          }
        },
        "required": [
          "name"
        ]
      }
    },
    {
      "name": "myapp_context_current",
      "description": "Show the currently active API context",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_context_delete",
      "description": "Delete an API context",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Context name to delete"
          }
        },
        "required": [
          "name"
        ]
      }
    },
    {
      "name": "myapp_auth_set_token",
      "description": "Store a bearer token for the current context",
      "inputSchema": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Bearer token value"
          }
        },
        "required": [
          "token"
        ]
      }
    },
    {
      "name": "myapp_auth_status",
      "description": "Show authentication status for all contexts",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_auth_logout",
      "description": "Remove credentials for the current context",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_car_list",
      "description": "List all Car records",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_car_get",
      "description": "Get a single Car record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_car_create",
      "description": "Create a new Car record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "make": {
            "type": "string",
            "description": "Car make"
          },
          "model": {
            "type": "string",
            "description": "Car model"
          },
          "year": {
            "type": "integer",
            "description": "Car year"
          },
          "isElectric": {
            "type": "boolean",
            "description": "Car isElectric"
          }
        },
        "required": [
          "make",
          "model",
          "year",
          "isElectric"
        ]
      }
    },
    {
      "name": "myapp_car_update",
      "description": "Update an existing Car record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          },
          "make": {
            "type": "string",
            "description": "Car make"
          },
          "model": {
            "type": "string",
            "description": "Car model"
          },
          "year": {
            "type": "integer",
            "description": "Car year"
          },
          "isElectric": {
            "type": "boolean",
            "description": "Car isElectric"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_car_delete",
      "description": "Delete a Car record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_car_fields",
      "description": "List available fields for Car",
      "inputSchema": {
        "type": "object",
        "properties": {}
      },
      "_meta": {
        "fields": [
          {
            "name": "id",
            "type": "UUID",
            "editable": false,
            "primaryKey": true
          },
          {
            "name": "make",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "model",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "year",
            "type": "Int",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "isElectric",
            "type": "Boolean",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "createdAt",
            "type": "Datetime",
            "editable": false,
            "primaryKey": false
          }
        ]
      }
    },
    {
      "name": "myapp_driver_list",
      "description": "List all Driver records",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_driver_get",
      "description": "Get a single Driver record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_driver_create",
      "description": "Create a new Driver record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Driver name"
          },
          "licenseNumber": {
            "type": "string",
            "description": "Driver licenseNumber"
          }
        },
        "required": [
          "name",
          "licenseNumber"
        ]
      }
    },
    {
      "name": "myapp_driver_update",
      "description": "Update an existing Driver record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          },
          "name": {
            "type": "string",
            "description": "Driver name"
          },
          "licenseNumber": {
            "type": "string",
            "description": "Driver licenseNumber"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_driver_delete",
      "description": "Delete a Driver record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_driver_fields",
      "description": "List available fields for Driver",
      "inputSchema": {
        "type": "object",
        "properties": {}
      },
      "_meta": {
        "fields": [
          {
            "name": "id",
            "type": "UUID",
            "editable": false,
            "primaryKey": true
          },
          {
            "name": "name",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "licenseNumber",
            "type": "String",
            "editable": true,
            "primaryKey": false
          }
        ]
      }
    },
    {
      "name": "myapp_current-user",
      "description": "Get the currently authenticated user",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_login",
      "description": "Authenticate a user",
      "inputSchema": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "email"
          },
          "password": {
            "type": "string",
            "description": "password"
          }
        },
        "required": [
          "email",
          "password"
        ]
      }
    }
  ]
}
"
`;

exports[`cli-generator docs: true (all formats) generates skill files 1`] = `
"# myapp-context

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Manage API endpoint contexts for myapp

## Usage

\`\`\`bash
myapp context create <name> --endpoint <url>
myapp context list
myapp context use <name>
myapp context current
myapp context delete <name>
\`\`\`

## Examples

### Create and activate a context

\`\`\`bash
myapp context create production --endpoint https://api.example.com/graphql
myapp context use production
\`\`\`

### List all contexts

\`\`\`bash
myapp context list
\`\`\`
"
`;

exports[`cli-generator docs: true (all formats) generates skill files 2`] = `
"# myapp-auth

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Manage authentication tokens for myapp

## Usage

\`\`\`bash
myapp auth set-token <token>
myapp auth status
myapp auth logout
\`\`\`

## Examples

### Authenticate with a token

\`\`\`bash
myapp auth set-token eyJhbGciOiJIUzI1NiIs...
\`\`\`

### Check auth status

\`\`\`bash
myapp auth status
\`\`\`
"
`;

exports[`cli-generator docs: true (all formats) generates skill files 3`] = `
"# myapp-car

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

CRUD operations for Car records via myapp CLI

## Usage

\`\`\`bash
myapp car list
myapp car get --id <value>
myapp car create --make <value> --model <value> --year <value> --isElectric <value>
myapp car update --id <value> [--make <value>] [--model <value>] [--year <value>] [--isElectric <value>]
myapp car delete --id <value>
\`\`\`

## Examples

### List all car records

\`\`\`bash
myapp car list
\`\`\`

### Create a car

\`\`\`bash
myapp car create --make "value" --model "value" --year "value" --isElectric "value"
\`\`\`

### Get a car by id

\`\`\`bash
myapp car get --id <value>
\`\`\`

### Update a car

\`\`\`bash
myapp car update --id <value> --make "new-value"
\`\`\`

### Delete a car

\`\`\`bash
myapp car delete --id <value>
\`\`\`
"
`;

exports[`cli-generator docs: true (all formats) generates skill files 4`] = `
"# myapp-driver

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

CRUD operations for Driver records via myapp CLI

## Usage

\`\`\`bash
myapp driver list
myapp driver get --id <value>
myapp driver create --name <value> --licenseNumber <value>
myapp driver update --id <value> [--name <value>] [--licenseNumber <value>]
myapp driver delete --id <value>
\`\`\`

## Examples

### List all driver records

\`\`\`bash
myapp driver list
\`\`\`

### Create a driver

\`\`\`bash
myapp driver create --name "value" --licenseNumber "value"
\`\`\`

### Get a driver by id

\`\`\`bash
myapp driver get --id <value>
\`\`\`

### Update a driver

\`\`\`bash
myapp driver update --id <value> --name "new-value"
\`\`\`

### Delete a driver

\`\`\`bash
myapp driver delete --id <value>
\`\`\`
"
`;

exports[`cli-generator docs: true (all formats) generates skill files 5`] = `
"# myapp-current-user

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Get the currently authenticated user

## Usage

\`\`\`bash
myapp current-user
\`\`\`

## Examples

### Run currentUser

\`\`\`bash
myapp current-user
\`\`\`
"
`;

exports[`cli-generator docs: true (all formats) generates skill files 6`] = `
"# myapp-login

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Authenticate a user

## Usage

\`\`\`bash
myapp login --email <value> --password <value>
\`\`\`

## Examples

### Run login

\`\`\`bash
myapp login --email <value> --password <value>
\`\`\`
"
`;

exports[`cli-generator generates AGENTS.md by default 1`] = `
"# myapp CLI - Agent Reference

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT
> This document is structured for LLM/agent consumption.

## OVERVIEW

\`myapp\` is a CLI tool for interacting with a GraphQL API.
All commands output JSON to stdout. All commands accept \`--help\` or \`-h\` for usage.
Configuration is stored at \`~/.myapp/config/\` via appstash.

## PREREQUISITES

Before running any data commands, you must:

1. Create a context: \`myapp context create <name> --endpoint <url>\`
2. Activate it: \`myapp context use <name>\`
3. Authenticate: \`myapp auth set-token <token>\`

## TOOLS

### TOOL: context

Manage named API endpoint contexts (like kubectl contexts).

\`\`\`
SUBCOMMANDS:
  myapp context create <name> --endpoint <url>   Create a new context
  myapp context list                              List all contexts
  myapp context use <name>                        Set active context
  myapp context current                           Show active context
  myapp context delete <name>                     Delete a context

INPUT:
  name:     string (required) - Context identifier
  endpoint: string (required for create) - GraphQL endpoint URL

OUTPUT: JSON
  create:  { name, endpoint }
  list:    [{ name, endpoint, isCurrent, hasCredentials }]
  use:     { name, endpoint }
  current: { name, endpoint }
  delete:  { deleted: name }
\`\`\`

### TOOL: auth

Manage authentication tokens per context.

\`\`\`
SUBCOMMANDS:
  myapp auth set-token <token>   Store bearer token for current context
  myapp auth status               Show auth status for all contexts
  myapp auth logout                Remove credentials for current context

INPUT:
  token: string (required for set-token) - Bearer token value

OUTPUT: JSON
  set-token: { context, status: "authenticated" }
  status:    [{ context, authenticated: boolean }]
  logout:    { context, status: "logged out" }
\`\`\`

### TOOL: car

CRUD operations for Car records.

\`\`\`
SUBCOMMANDS:
  myapp car list                               List all records
  myapp car get --id <value>              Get one record
  myapp car create --make <value> --model <value> --year <value> --isElectric <value>
  myapp car update --id <value> [--make <value>] [--model <value>] [--year <value>] [--isElectric <value>]
  myapp car delete --id <value>           Delete one record

INPUT FIELDS:
  id: UUID (primary key)
  make: String
  model: String
  year: Int
  isElectric: Boolean
  createdAt: Datetime

EDITABLE FIELDS (for create/update):
  make: String
  model: String
  year: Int
  isElectric: Boolean

OUTPUT: JSON
  list:   [{ id, make, model, year, isElectric, createdAt }]
  get:    { id, make, model, year, isElectric, createdAt }
  create: { id, make, model, year, isElectric, createdAt }
  update: { id, make, model, year, isElectric, createdAt }
  delete: { id }
\`\`\`

### TOOL: driver

CRUD operations for Driver records.

\`\`\`
SUBCOMMANDS:
  myapp driver list                               List all records
  myapp driver get --id <value>              Get one record
  myapp driver create --name <value> --licenseNumber <value>
  myapp driver update --id <value> [--name <value>] [--licenseNumber <value>]
  myapp driver delete --id <value>           Delete one record

INPUT FIELDS:
  id: UUID (primary key)
  name: String
  licenseNumber: String

EDITABLE FIELDS (for create/update):
  name: String
  licenseNumber: String

OUTPUT: JSON
  list:   [{ id, name, licenseNumber }]
  get:    { id, name, licenseNumber }
  create: { id, name, licenseNumber }
  update: { id, name, licenseNumber }
  delete: { id }
\`\`\`

### TOOL: current-user

Get the currently authenticated user

\`\`\`
TYPE: query
USAGE: myapp current-user

INPUT: none

OUTPUT: JSON
\`\`\`

### TOOL: login

Authenticate a user

\`\`\`
TYPE: mutation
USAGE: myapp login --email <value> --password <value>

INPUT:
  email: String (required)
  password: String (required)

OUTPUT: JSON
\`\`\`

## WORKFLOWS

### Initial setup

\`\`\`bash
myapp context create dev --endpoint http://localhost:5000/graphql
myapp context use dev
myapp auth set-token eyJhbGciOiJIUzI1NiIs...
\`\`\`

### CRUD workflow (car)

\`\`\`bash
# List all
myapp car list

# Create
myapp car create --make "value" --model "value" --year "value" --isElectric "value"

# Get by id
myapp car get --id <value>

# Update
myapp car update --id <value> --make "new-value"

# Delete
myapp car delete --id <value>
\`\`\`

### Piping output

\`\`\`bash
# Pretty print
myapp car list | jq '.'

# Extract field
myapp car list | jq '.[].id'

# Count results
myapp car list | jq 'length'
\`\`\`

## ERROR HANDLING

All errors are written to stderr. Exit codes:
- \`0\`: Success
- \`1\`: Error (auth failure, not found, validation error, network error)

Common errors:
- "No active context": Run \`context use <name>\` first
- "Not authenticated": Run \`auth set-token <token>\` first
- "Record not found": The requested ID does not exist
"
`;

exports[`cli-generator generates README.md by default 1`] = `
"# myapp CLI

> Auto-generated CLI commands from GraphQL schema
> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## Setup

\`\`\`bash
# Create a context pointing at your GraphQL endpoint
myapp context create production --endpoint https://api.example.com/graphql

# Set the active context
myapp context use production

# Authenticate
myapp auth set-token <your-token>
\`\`\`

## Commands

| Command | Description |
|---------|-------------|
| \`context\` | Manage API contexts (endpoints) |
| \`auth\` | Manage authentication tokens |
| \`car\` | car CRUD operations |
| \`driver\` | driver CRUD operations |
| \`current-user\` | Get the currently authenticated user |
| \`login\` | Authenticate a user |

## Infrastructure Commands

### \`context\`

Manage named API contexts (kubectl-style).

| Subcommand | Description |
|------------|-------------|
| \`create <name> --endpoint <url>\` | Create a new context |
| \`list\` | List all contexts |
| \`use <name>\` | Set the active context |
| \`current\` | Show current context |
| \`delete <name>\` | Delete a context |

Configuration is stored at \`~/.myapp/config/\`.

### \`auth\`

Manage authentication tokens per context.

| Subcommand | Description |
|------------|-------------|
| \`set-token <token>\` | Store bearer token for current context |
| \`status\` | Show auth status across all contexts |
| \`logout\` | Remove credentials for current context |

## Table Commands

### \`car\`

CRUD operations for Car records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all car records |
| \`get\` | Get a car by id |
| \`create\` | Create a new car |
| \`update\` | Update an existing car |
| \`delete\` | Delete a car |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`make\` | String |
| \`model\` | String |
| \`year\` | Int |
| \`isElectric\` | Boolean |
| \`createdAt\` | Datetime |

**Create fields:** \`make\`, \`model\`, \`year\`, \`isElectric\`

### \`driver\`

CRUD operations for Driver records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all driver records |
| \`get\` | Get a driver by id |
| \`create\` | Create a new driver |
| \`update\` | Update an existing driver |
| \`delete\` | Delete a driver |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`name\` | String |
| \`licenseNumber\` | String |

**Create fields:** \`name\`, \`licenseNumber\`

## Custom Operations

### \`current-user\`

Get the currently authenticated user

- **Type:** query
- **Arguments:** none

### \`login\`

Authenticate a user

- **Type:** mutation
- **Arguments:**

  | Argument | Type |
  |----------|------|
  | \`email\` | String (required) |
  | \`password\` | String (required) |

## Output

All commands output JSON to stdout. Pipe to \`jq\` for formatting:

\`\`\`bash
myapp car list | jq '.[]'
myapp car get --id <uuid> | jq '.'
\`\`\`
"
`;

exports[`cli-generator generates commands.ts (command map) 1`] = `
"/**
 * CLI command map and entry point
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import contextCmd from "./commands/context";
import authCmd from "./commands/auth";
import carCmd from "./commands/car";
import driverCmd from "./commands/driver";
import currentUserCmd from "./commands/current-user";
import loginCmd from "./commands/login";
const createCommandMap = () => ({
  "context": contextCmd,
  "auth": authCmd,
  "car": carCmd,
  "driver": driverCmd,
  "current-user": currentUserCmd,
  "login": loginCmd
});
const usage = "\\nmyapp <command>\\n\\nCommands:\\n  context               Manage API contexts\\n  auth                  Manage authentication\\n  car                  car CRUD operations\\n  driver               driver CRUD operations\\n  current-user         Get the currently authenticated user\\n  login                Authenticate a user\\n\\n  --help, -h            Show this help message\\n  --version, -v         Show version\\n";
export const commands = async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  let {
    first: command,
    newArgv
  } = extractFirst(argv);
  const commandMap = createCommandMap();
  if (!command) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "command",
      message: "What do you want to do?",
      options: Object.keys(commandMap)
    }]);
    command = answer.command;
  }
  const commandFn = commandMap[command];
  if (!commandFn) {
    console.log(usage);
    console.error(\`Unknown command: \${command}\`);
    process.exit(1);
  }
  await commandFn(newArgv, prompter, options);
  prompter.close();
  return argv;
};"
`;

exports[`cli-generator generates commands/auth.ts 1`] = `
"/**
 * Authentication commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp auth <command>\\n\\nCommands:\\n  set-token <token>     Set API token for the current context\\n  status                Show authentication status\\n  logout                Remove credentials for the current context\\n\\nOptions:\\n  --context <name>      Specify context (defaults to current context)\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["set-token", "status", "logout"]
    }]);
    return handleAuthSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleAuthSubcommand(subcommand, newArgv, prompter, store);
};
async function handleAuthSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "set-token":
      return handleSetToken(argv, prompter, store);
    case "status":
      return handleStatus(store);
    case "logout":
      return handleLogout(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleSetToken(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.error("No active context. Run \\"context create\\" first.");
    process.exit(1);
  }
  const {
    first: token
  } = extractFirst(argv);
  let tokenValue = token;
  if (!tokenValue) {
    const answer = await prompter.prompt(argv, [{
      type: "password",
      name: "token",
      message: "API Token",
      required: true
    }]);
    tokenValue = answer.token;
  }
  store.setCredentials(current.name, {
    token: String.call(tokenValue || "").trim()
  });
  console.log(\`Token saved for context: \${current.name}\`);
}
function handleStatus(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Authentication Status:");
  for (const ctx of contexts) {
    const isCurrent = ctx.name === settings.currentContext;
    const hasAuth = store.hasValidCredentials(ctx.name);
    const marker = isCurrent ? "* " : "  ";
    const status = hasAuth ? "authenticated" : "no token";
    console.log(\`\${marker}\${ctx.name} [\${status}]\`);
  }
}
async function handleLogout(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No active context.");
    return;
  }
  const confirm = await prompter.prompt(argv, [{
    type: "confirm",
    name: "confirm",
    message: \`Remove credentials for "\${current.name}"?\`,
    default: false
  }]);
  if (!confirm.confirm) {
    return;
  }
  if (store.removeCredentials(current.name)) {
    console.log(\`Credentials removed for: \${current.name}\`);
  } else {
    console.log(\`No credentials found for: \${current.name}\`);
  }
}"
`;

exports[`cli-generator generates commands/car.ts 1`] = `
"/**
 * CLI commands for Car
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../executor";
const usage = "\\ncar <command>\\n\\nCommands:\\n  list                  List all car records\\n  get                   Get a car by ID\\n  create                Create a new car\\n  update                Update an existing car\\n  delete                Delete a car\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient();
    const result = await client.car.findMany({
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.car.findOne({
      id: answers.id,
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "make",
      message: "make",
      required: true
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: true
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: true
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: true
    }]);
    const client = getClient();
    const result = await client.car.create({
      data: {
        make: answers.make,
        model: answers.model,
        year: answers.year,
        isElectric: answers.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "make",
      message: "make",
      required: false
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: false
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: false
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: false
    }]);
    const client = getClient();
    const result = await client.car.update({
      id: answers.id,
      data: {
        make: answers.make,
        model: answers.model,
        year: answers.year,
        isElectric: answers.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.car.delete({
      id: answers.id,
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/context.ts 1`] = `
"/**
 * Context management commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp context <command>\\n\\nCommands:\\n  create <name>         Create a new context\\n  list                  List all contexts\\n  use <name>            Set the active context\\n  current               Show current context\\n  delete <name>         Delete a context\\n\\nCreate Options:\\n  --endpoint <url>      GraphQL endpoint URL\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["create", "list", "use", "current", "delete"]
    }]);
    return handleSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleSubcommand(subcommand, newArgv, prompter, store);
};
async function handleSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "create":
      return handleCreate(argv, prompter, store);
    case "list":
      return handleList(store);
    case "use":
      return handleUse(argv, prompter, store);
    case "current":
      return handleCurrent(store);
    case "delete":
      return handleDelete(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name,
    newArgv: restArgv
  } = extractFirst(argv);
  const answers = await prompter.prompt({
    name,
    ...restArgv
  }, [{
    type: "text",
    name: "name",
    message: "Context name",
    required: true
  }, {
    type: "text",
    name: "endpoint",
    message: "GraphQL endpoint URL",
    required: true
  }]);
  const contextName = answers.name;
  const endpoint = answers.endpoint;
  store.createContext(contextName, {
    endpoint: endpoint
  });
  const settings = store.loadSettings();
  if (!settings.currentContext) {
    store.setCurrentContext(contextName);
  }
  console.log(\`Created context: \${contextName}\`);
  console.log(\`  Endpoint: \${endpoint}\`);
}
function handleList(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Contexts:");
  for (const ctx of contexts) {
    const marker = ctx.name === settings.currentContext ? "* " : "  ";
    const authStatus = store.hasValidCredentials(ctx.name) ? "[authenticated]" : "[no token]";
    console.log(\`\${marker}\${ctx.name} \${authStatus}\`);
    console.log(\`    Endpoint: \${ctx.endpoint}\`);
  }
}
async function handleUse(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.setCurrentContext(contextName)) {
    console.log(\`Switched to context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}
function handleCurrent(store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No current context set.");
    return;
  }
  console.log(\`Current context: \${current.name}\`);
  console.log(\`  Endpoint: \${current.endpoint}\`);
  const hasAuth = store.hasValidCredentials(current.name);
  console.log(\`  Auth: \${hasAuth ? "authenticated" : "not authenticated"}\`);
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context to delete",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.deleteContext(contextName)) {
    console.log(\`Deleted context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/current-user.ts (custom query) 1`] = `
"/**
 * CLI command for query currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer } from "inquirerer";
import { getClient } from "../executor";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  try {
    if (argv.help || argv.h) {
      console.log("current-user - Get the currently authenticated user\\n\\nUsage: current-user [OPTIONS]\\n");
      process.exit(0);
    }
    const client = getClient();
    const result = await client.query.currentUser({}).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed: currentUser");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
};"
`;

exports[`cli-generator generates commands/driver.ts 1`] = `
"/**
 * CLI commands for Driver
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../executor";
const usage = "\\ndriver <command>\\n\\nCommands:\\n  list                  List all driver records\\n  get                   Get a driver by ID\\n  create                Create a new driver\\n  update                Update an existing driver\\n  delete                Delete a driver\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient();
    const result = await client.driver.findMany({
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.driver.findOne({
      id: answers.id,
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "name",
      message: "name",
      required: true
    }, {
      type: "text",
      name: "licenseNumber",
      message: "licenseNumber",
      required: true
    }]);
    const client = getClient();
    const result = await client.driver.create({
      data: {
        name: answers.name,
        licenseNumber: answers.licenseNumber
      },
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "name",
      message: "name",
      required: false
    }, {
      type: "text",
      name: "licenseNumber",
      message: "licenseNumber",
      required: false
    }]);
    const client = getClient();
    const result = await client.driver.update({
      id: answers.id,
      data: {
        name: answers.name,
        licenseNumber: answers.licenseNumber
      },
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.driver.delete({
      id: answers.id,
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/login.ts (custom mutation) 1`] = `
"/**
 * CLI command for mutation login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer } from "inquirerer";
import { getClient } from "../executor";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  try {
    if (argv.help || argv.h) {
      console.log("login - Authenticate a user\\n\\nUsage: login [OPTIONS]\\n");
      process.exit(0);
    }
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "email",
      message: "email",
      required: true
    }, {
      type: "text",
      name: "password",
      message: "password",
      required: true
    }]);
    const client = getClient();
    const result = await client.mutation.login(answers).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed: login");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
};"
`;

exports[`cli-generator generates executor.ts 1`] = `
"/**
 * Executor and config store for CLI
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { createConfigStore } from "appstash";
import { createClient } from "../orm";
const store = createConfigStore("myapp");
export const getStore = () => store;
export function getClient(contextName?: string) {
  let ctx = null;
  if (contextName) {
    ctx = store.loadContext(contextName);
    if (!ctx) {
      throw new Error(\`Context "\${contextName}" not found.\`);
    }
  } else {
    ctx = store.getCurrentContext();
    if (!ctx) {
      throw new Error("No active context. Run \\"context create\\" or \\"context use\\" first.");
    }
  }
  const headers = {};
  if (store.hasValidCredentials(ctx.name)) {
    const creds = store.getCredentials(ctx.name);
    if (creds?.token) {
      headers.Authorization = \`Bearer \${creds.token}\`;
    }
  }
  return createClient({
    endpoint: ctx.endpoint,
    headers: headers
  });
}"
`;
