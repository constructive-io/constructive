// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`cli-generator generates COMMANDS.md (man-page reference) 1`] = `
"# myapp - Command Reference

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

---

## context(1)

### NAME

context - manage API endpoint contexts

### SYNOPSIS

    myapp context <command> [options]

### COMMANDS

**create** \`<name>\` \`--endpoint <url>\`

    Create a named context pointing at a GraphQL endpoint.
    Config stored at ~/.myapp/config/contexts/<name>.json

**list**

    List all configured contexts with auth status.

**use** \`<name>\`

    Set the active context for subsequent commands.

**current**

    Display the currently active context and its endpoint.

**delete** \`<name>\`

    Remove a context and its configuration.

---

## auth(1)

### NAME

auth - manage authentication tokens

### SYNOPSIS

    myapp auth <command> [options]

### COMMANDS

**set-token** \`<token>\` \`[--context <name>]\`

    Store a bearer token for the current (or specified) context.
    Credentials stored at ~/.myapp/config/credentials.json (mode 0600).

**status**

    Show authentication status for all contexts.

**logout** \`[--context <name>]\`

    Remove stored credentials for the current (or specified) context.

---

## car(1)

### NAME

car - manage Car records

### SYNOPSIS

    car <command> [options]

### COMMANDS

**list**

    car list

List all car records. Returns JSON array.

Selected fields: id, make, model, year, isElectric, createdAt

**get**

    car get --id <value>

Fetch a single car by its id.

**create**

    car create --make <value> --model <value> --year <value> --isElectric <value>

Create a new car. All fields are required.

  Options:
    --make                 String (required)
    --model                String (required)
    --year                 Int (required)
    --isElectric           Boolean (required)

**update**

    car update --id <value> [--make <value>] [--model <value>] [--year <value>] [--isElectric <value>]

Update an existing car. Only provided fields are changed.

  Options:
    --id                   UUID (required)
    --make                 String
    --model                String
    --year                 Int
    --isElectric           Boolean

**delete**

    car delete --id <value>

Delete a car by its id.

---

## driver(1)

### NAME

driver - manage Driver records

### SYNOPSIS

    driver <command> [options]

### COMMANDS

**list**

    driver list

List all driver records. Returns JSON array.

Selected fields: id, name, licenseNumber

**get**

    driver get --id <value>

Fetch a single driver by its id.

**create**

    driver create --name <value> --licenseNumber <value>

Create a new driver. All fields are required.

  Options:
    --name                 String (required)
    --licenseNumber        String (required)

**update**

    driver update --id <value> [--name <value>] [--licenseNumber <value>]

Update an existing driver. Only provided fields are changed.

  Options:
    --id                   UUID (required)
    --name                 String
    --licenseNumber        String

**delete**

    driver delete --id <value>

Delete a driver by its id.

---

## current-user(1)

### NAME

current-user - Get the currently authenticated user

### SYNOPSIS

    current-user

### DESCRIPTION

Get the currently authenticated user

---

## login(1)

### NAME

login - Authenticate a user

### SYNOPSIS

    login --email <value> --password <value>

### DESCRIPTION

Authenticate a user

### OPTIONS

**--email** String (required)

**--password** String (required)

---
"
`;

exports[`cli-generator generates README.md 1`] = `
"# myapp CLI

> Auto-generated CLI commands from GraphQL schema
> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## Setup

\`\`\`bash
# Create a context pointing at your GraphQL endpoint
myapp context create production --endpoint https://api.example.com/graphql

# Set the active context
myapp context use production

# Authenticate
myapp auth set-token <your-token>
\`\`\`

## Commands

| Command | Description |
|---------|-------------|
| \`context\` | Manage API contexts (endpoints) |
| \`auth\` | Manage authentication tokens |
| \`car\` | car CRUD operations |
| \`driver\` | driver CRUD operations |
| \`current-user\` | Get the currently authenticated user |
| \`login\` | Authenticate a user |

## Infrastructure Commands

### \`context\`

Manage named API contexts (kubectl-style).

| Subcommand | Description |
|------------|-------------|
| \`create <name> --endpoint <url>\` | Create a new context |
| \`list\` | List all contexts |
| \`use <name>\` | Set the active context |
| \`current\` | Show current context |
| \`delete <name>\` | Delete a context |

Configuration is stored at \`~/.myapp/config/\`.

### \`auth\`

Manage authentication tokens per context.

| Subcommand | Description |
|------------|-------------|
| \`set-token <token>\` | Store bearer token for current context |
| \`status\` | Show auth status across all contexts |
| \`logout\` | Remove credentials for current context |

## Table Commands

### \`car\`

CRUD operations for Car records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all car records |
| \`get\` | Get a car by id |
| \`create\` | Create a new car |
| \`update\` | Update an existing car |
| \`delete\` | Delete a car |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`make\` | String |
| \`model\` | String |
| \`year\` | Int |
| \`isElectric\` | Boolean |
| \`createdAt\` | Datetime |

**Create fields:** \`make\`, \`model\`, \`year\`, \`isElectric\`

### \`driver\`

CRUD operations for Driver records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all driver records |
| \`get\` | Get a driver by id |
| \`create\` | Create a new driver |
| \`update\` | Update an existing driver |
| \`delete\` | Delete a driver |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`name\` | String |
| \`licenseNumber\` | String |

**Create fields:** \`name\`, \`licenseNumber\`

## Custom Operations

### \`current-user\`

Get the currently authenticated user

- **Type:** query
- **Arguments:** none

### \`login\`

Authenticate a user

- **Type:** mutation
- **Arguments:**

  | Argument | Type |
  |----------|------|
  | \`email\` | String (required) |
  | \`password\` | String (required) |

## Output

All commands output JSON to stdout. Pipe to \`jq\` for formatting:

\`\`\`bash
myapp car list | jq '.[]'
myapp car get --id <uuid> | jq '.'
\`\`\`
"
`;

exports[`cli-generator generates commands.ts (command map) 1`] = `
"/**
 * CLI command map and entry point
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import contextCmd from "./commands/context";
import authCmd from "./commands/auth";
import carCmd from "./commands/car";
import driverCmd from "./commands/driver";
import currentUserCmd from "./commands/current-user";
import loginCmd from "./commands/login";
const createCommandMap = () => ({
  "context": contextCmd,
  "auth": authCmd,
  "car": carCmd,
  "driver": driverCmd,
  "current-user": currentUserCmd,
  "login": loginCmd
});
const usage = "\\nmyapp <command>\\n\\nCommands:\\n  context               Manage API contexts\\n  auth                  Manage authentication\\n  car                  car CRUD operations\\n  driver               driver CRUD operations\\n  current-user         Get the currently authenticated user\\n  login                Authenticate a user\\n\\n  --help, -h            Show this help message\\n  --version, -v         Show version\\n";
export const commands = async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  let {
    first: command,
    newArgv
  } = extractFirst(argv);
  const commandMap = createCommandMap();
  if (!command) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "command",
      message: "What do you want to do?",
      options: Object.keys(commandMap)
    }]);
    command = answer.command;
  }
  const commandFn = commandMap[command];
  if (!commandFn) {
    console.log(usage);
    console.error(\`Unknown command: \${command}\`);
    process.exit(1);
  }
  await commandFn(newArgv, prompter, options);
  prompter.close();
  return argv;
};"
`;

exports[`cli-generator generates commands/auth.ts 1`] = `
"/**
 * Authentication commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp auth <command>\\n\\nCommands:\\n  set-token <token>     Set API token for the current context\\n  status                Show authentication status\\n  logout                Remove credentials for the current context\\n\\nOptions:\\n  --context <name>      Specify context (defaults to current context)\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["set-token", "status", "logout"]
    }]);
    return handleAuthSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleAuthSubcommand(subcommand, newArgv, prompter, store);
};
async function handleAuthSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "set-token":
      return handleSetToken(argv, prompter, store);
    case "status":
      return handleStatus(store);
    case "logout":
      return handleLogout(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleSetToken(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.error("No active context. Run \\"context create\\" first.");
    process.exit(1);
  }
  const {
    first: token
  } = extractFirst(argv);
  let tokenValue = token;
  if (!tokenValue) {
    const answer = await prompter.prompt(argv, [{
      type: "password",
      name: "token",
      message: "API Token",
      required: true
    }]);
    tokenValue = answer.token;
  }
  store.setCredentials(current.name, {
    token: String.call(tokenValue || "").trim()
  });
  console.log(\`Token saved for context: \${current.name}\`);
}
function handleStatus(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Authentication Status:");
  for (const ctx of contexts) {
    const isCurrent = ctx.name === settings.currentContext;
    const hasAuth = store.hasValidCredentials(ctx.name);
    const marker = isCurrent ? "* " : "  ";
    const status = hasAuth ? "authenticated" : "no token";
    console.log(\`\${marker}\${ctx.name} [\${status}]\`);
  }
}
async function handleLogout(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No active context.");
    return;
  }
  const confirm = await prompter.prompt(argv, [{
    type: "confirm",
    name: "confirm",
    message: \`Remove credentials for "\${current.name}"?\`,
    default: false
  }]);
  if (!confirm.confirm) {
    return;
  }
  if (store.removeCredentials(current.name)) {
    console.log(\`Credentials removed for: \${current.name}\`);
  } else {
    console.log(\`No credentials found for: \${current.name}\`);
  }
}"
`;

exports[`cli-generator generates commands/car.ts 1`] = `
"/**
 * CLI commands for Car
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../executor";
const usage = "\\ncar <command>\\n\\nCommands:\\n  list                  List all car records\\n  get                   Get a car by ID\\n  create                Create a new car\\n  update                Update an existing car\\n  delete                Delete a car\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient();
    const result = await client.car.findMany({
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.car.findOne({
      id: answers.id,
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "make",
      message: "make",
      required: true
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: true
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: true
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: true
    }]);
    const client = getClient();
    const result = await client.car.create({
      data: {
        make: answers.make,
        model: answers.model,
        year: answers.year,
        isElectric: answers.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "make",
      message: "make",
      required: false
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: false
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: false
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: false
    }]);
    const client = getClient();
    const result = await client.car.update({
      id: answers.id,
      data: {
        make: answers.make,
        model: answers.model,
        year: answers.year,
        isElectric: answers.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.car.delete({
      id: answers.id,
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/context.ts 1`] = `
"/**
 * Context management commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp context <command>\\n\\nCommands:\\n  create <name>         Create a new context\\n  list                  List all contexts\\n  use <name>            Set the active context\\n  current               Show current context\\n  delete <name>         Delete a context\\n\\nCreate Options:\\n  --endpoint <url>      GraphQL endpoint URL\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["create", "list", "use", "current", "delete"]
    }]);
    return handleSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleSubcommand(subcommand, newArgv, prompter, store);
};
async function handleSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "create":
      return handleCreate(argv, prompter, store);
    case "list":
      return handleList(store);
    case "use":
      return handleUse(argv, prompter, store);
    case "current":
      return handleCurrent(store);
    case "delete":
      return handleDelete(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name,
    newArgv: restArgv
  } = extractFirst(argv);
  const answers = await prompter.prompt({
    name,
    ...restArgv
  }, [{
    type: "text",
    name: "name",
    message: "Context name",
    required: true
  }, {
    type: "text",
    name: "endpoint",
    message: "GraphQL endpoint URL",
    required: true
  }]);
  const contextName = answers.name;
  const endpoint = answers.endpoint;
  store.createContext(contextName, {
    endpoint: endpoint
  });
  const settings = store.loadSettings();
  if (!settings.currentContext) {
    store.setCurrentContext(contextName);
  }
  console.log(\`Created context: \${contextName}\`);
  console.log(\`  Endpoint: \${endpoint}\`);
}
function handleList(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Contexts:");
  for (const ctx of contexts) {
    const marker = ctx.name === settings.currentContext ? "* " : "  ";
    const authStatus = store.hasValidCredentials(ctx.name) ? "[authenticated]" : "[no token]";
    console.log(\`\${marker}\${ctx.name} \${authStatus}\`);
    console.log(\`    Endpoint: \${ctx.endpoint}\`);
  }
}
async function handleUse(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.setCurrentContext(contextName)) {
    console.log(\`Switched to context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}
function handleCurrent(store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No current context set.");
    return;
  }
  console.log(\`Current context: \${current.name}\`);
  console.log(\`  Endpoint: \${current.endpoint}\`);
  const hasAuth = store.hasValidCredentials(current.name);
  console.log(\`  Auth: \${hasAuth ? "authenticated" : "not authenticated"}\`);
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context to delete",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.deleteContext(contextName)) {
    console.log(\`Deleted context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/current-user.ts (custom query) 1`] = `
"/**
 * CLI command for query currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer } from "inquirerer";
import { getClient } from "../executor";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  try {
    if (argv.help || argv.h) {
      console.log("current-user - Get the currently authenticated user\\n\\nUsage: current-user [OPTIONS]\\n");
      process.exit(0);
    }
    const client = getClient();
    const result = await client.query.currentUser({}).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed: currentUser");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
};"
`;

exports[`cli-generator generates commands/driver.ts 1`] = `
"/**
 * CLI commands for Driver
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../executor";
const usage = "\\ndriver <command>\\n\\nCommands:\\n  list                  List all driver records\\n  get                   Get a driver by ID\\n  create                Create a new driver\\n  update                Update an existing driver\\n  delete                Delete a driver\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient();
    const result = await client.driver.findMany({
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.driver.findOne({
      id: answers.id,
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "name",
      message: "name",
      required: true
    }, {
      type: "text",
      name: "licenseNumber",
      message: "licenseNumber",
      required: true
    }]);
    const client = getClient();
    const result = await client.driver.create({
      data: {
        name: answers.name,
        licenseNumber: answers.licenseNumber
      },
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "name",
      message: "name",
      required: false
    }, {
      type: "text",
      name: "licenseNumber",
      message: "licenseNumber",
      required: false
    }]);
    const client = getClient();
    const result = await client.driver.update({
      id: answers.id,
      data: {
        name: answers.name,
        licenseNumber: answers.licenseNumber
      },
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.driver.delete({
      id: answers.id,
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/login.ts (custom mutation) 1`] = `
"/**
 * CLI command for mutation login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer } from "inquirerer";
import { getClient } from "../executor";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  try {
    if (argv.help || argv.h) {
      console.log("login - Authenticate a user\\n\\nUsage: login [OPTIONS]\\n");
      process.exit(0);
    }
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "email",
      message: "email",
      required: true
    }, {
      type: "text",
      name: "password",
      message: "password",
      required: true
    }]);
    const client = getClient();
    const result = await client.mutation.login(answers).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed: login");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
};"
`;

exports[`cli-generator generates executor.ts 1`] = `
"/**
 * Executor and config store for CLI
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { createConfigStore } from "appstash";
import { createClient } from "../orm";
const store = createConfigStore("myapp");
export const getStore = () => store;
export function getClient(contextName?: string) {
  let ctx = null;
  if (contextName) {
    ctx = store.loadContext(contextName);
    if (!ctx) {
      throw new Error(\`Context "\${contextName}" not found.\`);
    }
  } else {
    ctx = store.getCurrentContext();
    if (!ctx) {
      throw new Error("No active context. Run \\"context create\\" or \\"context use\\" first.");
    }
  }
  const headers = {};
  if (store.hasValidCredentials(ctx.name)) {
    const creds = store.getCredentials(ctx.name);
    if (creds?.token) {
      headers.Authorization = \`Bearer \${creds.token}\`;
    }
  }
  return createClient({
    endpoint: ctx.endpoint,
    headers: headers
  });
}"
`;
