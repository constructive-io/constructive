// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`cli docs generator generates CLI AGENTS.md 1`] = `
"# myapp CLI - Agent Reference

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT
> This document is structured for LLM/agent consumption.

## OVERVIEW

\`myapp\` is a CLI tool for interacting with a GraphQL API.
All commands output JSON to stdout. All commands accept \`--help\` or \`-h\` for usage.
Configuration is stored at \`~/.myapp/config/\` via appstash.

## PREREQUISITES

Before running any data commands, you must:

1. Create a context: \`myapp context create <name> --endpoint <url>\`
2. Activate it: \`myapp context use <name>\`
3. Authenticate: \`myapp auth set-token <token>\`

## TOOLS

### TOOL: context

Manage named API endpoint contexts (like kubectl contexts).

\`\`\`
SUBCOMMANDS:
  myapp context create <name> --endpoint <url>   Create a new context
  myapp context list                              List all contexts
  myapp context use <name>                        Set active context
  myapp context current                           Show active context
  myapp context delete <name>                     Delete a context

INPUT:
  name:     string (required) - Context identifier
  endpoint: string (required for create) - GraphQL endpoint URL

OUTPUT: JSON
  create:  { name, endpoint }
  list:    [{ name, endpoint, isCurrent, hasCredentials }]
  use:     { name, endpoint }
  current: { name, endpoint }
  delete:  { deleted: name }
\`\`\`

### TOOL: auth

Manage authentication tokens per context.

\`\`\`
SUBCOMMANDS:
  myapp auth set-token <token>   Store bearer token for current context
  myapp auth status               Show auth status for all contexts
  myapp auth logout                Remove credentials for current context

INPUT:
  token: string (required for set-token) - Bearer token value

OUTPUT: JSON
  set-token: { context, status: "authenticated" }
  status:    [{ context, authenticated: boolean }]
  logout:    { context, status: "logged out" }
\`\`\`

### TOOL: car

CRUD operations for Car records.

\`\`\`
SUBCOMMANDS:
  myapp car list                               List all records
  myapp car get --id <value>              Get one record
  myapp car create --make <value> --model <value> --year <value> --isElectric <value>
  myapp car update --id <value> [--make <value>] [--model <value>] [--year <value>] [--isElectric <value>]
  myapp car delete --id <value>           Delete one record

INPUT FIELDS:
  id: UUID (primary key)
  make: String
  model: String
  year: Int
  isElectric: Boolean
  createdAt: Datetime

EDITABLE FIELDS (for create/update):
  make: String
  model: String
  year: Int
  isElectric: Boolean

OUTPUT: JSON
  list:   [{ id, make, model, year, isElectric, createdAt }]
  get:    { id, make, model, year, isElectric, createdAt }
  create: { id, make, model, year, isElectric, createdAt }
  update: { id, make, model, year, isElectric, createdAt }
  delete: { id }
\`\`\`

### TOOL: driver

CRUD operations for Driver records.

\`\`\`
SUBCOMMANDS:
  myapp driver list                               List all records
  myapp driver get --id <value>              Get one record
  myapp driver create --name <value> --licenseNumber <value>
  myapp driver update --id <value> [--name <value>] [--licenseNumber <value>]
  myapp driver delete --id <value>           Delete one record

INPUT FIELDS:
  id: UUID (primary key)
  name: String
  licenseNumber: String

EDITABLE FIELDS (for create/update):
  name: String
  licenseNumber: String

OUTPUT: JSON
  list:   [{ id, name, licenseNumber }]
  get:    { id, name, licenseNumber }
  create: { id, name, licenseNumber }
  update: { id, name, licenseNumber }
  delete: { id }
\`\`\`

### TOOL: current-user

Get the currently authenticated user

\`\`\`
TYPE: query
USAGE: myapp current-user

INPUT: none

OUTPUT: JSON
\`\`\`

### TOOL: login

Authenticate a user

\`\`\`
TYPE: mutation
USAGE: myapp login --email <value> --password <value>

INPUT:
  email: String (required)
  password: String (required)

OUTPUT: JSON
\`\`\`

## WORKFLOWS

### Initial setup

\`\`\`bash
myapp context create dev --endpoint http://localhost:5000/graphql
myapp context use dev
myapp auth set-token eyJhbGciOiJIUzI1NiIs...
\`\`\`

### CRUD workflow (car)

\`\`\`bash
# List all
myapp car list

# Create
myapp car create --make "value" --model "value" --year "value" --isElectric "value"

# Get by id
myapp car get --id <value>

# Update
myapp car update --id <value> --make "new-value"

# Delete
myapp car delete --id <value>
\`\`\`

### Piping output

\`\`\`bash
# Pretty print
myapp car list | jq '.'

# Extract field
myapp car list | jq '.[].id'

# Count results
myapp car list | jq 'length'
\`\`\`

## ERROR HANDLING

All errors are written to stderr. Exit codes:
- \`0\`: Success
- \`1\`: Error (auth failure, not found, validation error, network error)

Common errors:
- "No active context": Run \`context use <name>\` first
- "Not authenticated": Run \`auth set-token <token>\` first
- "Record not found": The requested ID does not exist
"
`;

exports[`cli docs generator generates CLI README 1`] = `
"# myapp CLI

<p align="center" width="100%">
  <img height="120" src="https://raw.githubusercontent.com/constructive-io/constructive/refs/heads/main/assets/outline-logo.svg" />
</p>

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## Setup

\`\`\`bash
# Create a context pointing at your GraphQL endpoint
myapp context create production --endpoint https://api.example.com/graphql

# Set the active context
myapp context use production

# Authenticate
myapp auth set-token <your-token>
\`\`\`

## Commands

| Command | Description |
|---------|-------------|
| \`context\` | Manage API contexts (endpoints) |
| \`auth\` | Manage authentication tokens |
| \`car\` | car CRUD operations |
| \`driver\` | driver CRUD operations |
| \`current-user\` | Get the currently authenticated user |
| \`login\` | Authenticate a user |

## Infrastructure Commands

### \`context\`

Manage named API contexts (kubectl-style).

| Subcommand | Description |
|------------|-------------|
| \`create <name> --endpoint <url>\` | Create a new context |
| \`list\` | List all contexts |
| \`use <name>\` | Set the active context |
| \`current\` | Show current context |
| \`delete <name>\` | Delete a context |

Configuration is stored at \`~/.myapp/config/\`.

### \`auth\`

Manage authentication tokens per context.

| Subcommand | Description |
|------------|-------------|
| \`set-token <token>\` | Store bearer token for current context |
| \`status\` | Show auth status across all contexts |
| \`logout\` | Remove credentials for current context |

## Table Commands

### \`car\`

CRUD operations for Car records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all car records |
| \`get\` | Get a car by id |
| \`create\` | Create a new car |
| \`update\` | Update an existing car |
| \`delete\` | Delete a car |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`make\` | String |
| \`model\` | String |
| \`year\` | Int |
| \`isElectric\` | Boolean |
| \`createdAt\` | Datetime |

**Create fields:** \`make\`, \`model\`, \`year\`, \`isElectric\`

### \`driver\`

CRUD operations for Driver records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all driver records |
| \`get\` | Get a driver by id |
| \`create\` | Create a new driver |
| \`update\` | Update an existing driver |
| \`delete\` | Delete a driver |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`name\` | String |
| \`licenseNumber\` | String |

**Create fields:** \`name\`, \`licenseNumber\`

## Custom Operations

### \`current-user\`

Get the currently authenticated user

- **Type:** query
- **Arguments:** none

### \`login\`

Authenticate a user

- **Type:** mutation
- **Arguments:**

  | Argument | Type |
  |----------|------|
  | \`email\` | String (required) |
  | \`password\` | String (required) |

## Output

All commands output JSON to stdout. Pipe to \`jq\` for formatting:

\`\`\`bash
myapp car list | jq '.[]'
myapp car get --id <uuid> | jq '.'
\`\`\`

---

Built by the [Constructive](https://constructive.io) team.

## Disclaimer

AS DESCRIBED IN THE LICENSES, THE SOFTWARE IS PROVIDED "AS IS", AT YOUR OWN RISK, AND WITHOUT WARRANTIES OF ANY KIND.

No developer or entity involved in creating this software will be liable for any claims or damages whatsoever associated with your use, inability to use, or your interaction with other users of the code, including any direct, indirect, incidental, special, exemplary, punitive or consequential damages, or loss of profits, cryptocurrencies, tokens, or anything else of value.
"
`;

exports[`cli docs generator generates CLI skill files 1`] = `
"# myapp-context

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Manage API endpoint contexts for myapp

## Usage

\`\`\`bash
myapp context create <name> --endpoint <url>
myapp context list
myapp context use <name>
myapp context current
myapp context delete <name>
\`\`\`

## Examples

### Create and activate a context

\`\`\`bash
myapp context create production --endpoint https://api.example.com/graphql
myapp context use production
\`\`\`

### List all contexts

\`\`\`bash
myapp context list
\`\`\`
"
`;

exports[`cli docs generator generates CLI skill files 2`] = `
"# myapp-auth

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Manage authentication tokens for myapp

## Usage

\`\`\`bash
myapp auth set-token <token>
myapp auth status
myapp auth logout
\`\`\`

## Examples

### Authenticate with a token

\`\`\`bash
myapp auth set-token eyJhbGciOiJIUzI1NiIs...
\`\`\`

### Check auth status

\`\`\`bash
myapp auth status
\`\`\`
"
`;

exports[`cli docs generator generates CLI skill files 3`] = `
"# myapp-car

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

CRUD operations for Car records via myapp CLI

## Usage

\`\`\`bash
myapp car list
myapp car get --id <value>
myapp car create --make <value> --model <value> --year <value> --isElectric <value>
myapp car update --id <value> [--make <value>] [--model <value>] [--year <value>] [--isElectric <value>]
myapp car delete --id <value>
\`\`\`

## Examples

### List all car records

\`\`\`bash
myapp car list
\`\`\`

### Create a car

\`\`\`bash
myapp car create --make "value" --model "value" --year "value" --isElectric "value"
\`\`\`

### Get a car by id

\`\`\`bash
myapp car get --id <value>
\`\`\`

### Update a car

\`\`\`bash
myapp car update --id <value> --make "new-value"
\`\`\`

### Delete a car

\`\`\`bash
myapp car delete --id <value>
\`\`\`
"
`;

exports[`cli docs generator generates CLI skill files 4`] = `
"# myapp-driver

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

CRUD operations for Driver records via myapp CLI

## Usage

\`\`\`bash
myapp driver list
myapp driver get --id <value>
myapp driver create --name <value> --licenseNumber <value>
myapp driver update --id <value> [--name <value>] [--licenseNumber <value>]
myapp driver delete --id <value>
\`\`\`

## Examples

### List all driver records

\`\`\`bash
myapp driver list
\`\`\`

### Create a driver

\`\`\`bash
myapp driver create --name "value" --licenseNumber "value"
\`\`\`

### Get a driver by id

\`\`\`bash
myapp driver get --id <value>
\`\`\`

### Update a driver

\`\`\`bash
myapp driver update --id <value> --name "new-value"
\`\`\`

### Delete a driver

\`\`\`bash
myapp driver delete --id <value>
\`\`\`
"
`;

exports[`cli docs generator generates CLI skill files 5`] = `
"# myapp-current-user

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Get the currently authenticated user

## Usage

\`\`\`bash
myapp current-user
\`\`\`

## Examples

### Run currentUser

\`\`\`bash
myapp current-user
\`\`\`
"
`;

exports[`cli docs generator generates CLI skill files 6`] = `
"# myapp-login

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Authenticate a user

## Usage

\`\`\`bash
myapp login --email <value> --password <value>
\`\`\`

## Examples

### Run login

\`\`\`bash
myapp login --email <value> --password <value>
\`\`\`
"
`;

exports[`cli-generator generates commands.ts (command map) 1`] = `
"/**
 * CLI command map and entry point
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import contextCmd from "./commands/context";
import authCmd from "./commands/auth";
import carCmd from "./commands/car";
import driverCmd from "./commands/driver";
import currentUserCmd from "./commands/current-user";
import loginCmd from "./commands/login";
const createCommandMap = () => ({
  "context": contextCmd,
  "auth": authCmd,
  "car": carCmd,
  "driver": driverCmd,
  "current-user": currentUserCmd,
  "login": loginCmd
});
const usage = "\\nmyapp <command>\\n\\nCommands:\\n  context               Manage API contexts\\n  auth                  Manage authentication\\n  car                  car CRUD operations\\n  driver               driver CRUD operations\\n  current-user         Get the currently authenticated user\\n  login                Authenticate a user\\n\\n  --help, -h            Show this help message\\n  --version, -v         Show version\\n";
export const commands = async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  let {
    first: command,
    newArgv
  } = extractFirst(argv);
  const commandMap = createCommandMap();
  if (!command) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "command",
      message: "What do you want to do?",
      options: Object.keys(commandMap)
    }]);
    command = answer.command;
  }
  const commandFn = commandMap[command];
  if (!commandFn) {
    console.log(usage);
    console.error(\`Unknown command: \${command}\`);
    process.exit(1);
  }
  await commandFn(newArgv, prompter, options);
  prompter.close();
  return argv;
};"
`;

exports[`cli-generator generates commands/auth.ts 1`] = `
"/**
 * Authentication commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp auth <command>\\n\\nCommands:\\n  set-token <token>     Set API token for the current context\\n  status                Show authentication status\\n  logout                Remove credentials for the current context\\n\\nOptions:\\n  --context <name>      Specify context (defaults to current context)\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["set-token", "status", "logout"]
    }]);
    return handleAuthSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleAuthSubcommand(subcommand, newArgv, prompter, store);
};
async function handleAuthSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "set-token":
      return handleSetToken(argv, prompter, store);
    case "status":
      return handleStatus(store);
    case "logout":
      return handleLogout(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleSetToken(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.error("No active context. Run \\"context create\\" first.");
    process.exit(1);
  }
  const {
    first: token
  } = extractFirst(argv);
  let tokenValue = token;
  if (!tokenValue) {
    const answer = await prompter.prompt(argv, [{
      type: "password",
      name: "token",
      message: "API Token",
      required: true
    }]);
    tokenValue = answer.token;
  }
  store.setCredentials(current.name, {
    token: String(tokenValue || "").trim()
  });
  console.log(\`Token saved for context: \${current.name}\`);
}
function handleStatus(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Authentication Status:");
  for (const ctx of contexts) {
    const isCurrent = ctx.name === settings.currentContext;
    const hasAuth = store.hasValidCredentials(ctx.name);
    const marker = isCurrent ? "* " : "  ";
    const status = hasAuth ? "authenticated" : "no token";
    console.log(\`\${marker}\${ctx.name} [\${status}]\`);
  }
}
async function handleLogout(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No active context.");
    return;
  }
  const confirm = await prompter.prompt(argv, [{
    type: "confirm",
    name: "confirm",
    message: \`Remove credentials for "\${current.name}"?\`,
    default: false
  }]);
  if (!confirm.confirm) {
    return;
  }
  if (store.removeCredentials(current.name)) {
    console.log(\`Credentials removed for: \${current.name}\`);
  } else {
    console.log(\`No credentials found for: \${current.name}\`);
  }
}"
`;

exports[`cli-generator generates commands/car.ts 1`] = `
"/**
 * CLI commands for Car
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../executor";
import { coerceAnswers, stripUndefined } from "../utils";
const fieldSchema = {
  id: "uuid",
  make: "string",
  model: "string",
  year: "int",
  isElectric: "boolean",
  createdAt: "string"
};
const usage = "\\ncar <command>\\n\\nCommands:\\n  list                  List all car records\\n  get                   Get a car by ID\\n  create                Create a new car\\n  update                Update an existing car\\n  delete                Delete a car\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient();
    const result = await client.car.findMany({
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.car.findOne({
      id: answers.id,
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "make",
      message: "make",
      required: true
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: true
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: true
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient();
    const result = await client.car.create({
      data: {
        make: cleanedData.make,
        model: cleanedData.model,
        year: cleanedData.year,
        isElectric: cleanedData.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "make",
      message: "make",
      required: false
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: false
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: false
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: false
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient();
    const result = await client.car.update({
      where: {
        id: answers.id as string
      },
      data: {
        make: cleanedData.make,
        model: cleanedData.model,
        year: cleanedData.year,
        isElectric: cleanedData.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const client = getClient();
    const result = await client.car.delete({
      where: {
        id: answers.id as string
      },
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/context.ts 1`] = `
"/**
 * Context management commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp context <command>\\n\\nCommands:\\n  create <name>         Create a new context\\n  list                  List all contexts\\n  use <name>            Set the active context\\n  current               Show current context\\n  delete <name>         Delete a context\\n\\nCreate Options:\\n  --endpoint <url>      GraphQL endpoint URL\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["create", "list", "use", "current", "delete"]
    }]);
    return handleSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleSubcommand(subcommand, newArgv, prompter, store);
};
async function handleSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "create":
      return handleCreate(argv, prompter, store);
    case "list":
      return handleList(store);
    case "use":
      return handleUse(argv, prompter, store);
    case "current":
      return handleCurrent(store);
    case "delete":
      return handleDelete(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name,
    newArgv: restArgv
  } = extractFirst(argv);
  const answers = await prompter.prompt({
    name,
    ...restArgv
  }, [{
    type: "text",
    name: "name",
    message: "Context name",
    required: true
  }, {
    type: "text",
    name: "endpoint",
    message: "GraphQL endpoint URL",
    required: true
  }]);
  const contextName = answers.name;
  const endpoint = answers.endpoint;
  store.createContext(contextName, {
    endpoint: endpoint
  });
  const settings = store.loadSettings();
  if (!settings.currentContext) {
    store.setCurrentContext(contextName);
  }
  console.log(\`Created context: \${contextName}\`);
  console.log(\`  Endpoint: \${endpoint}\`);
}
function handleList(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Contexts:");
  for (const ctx of contexts) {
    const marker = ctx.name === settings.currentContext ? "* " : "  ";
    const authStatus = store.hasValidCredentials(ctx.name) ? "[authenticated]" : "[no token]";
    console.log(\`\${marker}\${ctx.name} \${authStatus}\`);
    console.log(\`    Endpoint: \${ctx.endpoint}\`);
  }
}
async function handleUse(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.setCurrentContext(contextName)) {
    console.log(\`Switched to context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}
function handleCurrent(store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No current context set.");
    return;
  }
  console.log(\`Current context: \${current.name}\`);
  console.log(\`  Endpoint: \${current.endpoint}\`);
  const hasAuth = store.hasValidCredentials(current.name);
  console.log(\`  Auth: \${hasAuth ? "authenticated" : "not authenticated"}\`);
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context to delete",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.deleteContext(contextName)) {
    console.log(\`Deleted context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/current-user.ts (custom query) 1`] = `
"/**
 * CLI command for query currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer } from "inquirerer";
import { getClient } from "../executor";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  try {
    if (argv.help || argv.h) {
      console.log("current-user - Get the currently authenticated user\\n\\nUsage: current-user [OPTIONS]\\n");
      process.exit(0);
    }
    const client = getClient();
    const result = await client.query.currentUser({}).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed: currentUser");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
};"
`;

exports[`cli-generator generates commands/driver.ts 1`] = `
"/**
 * CLI commands for Driver
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../executor";
import { coerceAnswers, stripUndefined } from "../utils";
const fieldSchema = {
  id: "uuid",
  name: "string",
  licenseNumber: "string"
};
const usage = "\\ndriver <command>\\n\\nCommands:\\n  list                  List all driver records\\n  get                   Get a driver by ID\\n  create                Create a new driver\\n  update                Update an existing driver\\n  delete                Delete a driver\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient();
    const result = await client.driver.findMany({
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient();
    const result = await client.driver.findOne({
      id: answers.id,
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "name",
      message: "name",
      required: true
    }, {
      type: "text",
      name: "licenseNumber",
      message: "licenseNumber",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient();
    const result = await client.driver.create({
      data: {
        name: cleanedData.name,
        licenseNumber: cleanedData.licenseNumber
      },
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "name",
      message: "name",
      required: false
    }, {
      type: "text",
      name: "licenseNumber",
      message: "licenseNumber",
      required: false
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient();
    const result = await client.driver.update({
      where: {
        id: answers.id as string
      },
      data: {
        name: cleanedData.name,
        licenseNumber: cleanedData.licenseNumber
      },
      select: {
        id: true,
        name: true,
        licenseNumber: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const client = getClient();
    const result = await client.driver.delete({
      where: {
        id: answers.id as string
      },
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`cli-generator generates commands/login.ts (custom mutation) 1`] = `
"/**
 * CLI command for mutation login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer } from "inquirerer";
import { getClient } from "../executor";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  try {
    if (argv.help || argv.h) {
      console.log("login - Authenticate a user\\n\\nUsage: login [OPTIONS]\\n");
      process.exit(0);
    }
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "email",
      message: "email",
      required: true
    }, {
      type: "text",
      name: "password",
      message: "password",
      required: true
    }]);
    const client = getClient();
    const result = await client.mutation.login(answers).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed: login");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
};"
`;

exports[`cli-generator generates executor.ts 1`] = `
"/**
 * Executor and config store for CLI
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { createConfigStore } from "appstash";
import { createClient } from "../orm";
const store = createConfigStore("myapp");
export const getStore = () => store;
export function getClient(contextName?: string) {
  let ctx = null;
  if (contextName) {
    ctx = store.loadContext(contextName);
    if (!ctx) {
      throw new Error(\`Context "\${contextName}" not found.\`);
    }
  } else {
    ctx = store.getCurrentContext();
    if (!ctx) {
      throw new Error("No active context. Run \\"context create\\" or \\"context use\\" first.");
    }
  }
  const headers = {};
  if (store.hasValidCredentials(ctx.name)) {
    const creds = store.getCredentials(ctx.name);
    if (creds?.token) {
      headers.Authorization = \`Bearer \${creds.token}\`;
    }
  }
  return createClient({
    endpoint: ctx.endpoint,
    headers: headers
  });
}"
`;

exports[`hooks docs generator generates hooks AGENTS.md 1`] = `
"# React Query Hooks - Agent Reference

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT
> This document is structured for LLM/agent consumption.

## OVERVIEW

React Query hooks wrapping ORM operations for data fetching and mutations.
All query hooks return \`UseQueryResult\`. All mutation hooks return \`UseMutationResult\`.

## SETUP

\`\`\`typescript
import { configure } from './hooks';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

configure({ endpoint: 'https://api.example.com/graphql' });
const queryClient = new QueryClient();
// Wrap app in <QueryClientProvider client={queryClient}>
\`\`\`

## HOOKS

### HOOK: useCarsQuery

List all cars.

\`\`\`
TYPE: query
USAGE: useCarsQuery({ selection: { fields: { ... } } })

INPUT:
  selection: { fields: Record<string, boolean> } - Fields to select

OUTPUT: UseQueryResult<Array<{
  id: string
  make: string
  model: string
  year: number
  isElectric: boolean
  createdAt: string
}>>
\`\`\`

### HOOK: useCarQuery

Get a single car by id.

\`\`\`
TYPE: query
USAGE: useCarQuery({ id: '<value>', selection: { fields: { ... } } })

INPUT:
  id: string (required)
  selection: { fields: Record<string, boolean> } - Fields to select

OUTPUT: UseQueryResult<{
  id: string
  make: string
  model: string
  year: number
  isElectric: boolean
  createdAt: string
}>
\`\`\`

### HOOK: useCreateCarMutation

Create a new car.

\`\`\`
TYPE: mutation
USAGE: const { mutate } = useCreateCarMutation({ selection: { fields: { ... } } })

OUTPUT: UseMutationResult
\`\`\`

### HOOK: useUpdateCarMutation

Update an existing car.

\`\`\`
TYPE: mutation
USAGE: const { mutate } = useUpdateCarMutation({ selection: { fields: { ... } } })

OUTPUT: UseMutationResult
\`\`\`

### HOOK: useDeleteCarMutation

Delete a car.

\`\`\`
TYPE: mutation
USAGE: const { mutate } = useDeleteCarMutation({})

OUTPUT: UseMutationResult
\`\`\`

### HOOK: useDriversQuery

List all drivers.

\`\`\`
TYPE: query
USAGE: useDriversQuery({ selection: { fields: { ... } } })

INPUT:
  selection: { fields: Record<string, boolean> } - Fields to select

OUTPUT: UseQueryResult<Array<{
  id: string
  name: string
  licenseNumber: string
}>>
\`\`\`

### HOOK: useDriverQuery

Get a single driver by id.

\`\`\`
TYPE: query
USAGE: useDriverQuery({ id: '<value>', selection: { fields: { ... } } })

INPUT:
  id: string (required)
  selection: { fields: Record<string, boolean> } - Fields to select

OUTPUT: UseQueryResult<{
  id: string
  name: string
  licenseNumber: string
}>
\`\`\`

### HOOK: useCreateDriverMutation

Create a new driver.

\`\`\`
TYPE: mutation
USAGE: const { mutate } = useCreateDriverMutation({ selection: { fields: { ... } } })

OUTPUT: UseMutationResult
\`\`\`

### HOOK: useUpdateDriverMutation

Update an existing driver.

\`\`\`
TYPE: mutation
USAGE: const { mutate } = useUpdateDriverMutation({ selection: { fields: { ... } } })

OUTPUT: UseMutationResult
\`\`\`

### HOOK: useDeleteDriverMutation

Delete a driver.

\`\`\`
TYPE: mutation
USAGE: const { mutate } = useDeleteDriverMutation({})

OUTPUT: UseMutationResult
\`\`\`

## CUSTOM OPERATION HOOKS

### HOOK: useCurrentUserQuery

Get the currently authenticated user

\`\`\`
TYPE: query
USAGE: useCurrentUserQuery()

INPUT: none

OUTPUT: UseQueryResult
\`\`\`

### HOOK: useLoginMutation

Authenticate a user

\`\`\`
TYPE: mutation
USAGE: const { mutate } = useLoginMutation()
  mutate({ email: <value>, password: <value> })

INPUT:
  email: String (required)
  password: String (required)

OUTPUT: UseMutationResult
\`\`\`
"
`;

exports[`hooks docs generator generates hooks README 1`] = `
"# React Query Hooks

<p align="center" width="100%">
  <img height="120" src="https://raw.githubusercontent.com/constructive-io/constructive/refs/heads/main/assets/outline-logo.svg" />
</p>

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## Setup

\`\`\`typescript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { configure } from './hooks';

configure({
  endpoint: 'https://api.example.com/graphql',
  headers: { Authorization: 'Bearer <token>' },
});

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}
\`\`\`

## Hooks

| Hook | Type | Description |
|------|------|-------------|
| \`useCarsQuery\` | Query | List all cars |
| \`useCarQuery\` | Query | Get one car |
| \`useCreateCarMutation\` | Mutation | Create a car |
| \`useUpdateCarMutation\` | Mutation | Update a car |
| \`useDeleteCarMutation\` | Mutation | Delete a car |
| \`useDriversQuery\` | Query | List all drivers |
| \`useDriverQuery\` | Query | Get one driver |
| \`useCreateDriverMutation\` | Mutation | Create a driver |
| \`useUpdateDriverMutation\` | Mutation | Update a driver |
| \`useDeleteDriverMutation\` | Mutation | Delete a driver |
| \`useCurrentUserQuery\` | Query | Get the currently authenticated user |
| \`useLoginMutation\` | Mutation | Authenticate a user |

## Table Hooks

### Car

\`\`\`typescript
// List all cars
const { data, isLoading } = useCarsQuery({
  selection: { fields: { id: true, make: true, model: true, year: true, isElectric: true, createdAt: true } },
});

// Get one car
const { data: item } = useCarQuery({
  id: '<value>',
  selection: { fields: { id: true, make: true, model: true, year: true, isElectric: true, createdAt: true } },
});

// Create a car
const { mutate: create } = useCreateCarMutation({
  selection: { fields: { id: true } },
});
create({ make: '<value>', model: '<value>', year: '<value>', isElectric: '<value>' });
\`\`\`

### Driver

\`\`\`typescript
// List all drivers
const { data, isLoading } = useDriversQuery({
  selection: { fields: { id: true, name: true, licenseNumber: true } },
});

// Get one driver
const { data: item } = useDriverQuery({
  id: '<value>',
  selection: { fields: { id: true, name: true, licenseNumber: true } },
});

// Create a driver
const { mutate: create } = useCreateDriverMutation({
  selection: { fields: { id: true } },
});
create({ name: '<value>', licenseNumber: '<value>' });
\`\`\`

## Custom Operation Hooks

### \`useCurrentUserQuery\`

Get the currently authenticated user

- **Type:** query
- **Arguments:** none

### \`useLoginMutation\`

Authenticate a user

- **Type:** mutation
- **Arguments:**

  | Argument | Type |
  |----------|------|
  | \`email\` | String (required) |
  | \`password\` | String (required) |

---

Built by the [Constructive](https://constructive.io) team.

## Disclaimer

AS DESCRIBED IN THE LICENSES, THE SOFTWARE IS PROVIDED "AS IS", AT YOUR OWN RISK, AND WITHOUT WARRANTIES OF ANY KIND.

No developer or entity involved in creating this software will be liable for any claims or damages whatsoever associated with your use, inability to use, or your interaction with other users of the code, including any direct, indirect, incidental, special, exemplary, punitive or consequential damages, or loss of profits, cryptocurrencies, tokens, or anything else of value.
"
`;

exports[`hooks docs generator generates hooks skill files 1`] = `
"# hooks-car

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

React Query hooks for Car data operations

## Usage

\`\`\`typescript
useCarsQuery({ selection: { fields: { id: true, make: true, model: true, year: true, isElectric: true, createdAt: true } } })
useCarQuery({ id: '<value>', selection: { fields: { id: true, make: true, model: true, year: true, isElectric: true, createdAt: true } } })
useCreateCarMutation({ selection: { fields: { id: true } } })
useUpdateCarMutation({ selection: { fields: { id: true } } })
useDeleteCarMutation({})
\`\`\`

## Examples

### List all cars

\`\`\`typescript
const { data, isLoading } = useCarsQuery({
  selection: { fields: { id: true, make: true, model: true, year: true, isElectric: true, createdAt: true } },
});
\`\`\`

### Create a car

\`\`\`typescript
const { mutate } = useCreateCarMutation({
  selection: { fields: { id: true } },
});
mutate({ make: '<value>', model: '<value>', year: '<value>', isElectric: '<value>' });
\`\`\`
"
`;

exports[`hooks docs generator generates hooks skill files 2`] = `
"# hooks-driver

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

React Query hooks for Driver data operations

## Usage

\`\`\`typescript
useDriversQuery({ selection: { fields: { id: true, name: true, licenseNumber: true } } })
useDriverQuery({ id: '<value>', selection: { fields: { id: true, name: true, licenseNumber: true } } })
useCreateDriverMutation({ selection: { fields: { id: true } } })
useUpdateDriverMutation({ selection: { fields: { id: true } } })
useDeleteDriverMutation({})
\`\`\`

## Examples

### List all drivers

\`\`\`typescript
const { data, isLoading } = useDriversQuery({
  selection: { fields: { id: true, name: true, licenseNumber: true } },
});
\`\`\`

### Create a driver

\`\`\`typescript
const { mutate } = useCreateDriverMutation({
  selection: { fields: { id: true } },
});
mutate({ name: '<value>', licenseNumber: '<value>' });
\`\`\`
"
`;

exports[`hooks docs generator generates hooks skill files 3`] = `
"# hooks-currentUser

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Get the currently authenticated user

## Usage

\`\`\`typescript
useCurrentUserQuery()
\`\`\`

## Examples

### Use useCurrentUserQuery

\`\`\`typescript
const { data, isLoading } = useCurrentUserQuery();
\`\`\`
"
`;

exports[`hooks docs generator generates hooks skill files 4`] = `
"# hooks-login

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Authenticate a user

## Usage

\`\`\`typescript
const { mutate } = useLoginMutation(); mutate({ email: '<value>', password: '<value>' });
\`\`\`

## Examples

### Use useLoginMutation

\`\`\`typescript
const { mutate, isLoading } = useLoginMutation();
mutate({ email: '<value>', password: '<value>' });
\`\`\`
"
`;

exports[`multi-target cli docs generates multi-target AGENTS.md 1`] = `
"# myapp CLI - Agent Reference

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT
> This document is structured for LLM/agent consumption.

## OVERVIEW

\`myapp\` is a unified multi-target CLI for interacting with multiple GraphQL APIs.
All commands output JSON to stdout. All commands accept \`--help\` or \`-h\` for usage.
Configuration is stored at \`~/.myapp/config/\` via appstash.

TARGETS:
  auth: http://auth.localhost/graphql
  members: http://members.localhost/graphql
  app: http://app.localhost/graphql

COMMAND FORMAT:
  myapp <target>:<command> <subcommand> [flags]    Target-specific commands
  myapp context <subcommand> [flags]              Context management
  myapp credentials <subcommand> [flags]                 Authentication

## PREREQUISITES

Before running any data commands, you must:

1. Create a context: \`myapp context create <name>\`
   (prompts for per-target endpoints, defaults baked from config)
2. Activate it: \`myapp context use <name>\`
3. Authenticate: \`myapp credentials set-token <token>\`

For local development, create a context accepting all defaults:

\`\`\`bash
myapp context create local
myapp context use local
myapp credentials set-token <token>
\`\`\`

## TOOLS

### TOOL: context

Manage named API endpoint contexts. Each context stores per-target endpoint overrides.

\`\`\`
SUBCOMMANDS:
  myapp context create <name>   Create a new context
  myapp context list              List all contexts
  myapp context use <name>        Set active context
  myapp context current           Show active context
  myapp context delete <name>     Delete a context

CREATE OPTIONS:
  --auth-endpoint: string (default: http://auth.localhost/graphql)
  --members-endpoint: string (default: http://members.localhost/graphql)
  --app-endpoint: string (default: http://app.localhost/graphql)

OUTPUT: JSON
  create:  { name, endpoint, targets }
  list:    [{ name, endpoint, isCurrent, hasCredentials }]
  use:     { name, endpoint }
  current: { name, endpoint }
  delete:  { deleted: name }
\`\`\`

### TOOL: credentials

Manage authentication tokens per context. One shared token across all targets.

\`\`\`
SUBCOMMANDS:
  myapp credentials set-token <token>   Store bearer token for current context
  myapp credentials status               Show auth status for all contexts
  myapp credentials logout                Remove credentials for current context

INPUT:
  token: string (required for set-token) - Bearer token value

OUTPUT: JSON
  set-token: { context, status: "authenticated" }
  status:    [{ context, authenticated: boolean }]
  logout:    { context, status: "logged out" }
\`\`\`

### TOOL: auth:user

CRUD operations for User records (auth target).

\`\`\`
SUBCOMMANDS:
  myapp auth:user list                               List all records
  myapp auth:user get --id <value>              Get one record
  myapp auth:user create --email <value> --name <value>
  myapp auth:user update --id <value> [--email <value>] [--name <value>]
  myapp auth:user delete --id <value>           Delete one record

INPUT FIELDS:
  id: UUID (primary key)
  email: String
  name: String

EDITABLE FIELDS (for create/update):
  email: String
  name: String

OUTPUT: JSON
  list:   [{ id, email, name }]
  get:    { id, email, name }
  create: { id, email, name }
  update: { id, email, name }
  delete: { id }
\`\`\`

### TOOL: auth:current-user

Get the currently authenticated user

\`\`\`
TYPE: query
USAGE: myapp auth:current-user

INPUT: none

OUTPUT: JSON
\`\`\`

### TOOL: auth:login

Authenticate a user

\`\`\`
TYPE: mutation
USAGE: myapp auth:login --email <value> --password <value>

INPUT:
  email: String (required)
  password: String (required)

FLAGS:
  --save-token: boolean - Auto-save returned token to credentials

OUTPUT: JSON
\`\`\`

### TOOL: members:member

CRUD operations for Member records (members target).

\`\`\`
SUBCOMMANDS:
  myapp members:member list                               List all records
  myapp members:member get --id <value>              Get one record
  myapp members:member create --role <value>
  myapp members:member update --id <value> [--role <value>]
  myapp members:member delete --id <value>           Delete one record

INPUT FIELDS:
  id: UUID (primary key)
  role: String

EDITABLE FIELDS (for create/update):
  role: String

OUTPUT: JSON
  list:   [{ id, role }]
  get:    { id, role }
  create: { id, role }
  update: { id, role }
  delete: { id }
\`\`\`

### TOOL: app:car

CRUD operations for Car records (app target).

\`\`\`
SUBCOMMANDS:
  myapp app:car list                               List all records
  myapp app:car get --id <value>              Get one record
  myapp app:car create --make <value> --model <value> --year <value> --isElectric <value>
  myapp app:car update --id <value> [--make <value>] [--model <value>] [--year <value>] [--isElectric <value>]
  myapp app:car delete --id <value>           Delete one record

INPUT FIELDS:
  id: UUID (primary key)
  make: String
  model: String
  year: Int
  isElectric: Boolean
  createdAt: Datetime

EDITABLE FIELDS (for create/update):
  make: String
  model: String
  year: Int
  isElectric: Boolean

OUTPUT: JSON
  list:   [{ id, make, model, year, isElectric, createdAt }]
  get:    { id, make, model, year, isElectric, createdAt }
  create: { id, make, model, year, isElectric, createdAt }
  update: { id, make, model, year, isElectric, createdAt }
  delete: { id }
\`\`\`

## WORKFLOWS

### Initial setup

\`\`\`bash
myapp context create dev
myapp context use dev
myapp credentials set-token eyJhbGciOiJIUzI1NiIs...
\`\`\`

### Switch environment

\`\`\`bash
myapp context create production \\
  --auth-endpoint https://auth.prod.example.com/graphql \\
  --members-endpoint https://members.prod.example.com/graphql \\
  --app-endpoint https://app.prod.example.com/graphql
myapp context use production
\`\`\`

### CRUD workflow (auth:user)

\`\`\`bash
myapp auth:user list
myapp auth:user create --email "value" --name "value"
myapp auth:user get --id <value>
myapp auth:user update --id <value> --email "new-value"
myapp auth:user delete --id <value>
\`\`\`

### Piping output

\`\`\`bash
myapp auth:user list | jq '.'
myapp auth:user list | jq '.[].id'
myapp auth:user list | jq 'length'
\`\`\`

## ERROR HANDLING

All errors are written to stderr. Exit codes:
- \`0\`: Success
- \`1\`: Error (auth failure, not found, validation error, network error)

Common errors:
- "No active context": Run \`context use <name>\` first
- "Not authenticated": Run \`credentials set-token <token>\` first
- "Unknown target": The target name is not recognized
- "Record not found": The requested ID does not exist
"
`;

exports[`multi-target cli docs generates multi-target MCP tools 1`] = `
[
  {
    "description": "Create a named API context with per-target endpoint overrides",
    "inputSchema": {
      "properties": {
        "app_endpoint": {
          "description": "app GraphQL endpoint (default: http://app.localhost/graphql)",
          "type": "string",
        },
        "auth_endpoint": {
          "description": "auth GraphQL endpoint (default: http://auth.localhost/graphql)",
          "type": "string",
        },
        "members_endpoint": {
          "description": "members GraphQL endpoint (default: http://members.localhost/graphql)",
          "type": "string",
        },
        "name": {
          "description": "Context name",
          "type": "string",
        },
      },
      "required": [
        "name",
      ],
      "type": "object",
    },
    "name": "myapp_context_create",
  },
  {
    "description": "List all configured API contexts",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_context_list",
  },
  {
    "description": "Set the active API context (switches all targets at once)",
    "inputSchema": {
      "properties": {
        "name": {
          "description": "Context name to activate",
          "type": "string",
        },
      },
      "required": [
        "name",
      ],
      "type": "object",
    },
    "name": "myapp_context_use",
  },
  {
    "description": "Show the currently active API context",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_context_current",
  },
  {
    "description": "Delete an API context",
    "inputSchema": {
      "properties": {
        "name": {
          "description": "Context name to delete",
          "type": "string",
        },
      },
      "required": [
        "name",
      ],
      "type": "object",
    },
    "name": "myapp_context_delete",
  },
  {
    "description": "Store a bearer token for the current context (shared across all targets)",
    "inputSchema": {
      "properties": {
        "token": {
          "description": "Bearer token value",
          "type": "string",
        },
      },
      "required": [
        "token",
      ],
      "type": "object",
    },
    "name": "myapp_credentials_set_token",
  },
  {
    "description": "Show authentication status for all contexts",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_credentials_status",
  },
  {
    "description": "Remove credentials for the current context",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_credentials_logout",
  },
  {
    "description": "List all User records (auth target)",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_auth_user_list",
  },
  {
    "description": "Get a single User record by id (auth target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "User id",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_auth_user_get",
  },
  {
    "description": "Create a new User record (auth target)",
    "inputSchema": {
      "properties": {
        "email": {
          "description": "User email",
          "type": "string",
        },
        "name": {
          "description": "User name",
          "type": "string",
        },
      },
      "required": [
        "email",
        "name",
      ],
      "type": "object",
    },
    "name": "myapp_auth_user_create",
  },
  {
    "description": "Update an existing User record (auth target)",
    "inputSchema": {
      "properties": {
        "email": {
          "description": "User email",
          "type": "string",
        },
        "id": {
          "description": "User id",
          "type": "string",
        },
        "name": {
          "description": "User name",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_auth_user_update",
  },
  {
    "description": "Delete a User record by id (auth target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "User id",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_auth_user_delete",
  },
  {
    "_meta": {
      "fields": [
        {
          "editable": false,
          "name": "id",
          "primaryKey": true,
          "type": "UUID",
        },
        {
          "editable": true,
          "name": "email",
          "primaryKey": false,
          "type": "String",
        },
        {
          "editable": true,
          "name": "name",
          "primaryKey": false,
          "type": "String",
        },
      ],
    },
    "description": "List available fields for User (auth target)",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_auth_user_fields",
  },
  {
    "description": "Get the currently authenticated user (auth target)",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_auth_current-user",
  },
  {
    "description": "Authenticate a user (auth target)",
    "inputSchema": {
      "properties": {
        "email": {
          "description": "email",
          "type": "string",
        },
        "password": {
          "description": "password",
          "type": "string",
        },
        "save_token": {
          "description": "Auto-save returned token to credentials",
          "type": "boolean",
        },
      },
      "required": [
        "email",
        "password",
      ],
      "type": "object",
    },
    "name": "myapp_auth_login",
  },
  {
    "description": "List all Member records (members target)",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_members_member_list",
  },
  {
    "description": "Get a single Member record by id (members target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "Member id",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_members_member_get",
  },
  {
    "description": "Create a new Member record (members target)",
    "inputSchema": {
      "properties": {
        "role": {
          "description": "Member role",
          "type": "string",
        },
      },
      "required": [
        "role",
      ],
      "type": "object",
    },
    "name": "myapp_members_member_create",
  },
  {
    "description": "Update an existing Member record (members target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "Member id",
          "type": "string",
        },
        "role": {
          "description": "Member role",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_members_member_update",
  },
  {
    "description": "Delete a Member record by id (members target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "Member id",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_members_member_delete",
  },
  {
    "_meta": {
      "fields": [
        {
          "editable": false,
          "name": "id",
          "primaryKey": true,
          "type": "UUID",
        },
        {
          "editable": true,
          "name": "role",
          "primaryKey": false,
          "type": "String",
        },
      ],
    },
    "description": "List available fields for Member (members target)",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_members_member_fields",
  },
  {
    "description": "List all Car records (app target)",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_app_car_list",
  },
  {
    "description": "Get a single Car record by id (app target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "Car id",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_app_car_get",
  },
  {
    "description": "Create a new Car record (app target)",
    "inputSchema": {
      "properties": {
        "isElectric": {
          "description": "Car isElectric",
          "type": "boolean",
        },
        "make": {
          "description": "Car make",
          "type": "string",
        },
        "model": {
          "description": "Car model",
          "type": "string",
        },
        "year": {
          "description": "Car year",
          "type": "integer",
        },
      },
      "required": [
        "make",
        "model",
        "year",
        "isElectric",
      ],
      "type": "object",
    },
    "name": "myapp_app_car_create",
  },
  {
    "description": "Update an existing Car record (app target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "Car id",
          "type": "string",
        },
        "isElectric": {
          "description": "Car isElectric",
          "type": "boolean",
        },
        "make": {
          "description": "Car make",
          "type": "string",
        },
        "model": {
          "description": "Car model",
          "type": "string",
        },
        "year": {
          "description": "Car year",
          "type": "integer",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_app_car_update",
  },
  {
    "description": "Delete a Car record by id (app target)",
    "inputSchema": {
      "properties": {
        "id": {
          "description": "Car id",
          "type": "string",
        },
      },
      "required": [
        "id",
      ],
      "type": "object",
    },
    "name": "myapp_app_car_delete",
  },
  {
    "_meta": {
      "fields": [
        {
          "editable": false,
          "name": "id",
          "primaryKey": true,
          "type": "UUID",
        },
        {
          "editable": true,
          "name": "make",
          "primaryKey": false,
          "type": "String",
        },
        {
          "editable": true,
          "name": "model",
          "primaryKey": false,
          "type": "String",
        },
        {
          "editable": true,
          "name": "year",
          "primaryKey": false,
          "type": "Int",
        },
        {
          "editable": true,
          "name": "isElectric",
          "primaryKey": false,
          "type": "Boolean",
        },
        {
          "editable": false,
          "name": "createdAt",
          "primaryKey": false,
          "type": "Datetime",
        },
      ],
    },
    "description": "List available fields for Car (app target)",
    "inputSchema": {
      "properties": {},
      "type": "object",
    },
    "name": "myapp_app_car_fields",
  },
]
`;

exports[`multi-target cli docs generates multi-target README 1`] = `
"# myapp CLI

<p align="center" width="100%">
  <img height="120" src="https://raw.githubusercontent.com/constructive-io/constructive/refs/heads/main/assets/outline-logo.svg" />
</p>

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## Setup

### Create a context

A context stores per-target endpoint overrides for an environment (dev, staging, production).
Default endpoints are baked in from the codegen config, so local development works with zero configuration.

\`\`\`bash
# Interactive - prompts for each target endpoint (defaults shown)
myapp context create local

# Non-interactive
myapp context create production \\
  --auth-endpoint https://auth.prod.example.com/graphql \\
  --members-endpoint https://members.prod.example.com/graphql \\
  --app-endpoint https://app.prod.example.com/graphql
\`\`\`

### Activate a context

\`\`\`bash
myapp context use production
\`\`\`

### Authenticate

\`\`\`bash
myapp credentials set-token <your-token>
\`\`\`

Or authenticate via a login mutation (auto-saves token):

\`\`\`bash
myapp auth:login --email <value> --password <value> --save-token
\`\`\`

## API Targets

| Target | Default Endpoint | Tables | Custom Operations |
|--------|-----------------|--------|-------------------|
| \`auth\` | http://auth.localhost/graphql | 1 | 2 |
| \`members\` | http://members.localhost/graphql | 1 | 0 |
| \`app\` | http://app.localhost/graphql | 1 | 0 |

## Commands

### Infrastructure

| Command | Description |
|---------|-------------|
| \`context\` | Manage API contexts (per-target endpoints) |
| \`credentials\` | Manage authentication tokens |

### auth

| Command | Description |
|---------|-------------|
| \`auth:user\` | user CRUD operations |
| \`auth:current-user\` | Get the currently authenticated user |
| \`auth:login\` | Authenticate a user |

### members

| Command | Description |
|---------|-------------|
| \`members:member\` | member CRUD operations |

### app

| Command | Description |
|---------|-------------|
| \`app:car\` | car CRUD operations |

## Infrastructure Commands

### \`context\`

Manage named API contexts (kubectl-style). Each context stores per-target endpoint overrides.

| Subcommand | Description |
|------------|-------------|
| \`create <name>\` | Create a new context (prompts for per-target endpoints) |
| \`list\` | List all contexts |
| \`use <name>\` | Set the active context |
| \`current\` | Show current context |
| \`delete <name>\` | Delete a context |

Create options:

- \`--auth-endpoint <url>\` (default: http://auth.localhost/graphql)
- \`--members-endpoint <url>\` (default: http://members.localhost/graphql)
- \`--app-endpoint <url>\` (default: http://app.localhost/graphql)

Configuration is stored at \`~/.myapp/config/\`.

### \`credentials\`

Manage authentication tokens per context. One shared token is used across all targets.

| Subcommand | Description |
|------------|-------------|
| \`set-token <token>\` | Store bearer token for current context |
| \`status\` | Show auth status across all contexts |
| \`logout\` | Remove credentials for current context |

## auth Commands

### \`auth:user\`

CRUD operations for User records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all user records |
| \`get\` | Get a user by id |
| \`create\` | Create a new user |
| \`update\` | Update an existing user |
| \`delete\` | Delete a user |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`email\` | String |
| \`name\` | String |

**Create fields:** \`email\`, \`name\`

### \`auth:current-user\`

Get the currently authenticated user

- **Type:** query
- **Arguments:** none

### \`auth:login\`

Authenticate a user

- **Type:** mutation
- **Arguments:**

  | Argument | Type |
  |----------|------|
  | \`email\` | String (required) |
  | \`password\` | String (required) |
- **Flags:** \`--save-token\` auto-saves returned token to credentials

## members Commands

### \`members:member\`

CRUD operations for Member records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all member records |
| \`get\` | Get a member by id |
| \`create\` | Create a new member |
| \`update\` | Update an existing member |
| \`delete\` | Delete a member |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`role\` | String |

**Create fields:** \`role\`

## app Commands

### \`app:car\`

CRUD operations for Car records.

| Subcommand | Description |
|------------|-------------|
| \`list\` | List all car records |
| \`get\` | Get a car by id |
| \`create\` | Create a new car |
| \`update\` | Update an existing car |
| \`delete\` | Delete a car |

**Fields:**

| Field | Type |
|-------|------|
| \`id\` | UUID |
| \`make\` | String |
| \`model\` | String |
| \`year\` | Int |
| \`isElectric\` | Boolean |
| \`createdAt\` | Datetime |

**Create fields:** \`make\`, \`model\`, \`year\`, \`isElectric\`

## Output

All commands output JSON to stdout. Pipe to \`jq\` for formatting:

\`\`\`bash
myapp auth:user list | jq '.[]'
myapp auth:user get --id <uuid> | jq '.'
\`\`\`

---

Built by the [Constructive](https://constructive.io) team.

## Disclaimer

AS DESCRIBED IN THE LICENSES, THE SOFTWARE IS PROVIDED "AS IS", AT YOUR OWN RISK, AND WITHOUT WARRANTIES OF ANY KIND.

No developer or entity involved in creating this software will be liable for any claims or damages whatsoever associated with your use, inability to use, or your interaction with other users of the code, including any direct, indirect, incidental, special, exemplary, punitive or consequential damages, or loss of profits, cryptocurrencies, tokens, or anything else of value.
"
`;

exports[`multi-target cli docs generates multi-target skills 1`] = `
[
  {
    "content": "# myapp-context

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Manage API endpoint contexts for myapp (multi-target: auth, members, app)

## Usage

\`\`\`bash
myapp context create <name>
myapp context list
myapp context use <name>
myapp context current
myapp context delete <name>
\`\`\`

## Examples

### Create a context for local development (accept all defaults)

\`\`\`bash
myapp context create local
myapp context use local
\`\`\`

### Create a production context with custom endpoints

\`\`\`bash
myapp context create production --auth-endpoint <url> --members-endpoint <url> --app-endpoint <url>
myapp context use production
\`\`\`

### List and switch contexts

\`\`\`bash
myapp context list
myapp context use staging
\`\`\`
",
    "fileName": "skills/context.md",
  },
  {
    "content": "# myapp-credentials

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Manage authentication tokens for myapp (shared across all targets)

## Usage

\`\`\`bash
myapp credentials set-token <token>
myapp credentials status
myapp credentials logout
\`\`\`

## Examples

### Authenticate with a token

\`\`\`bash
myapp credentials set-token eyJhbGciOiJIUzI1NiIs...
\`\`\`

### Check auth status

\`\`\`bash
myapp credentials status
\`\`\`
",
    "fileName": "skills/credentials.md",
  },
  {
    "content": "# myapp-auth:user

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

CRUD operations for User records via myapp CLI (auth target)

## Usage

\`\`\`bash
myapp auth:user list
myapp auth:user get --id <value>
myapp auth:user create --email <value> --name <value>
myapp auth:user update --id <value> [--email <value>] [--name <value>]
myapp auth:user delete --id <value>
\`\`\`

## Examples

### List all user records

\`\`\`bash
myapp auth:user list
\`\`\`

### Create a user

\`\`\`bash
myapp auth:user create --email "value" --name "value"
\`\`\`

### Get a user by id

\`\`\`bash
myapp auth:user get --id <value>
\`\`\`
",
    "fileName": "skills/auth-user.md",
  },
  {
    "content": "# myapp-auth:current-user

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Get the currently authenticated user (auth target)

## Usage

\`\`\`bash
myapp auth:current-user
\`\`\`

## Examples

### Run currentUser

\`\`\`bash
myapp auth:current-user
\`\`\`
",
    "fileName": "skills/auth-current-user.md",
  },
  {
    "content": "# myapp-auth:login

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Authenticate a user (auth target)

## Usage

\`\`\`bash
myapp auth:login --email <value> --password <value>
myapp auth:login --email <value> --password <value> --save-token
\`\`\`

## Examples

### Run login

\`\`\`bash
myapp auth:login --email <value> --password <value>
\`\`\`
",
    "fileName": "skills/auth-login.md",
  },
  {
    "content": "# myapp-members:member

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

CRUD operations for Member records via myapp CLI (members target)

## Usage

\`\`\`bash
myapp members:member list
myapp members:member get --id <value>
myapp members:member create --role <value>
myapp members:member update --id <value> [--role <value>]
myapp members:member delete --id <value>
\`\`\`

## Examples

### List all member records

\`\`\`bash
myapp members:member list
\`\`\`

### Create a member

\`\`\`bash
myapp members:member create --role "value"
\`\`\`

### Get a member by id

\`\`\`bash
myapp members:member get --id <value>
\`\`\`
",
    "fileName": "skills/members-member.md",
  },
  {
    "content": "# myapp-app:car

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

CRUD operations for Car records via myapp CLI (app target)

## Usage

\`\`\`bash
myapp app:car list
myapp app:car get --id <value>
myapp app:car create --make <value> --model <value> --year <value> --isElectric <value>
myapp app:car update --id <value> [--make <value>] [--model <value>] [--year <value>] [--isElectric <value>]
myapp app:car delete --id <value>
\`\`\`

## Examples

### List all car records

\`\`\`bash
myapp app:car list
\`\`\`

### Create a car

\`\`\`bash
myapp app:car create --make "value" --model "value" --year "value" --isElectric "value"
\`\`\`

### Get a car by id

\`\`\`bash
myapp app:car get --id <value>
\`\`\`
",
    "fileName": "skills/app-car.md",
  },
]
`;

exports[`multi-target cli generator generates credentials command (renamed from auth) 1`] = `
"/**
 * Authentication commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp credentials <command>\\n\\nCommands:\\n  set-token <token>     Set API token for the current context\\n  status                Show authentication status\\n  logout                Remove credentials for the current context\\n\\nOptions:\\n  --context <name>      Specify context (defaults to current context)\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["set-token", "status", "logout"]
    }]);
    return handleAuthSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleAuthSubcommand(subcommand, newArgv, prompter, store);
};
async function handleAuthSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "set-token":
      return handleSetToken(argv, prompter, store);
    case "status":
      return handleStatus(store);
    case "logout":
      return handleLogout(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleSetToken(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.error("No active context. Run \\"context create\\" first.");
    process.exit(1);
  }
  const {
    first: token
  } = extractFirst(argv);
  let tokenValue = token;
  if (!tokenValue) {
    const answer = await prompter.prompt(argv, [{
      type: "password",
      name: "token",
      message: "API Token",
      required: true
    }]);
    tokenValue = answer.token;
  }
  store.setCredentials(current.name, {
    token: String(tokenValue || "").trim()
  });
  console.log(\`Token saved for context: \${current.name}\`);
}
function handleStatus(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Authentication Status:");
  for (const ctx of contexts) {
    const isCurrent = ctx.name === settings.currentContext;
    const hasAuth = store.hasValidCredentials(ctx.name);
    const marker = isCurrent ? "* " : "  ";
    const status = hasAuth ? "authenticated" : "no token";
    console.log(\`\${marker}\${ctx.name} [\${status}]\`);
  }
}
async function handleLogout(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No active context.");
    return;
  }
  const confirm = await prompter.prompt(argv, [{
    type: "confirm",
    name: "confirm",
    message: \`Remove credentials for "\${current.name}"?\`,
    default: false
  }]);
  if (!confirm.confirm) {
    return;
  }
  if (store.removeCredentials(current.name)) {
    console.log(\`Credentials removed for: \${current.name}\`);
  } else {
    console.log(\`No credentials found for: \${current.name}\`);
  }
}"
`;

exports[`multi-target cli generator generates multi-target command map 1`] = `
"/**
 * Multi-target CLI command map and entry point
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import contextCmd from "./commands/context";
import credentialsCmd from "./commands/credentials";
import authUserCmd from "./commands/auth/user";
import authCurrentUserCmd from "./commands/auth/current-user";
import authLoginCmd from "./commands/auth/login";
import membersMemberCmd from "./commands/members/member";
import appCarCmd from "./commands/app/car";
const createCommandMap = () => ({
  "context": contextCmd,
  "credentials": credentialsCmd,
  "auth:user": authUserCmd,
  "auth:current-user": authCurrentUserCmd,
  "auth:login": authLoginCmd,
  "members:member": membersMemberCmd,
  "app:car": appCarCmd
});
const usage = "\\nmyapp <command>\\n\\nCommands:\\n  context              Manage API contexts\\n  credentials          Manage authentication\\n\\n  auth:\\n    auth:user              user CRUD operations\\n    auth:current-user      Get the currently authenticated user\\n    auth:login             Authenticate a user\\n\\n  members:\\n    members:member         member CRUD operations\\n\\n  app:\\n    app:car                car CRUD operations\\n\\n  --help, -h            Show this help message\\n  --version, -v         Show version\\n";
export const commands = async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  let {
    first: command,
    newArgv
  } = extractFirst(argv);
  const commandMap = createCommandMap();
  if (!command) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "command",
      message: "What do you want to do?",
      options: Object.keys(commandMap)
    }]);
    command = answer.command;
  }
  const commandFn = commandMap[command];
  if (!commandFn) {
    console.log(usage);
    console.error(\`Unknown command: \${command}\`);
    process.exit(1);
  }
  await commandFn(newArgv, prompter, options);
  prompter.close();
  return argv;
};"
`;

exports[`multi-target cli generator generates multi-target context command 1`] = `
"/**
 * Multi-target context management commands
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getStore } from "../executor";
const usage = "\\nmyapp context <command>\\n\\nCommands:\\n  create <name>         Create a new context\\n  list                  List all contexts\\n  use <name>            Set the active context\\n  current               Show current context\\n  delete <name>         Delete a context\\n\\nCreate Options:\\n  --auth-endpoint <url>  auth endpoint (default: http://auth.localhost/graphql)\\n  --members-endpoint <url>  members endpoint (default: http://members.localhost/graphql)\\n  --app-endpoint <url>  app endpoint (default: http://app.localhost/graphql)\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const store = getStore();
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["create", "list", "use", "current", "delete"]
    }]);
    return handleSubcommand(answer.subcommand, newArgv, prompter, store);
  }
  return handleSubcommand(subcommand, newArgv, prompter, store);
};
async function handleSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  switch (subcommand) {
    case "create":
      return handleCreate(argv, prompter, store);
    case "list":
      return handleList(store);
    case "use":
      return handleUse(argv, prompter, store);
    case "current":
      return handleCurrent(store);
    case "delete":
      return handleDelete(argv, prompter, store);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name,
    newArgv: restArgv
  } = extractFirst(argv);
  const answers = await prompter.prompt({
    name,
    ...restArgv
  }, [{
    type: "text",
    name: "name",
    message: "Context name",
    required: true
  }, {
    type: "text",
    name: "authEndpoint",
    message: "auth endpoint",
    default: "http://auth.localhost/graphql"
  }, {
    type: "text",
    name: "membersEndpoint",
    message: "members endpoint",
    default: "http://members.localhost/graphql"
  }, {
    type: "text",
    name: "appEndpoint",
    message: "app endpoint",
    default: "http://app.localhost/graphql"
  }]);
  const contextName = answers.name;
  const targets = {
    "auth": {
      endpoint: answers.authEndpoint
    },
    "members": {
      endpoint: answers.membersEndpoint
    },
    "app": {
      endpoint: answers.appEndpoint
    }
  };
  store.createContext(contextName, {
    endpoint: answers.authEndpoint,
    targets: targets
  });
  const settings = store.loadSettings();
  if (!settings.currentContext) {
    store.setCurrentContext(contextName);
  }
  console.log(\`Created context: \${contextName}\`);
  console.log(\`  auth: \${answers.authEndpoint}\`);
  console.log(\`  members: \${answers.membersEndpoint}\`);
  console.log(\`  app: \${answers.appEndpoint}\`);
}
function handleList(store: ReturnType<typeof getStore>) {
  const contexts = store.listContexts();
  const settings = store.loadSettings();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  console.log("Contexts:");
  for (const ctx of contexts) {
    const marker = ctx.name === settings.currentContext ? "* " : "  ";
    const authStatus = store.hasValidCredentials(ctx.name) ? "[authenticated]" : "[no token]";
    console.log(\`\${marker}\${ctx.name} \${authStatus}\`);
    console.log(\`    Endpoint: \${ctx.endpoint}\`);
  }
}
async function handleUse(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.setCurrentContext(contextName)) {
    console.log(\`Switched to context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}
function handleCurrent(store: ReturnType<typeof getStore>) {
  const current = store.getCurrentContext();
  if (!current) {
    console.log("No current context set.");
    return;
  }
  console.log(\`Current context: \${current.name}\`);
  console.log(\`  Endpoint: \${current.endpoint}\`);
  const hasAuth = store.hasValidCredentials(current.name);
  console.log(\`  Auth: \${hasAuth ? "authenticated" : "not authenticated"}\`);
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer, store: ReturnType<typeof getStore>) {
  const {
    first: name
  } = extractFirst(argv);
  const contexts = store.listContexts();
  if (contexts.length === 0) {
    console.log("No contexts configured.");
    return;
  }
  let contextName = name;
  if (!contextName) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "name",
      message: "Select context to delete",
      options: contexts.map(c => c.name)
    }]);
    contextName = answer.name;
  }
  if (store.deleteContext(contextName)) {
    console.log(\`Deleted context: \${contextName}\`);
  } else {
    console.error(\`Context "\${contextName}" not found.\`);
    process.exit(1);
  }
}"
`;

exports[`multi-target cli generator generates multi-target executor 1`] = `
"/**
 * Multi-target executor and config store for CLI
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { createConfigStore } from "appstash";
import { createClient as createAuthClient } from "../../generated/auth/orm";
import { createClient as createMembersClient } from "../../generated/members/orm";
import { createClient as createAppClient } from "../../generated/app/orm";
const store = createConfigStore("myapp");
export const getStore = () => store;
const targetClients = {
  "auth": createAuthClient,
  "members": createMembersClient,
  "app": createAppClient
};
const defaultEndpoints = {
  "auth": "http://auth.localhost/graphql",
  "members": "http://members.localhost/graphql",
  "app": "http://app.localhost/graphql"
};
export const getTargetNames = () => Object.keys(targetClients);
export const getDefaultEndpoint = (targetName: string) => defaultEndpoints[targetName] || "";
export function getClient(targetName: string, contextName?: string) {
  const createFn = targetClients[targetName];
  if (!createFn) {
    throw new Error(\`Unknown target: \${targetName}\`);
  }
  const headers = {};
  let endpoint = "";
  const ctx = contextName ? store.loadContext(contextName) : store.getCurrentContext();
  if (ctx) {
    const resolved = store.getTargetEndpoint(targetName, ctx.name);
    endpoint = resolved || defaultEndpoints[targetName] || "";
    if (store.hasValidCredentials(ctx.name)) {
      const creds = store.getCredentials(ctx.name);
      if (creds?.token) {
        headers.Authorization = \`Bearer \${creds.token}\`;
      }
    }
  } else {
    endpoint = defaultEndpoints[targetName] || "";
  }
  return createFn({
    endpoint: endpoint,
    headers: headers
  });
}"
`;

exports[`multi-target cli generator generates target-prefixed custom commands with save-token 1`] = `
"/**
 * CLI command for mutation login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer } from "inquirerer";
import { getClient, getStore } from "../../executor";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  try {
    if (argv.help || argv.h) {
      console.log("login - Authenticate a user\\n\\nUsage: login [OPTIONS]\\n");
      process.exit(0);
    }
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "email",
      message: "email",
      required: true
    }, {
      type: "text",
      name: "password",
      message: "password",
      required: true
    }]);
    const client = getClient("auth");
    const result = await client.mutation.login(answers).execute();
    if (argv.saveToken && result) {
      const tokenValue = result.token || result.jwtToken || result.accessToken;
      if (tokenValue) {
        const s = getStore();
        const ctx = s.getCurrentContext();
        if (ctx) {
          s.setCredentials(ctx.name, {
            token: tokenValue
          });
          console.log("Token saved to current context.");
        }
      }
    }
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed: login");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
};"
`;

exports[`multi-target cli generator generates target-prefixed table commands 1`] = `
"/**
 * CLI commands for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../../executor";
import { coerceAnswers, stripUndefined } from "../../utils";
const fieldSchema = {
  id: "uuid",
  email: "string",
  name: "string"
};
const usage = "\\nuser <command>\\n\\nCommands:\\n  list                  List all user records\\n  get                   Get a user by ID\\n  create                Create a new user\\n  update                Update an existing user\\n  delete                Delete a user\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient("auth");
    const result = await client.user.findMany({
      select: {
        id: true,
        email: true,
        name: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient("auth");
    const result = await client.user.findOne({
      id: answers.id,
      select: {
        id: true,
        email: true,
        name: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "email",
      message: "email",
      required: true
    }, {
      type: "text",
      name: "name",
      message: "name",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient("auth");
    const result = await client.user.create({
      data: {
        email: cleanedData.email,
        name: cleanedData.name
      },
      select: {
        id: true,
        email: true,
        name: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "email",
      message: "email",
      required: false
    }, {
      type: "text",
      name: "name",
      message: "name",
      required: false
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient("auth");
    const result = await client.user.update({
      where: {
        id: answers.id as string
      },
      data: {
        email: cleanedData.email,
        name: cleanedData.name
      },
      select: {
        id: true,
        email: true,
        name: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const client = getClient("auth");
    const result = await client.user.delete({
      where: {
        id: answers.id as string
      },
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`multi-target cli generator generates target-prefixed table commands 2`] = `
"/**
 * CLI commands for Member
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../../executor";
import { coerceAnswers, stripUndefined } from "../../utils";
const fieldSchema = {
  id: "uuid",
  role: "string"
};
const usage = "\\nmember <command>\\n\\nCommands:\\n  list                  List all member records\\n  get                   Get a member by ID\\n  create                Create a new member\\n  update                Update an existing member\\n  delete                Delete a member\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient("members");
    const result = await client.member.findMany({
      select: {
        id: true,
        role: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient("members");
    const result = await client.member.findOne({
      id: answers.id,
      select: {
        id: true,
        role: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "role",
      message: "role",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient("members");
    const result = await client.member.create({
      data: {
        role: cleanedData.role
      },
      select: {
        id: true,
        role: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "role",
      message: "role",
      required: false
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient("members");
    const result = await client.member.update({
      where: {
        id: answers.id as string
      },
      data: {
        role: cleanedData.role
      },
      select: {
        id: true,
        role: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const client = getClient("members");
    const result = await client.member.delete({
      where: {
        id: answers.id as string
      },
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`multi-target cli generator generates target-prefixed table commands 3`] = `
"/**
 * CLI commands for Car
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { CLIOptions, Inquirerer, extractFirst } from "inquirerer";
import { getClient } from "../../executor";
import { coerceAnswers, stripUndefined } from "../../utils";
const fieldSchema = {
  id: "uuid",
  make: "string",
  model: "string",
  year: "int",
  isElectric: "boolean",
  createdAt: "string"
};
const usage = "\\ncar <command>\\n\\nCommands:\\n  list                  List all car records\\n  get                   Get a car by ID\\n  create                Create a new car\\n  update                Update an existing car\\n  delete                Delete a car\\n\\n  --help, -h            Show this help message\\n";
export default async (argv: Partial<Record<string, unknown>>, prompter: Inquirerer, _options: CLIOptions) => {
  if (argv.help || argv.h) {
    console.log(usage);
    process.exit(0);
  }
  const {
    first: subcommand,
    newArgv
  } = extractFirst(argv);
  if (!subcommand) {
    const answer = await prompter.prompt(argv, [{
      type: "autocomplete",
      name: "subcommand",
      message: "What do you want to do?",
      options: ["list", "get", "create", "update", "delete"]
    }]);
    return handleTableSubcommand(answer.subcommand, newArgv, prompter);
  }
  return handleTableSubcommand(subcommand, newArgv, prompter);
};
async function handleTableSubcommand(subcommand: string, argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  switch (subcommand) {
    case "list":
      return handleList(argv, prompter);
    case "get":
      return handleGet(argv, prompter);
    case "create":
      return handleCreate(argv, prompter);
    case "update":
      return handleUpdate(argv, prompter);
    case "delete":
      return handleDelete(argv, prompter);
    default:
      console.log(usage);
      process.exit(1);
  }
}
async function handleList(_argv: Partial<Record<string, unknown>>, _prompter: Inquirerer) {
  try {
    const client = getClient("app");
    const result = await client.car.findMany({
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to list records.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleGet(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const answers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const client = getClient("app");
    const result = await client.car.findOne({
      id: answers.id,
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Record not found.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleCreate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "make",
      message: "make",
      required: true
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: true
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: true
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient("app");
    const result = await client.car.create({
      data: {
        make: cleanedData.make,
        model: cleanedData.model,
        year: cleanedData.year,
        isElectric: cleanedData.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to create record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleUpdate(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }, {
      type: "text",
      name: "make",
      message: "make",
      required: false
    }, {
      type: "text",
      name: "model",
      message: "model",
      required: false
    }, {
      type: "text",
      name: "year",
      message: "year",
      required: false
    }, {
      type: "text",
      name: "isElectric",
      message: "isElectric",
      required: false
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const cleanedData = stripUndefined(answers, fieldSchema);
    const client = getClient("app");
    const result = await client.car.update({
      where: {
        id: answers.id as string
      },
      data: {
        make: cleanedData.make,
        model: cleanedData.model,
        year: cleanedData.year,
        isElectric: cleanedData.isElectric
      },
      select: {
        id: true,
        make: true,
        model: true,
        year: true,
        isElectric: true,
        createdAt: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to update record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}
async function handleDelete(argv: Partial<Record<string, unknown>>, prompter: Inquirerer) {
  try {
    const rawAnswers = await prompter.prompt(argv, [{
      type: "text",
      name: "id",
      message: "id",
      required: true
    }]);
    const answers = coerceAnswers(rawAnswers, fieldSchema);
    const client = getClient("app");
    const result = await client.car.delete({
      where: {
        id: answers.id as string
      },
      select: {
        id: true
      }
    }).execute();
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error("Failed to delete record.");
    if (error instanceof Error) {
      console.error(error.message);
    }
    process.exit(1);
  }
}"
`;

exports[`orm docs generator generates ORM AGENTS.md 1`] = `
"# ORM Client - Agent Reference

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT
> This document is structured for LLM/agent consumption.

## OVERVIEW

Prisma-like ORM client for interacting with a GraphQL API.
All methods return a query builder. Call \`.execute()\` to run the query.

## SETUP

\`\`\`typescript
import { createClient } from './orm';

const db = createClient({
  endpoint: 'https://api.example.com/graphql',
  headers: { Authorization: 'Bearer <token>' },
});
\`\`\`

## MODELS

### MODEL: car

Access: \`db.car\`

\`\`\`
METHODS:
  db.car.findMany({ select, where?, orderBy?, first?, offset? })
  db.car.findOne({ where: { id }, select })
  db.car.create({ data: { make, model, year, isElectric }, select })
  db.car.update({ where: { id }, data, select })
  db.car.delete({ where: { id } })

FIELDS:
  id: string (primary key)
  make: string
  model: string
  year: number
  isElectric: boolean
  createdAt: string

EDITABLE FIELDS:
  make: string
  model: string
  year: number
  isElectric: boolean

OUTPUT: Promise<JSON>
  findMany: [{ id, make, model, year, isElectric, createdAt }]
  findOne:  { id, make, model, year, isElectric, createdAt }
  create:   { id, make, model, year, isElectric, createdAt }
  update:   { id, make, model, year, isElectric, createdAt }
  delete:   { id }
\`\`\`

### MODEL: driver

Access: \`db.driver\`

\`\`\`
METHODS:
  db.driver.findMany({ select, where?, orderBy?, first?, offset? })
  db.driver.findOne({ where: { id }, select })
  db.driver.create({ data: { name, licenseNumber }, select })
  db.driver.update({ where: { id }, data, select })
  db.driver.delete({ where: { id } })

FIELDS:
  id: string (primary key)
  name: string
  licenseNumber: string

EDITABLE FIELDS:
  name: string
  licenseNumber: string

OUTPUT: Promise<JSON>
  findMany: [{ id, name, licenseNumber }]
  findOne:  { id, name, licenseNumber }
  create:   { id, name, licenseNumber }
  update:   { id, name, licenseNumber }
  delete:   { id }
\`\`\`

## CUSTOM OPERATIONS

### OPERATION: currentUser

Get the currently authenticated user

\`\`\`
TYPE: query
ACCESS: db.query.currentUser
USAGE: db.query.currentUser().execute()

INPUT: none

OUTPUT: Promise<JSON>
\`\`\`

### OPERATION: login

Authenticate a user

\`\`\`
TYPE: mutation
ACCESS: db.mutation.login
USAGE: db.mutation.login({ email: <value>, password: <value> }).execute()

INPUT:
  email: String (required)
  password: String (required)

OUTPUT: Promise<JSON>
\`\`\`

## PATTERNS

\`\`\`typescript
// All methods require .execute() to run
const result = await db.modelName.findMany({ select: { id: true } }).execute();

// Select specific fields
const partial = await db.modelName.findMany({ select: { id: true, name: true } }).execute();

// Filter with where clause
const filtered = await db.modelName.findMany({ select: { id: true }, where: { name: 'test' } }).execute();
\`\`\`
"
`;

exports[`orm docs generator generates ORM README 1`] = `
"# ORM Client

<p align="center" width="100%">
  <img height="120" src="https://raw.githubusercontent.com/constructive-io/constructive/refs/heads/main/assets/outline-logo.svg" />
</p>

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## Setup

\`\`\`typescript
import { createClient } from './orm';

const db = createClient({
  endpoint: 'https://api.example.com/graphql',
  headers: { Authorization: 'Bearer <token>' },
});
\`\`\`

## Models

| Model | Operations |
|-------|------------|
| \`car\` | findMany, findOne, create, update, delete |
| \`driver\` | findMany, findOne, create, update, delete |

## Table Operations

### \`db.car\`

CRUD operations for Car records.

**Fields:**

| Field | Type | Editable |
|-------|------|----------|
| \`id\` | UUID | No |
| \`make\` | String | Yes |
| \`model\` | String | Yes |
| \`year\` | Int | Yes |
| \`isElectric\` | Boolean | Yes |
| \`createdAt\` | Datetime | No |

**Operations:**

\`\`\`typescript
// List all car records
const items = await db.car.findMany({ select: { id: true, make: true, model: true, year: true, isElectric: true, createdAt: true } }).execute();

// Get one by id
const item = await db.car.findOne({ where: { id: '<value>' }, select: { id: true, make: true, model: true, year: true, isElectric: true, createdAt: true } }).execute();

// Create
const created = await db.car.create({ data: { make: '<value>', model: '<value>', year: '<value>', isElectric: '<value>' }, select: { id: true } }).execute();

// Update
const updated = await db.car.update({ where: { id: '<value>' }, data: { make: '<new-value>' }, select: { id: true } }).execute();

// Delete
const deleted = await db.car.delete({ where: { id: '<value>' } }).execute();
\`\`\`

### \`db.driver\`

CRUD operations for Driver records.

**Fields:**

| Field | Type | Editable |
|-------|------|----------|
| \`id\` | UUID | No |
| \`name\` | String | Yes |
| \`licenseNumber\` | String | Yes |

**Operations:**

\`\`\`typescript
// List all driver records
const items = await db.driver.findMany({ select: { id: true, name: true, licenseNumber: true } }).execute();

// Get one by id
const item = await db.driver.findOne({ where: { id: '<value>' }, select: { id: true, name: true, licenseNumber: true } }).execute();

// Create
const created = await db.driver.create({ data: { name: '<value>', licenseNumber: '<value>' }, select: { id: true } }).execute();

// Update
const updated = await db.driver.update({ where: { id: '<value>' }, data: { name: '<new-value>' }, select: { id: true } }).execute();

// Delete
const deleted = await db.driver.delete({ where: { id: '<value>' } }).execute();
\`\`\`

## Custom Operations

### \`db.query.currentUser\`

Get the currently authenticated user

- **Type:** query
- **Arguments:** none

\`\`\`typescript
const result = await db.query.currentUser().execute();
\`\`\`

### \`db.mutation.login\`

Authenticate a user

- **Type:** mutation
- **Arguments:**

  | Argument | Type |
  |----------|------|
  | \`email\` | String (required) |
  | \`password\` | String (required) |

\`\`\`typescript
const result = await db.mutation.login({ email: '<value>', password: '<value>' }).execute();
\`\`\`

---

Built by the [Constructive](https://constructive.io) team.

## Disclaimer

AS DESCRIBED IN THE LICENSES, THE SOFTWARE IS PROVIDED "AS IS", AT YOUR OWN RISK, AND WITHOUT WARRANTIES OF ANY KIND.

No developer or entity involved in creating this software will be liable for any claims or damages whatsoever associated with your use, inability to use, or your interaction with other users of the code, including any direct, indirect, incidental, special, exemplary, punitive or consequential damages, or loss of profits, cryptocurrencies, tokens, or anything else of value.
"
`;

exports[`orm docs generator generates ORM skill files 1`] = `
"# orm-car

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

ORM operations for Car records

## Usage

\`\`\`typescript
db.car.findMany({ select: { id: true } }).execute()
db.car.findOne({ where: { id: '<value>' }, select: { id: true } }).execute()
db.car.create({ data: { make: '<value>', model: '<value>', year: '<value>', isElectric: '<value>' }, select: { id: true } }).execute()
db.car.update({ where: { id: '<value>' }, data: { make: '<new>' }, select: { id: true } }).execute()
db.car.delete({ where: { id: '<value>' } }).execute()
\`\`\`

## Examples

### List all car records

\`\`\`typescript
const items = await db.car.findMany({
  select: { id: true, make: true }
}).execute();
\`\`\`

### Create a car

\`\`\`typescript
const item = await db.car.create({
  data: { make: 'value', model: 'value', year: 'value', isElectric: 'value' },
  select: { id: true }
}).execute();
\`\`\`
"
`;

exports[`orm docs generator generates ORM skill files 2`] = `
"# orm-driver

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

ORM operations for Driver records

## Usage

\`\`\`typescript
db.driver.findMany({ select: { id: true } }).execute()
db.driver.findOne({ where: { id: '<value>' }, select: { id: true } }).execute()
db.driver.create({ data: { name: '<value>', licenseNumber: '<value>' }, select: { id: true } }).execute()
db.driver.update({ where: { id: '<value>' }, data: { name: '<new>' }, select: { id: true } }).execute()
db.driver.delete({ where: { id: '<value>' } }).execute()
\`\`\`

## Examples

### List all driver records

\`\`\`typescript
const items = await db.driver.findMany({
  select: { id: true, name: true }
}).execute();
\`\`\`

### Create a driver

\`\`\`typescript
const item = await db.driver.create({
  data: { name: 'value', licenseNumber: 'value' },
  select: { id: true }
}).execute();
\`\`\`
"
`;

exports[`orm docs generator generates ORM skill files 3`] = `
"# orm-currentUser

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Get the currently authenticated user

## Usage

\`\`\`typescript
db.query.currentUser().execute()
\`\`\`

## Examples

### Run currentUser

\`\`\`typescript
const result = await db.query.currentUser().execute();
\`\`\`
"
`;

exports[`orm docs generator generates ORM skill files 4`] = `
"# orm-login

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

Authenticate a user

## Usage

\`\`\`typescript
db.mutation.login({ email: '<value>', password: '<value>' }).execute()
\`\`\`

## Examples

### Run login

\`\`\`typescript
const result = await db.mutation.login({ email: '<value>', password: '<value>' }).execute();
\`\`\`
"
`;

exports[`target docs generator generates combined MCP config 1`] = `
"{
  "name": "myapp",
  "version": "1.0.0",
  "description": "MCP tool definitions for myapp SDK (auto-generated from GraphQL schema)",
  "tools": [
    {
      "name": "myapp_context_create",
      "description": "Create a named API context pointing at a GraphQL endpoint",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Context name"
          },
          "endpoint": {
            "type": "string",
            "description": "GraphQL endpoint URL"
          }
        },
        "required": [
          "name",
          "endpoint"
        ]
      }
    },
    {
      "name": "myapp_context_list",
      "description": "List all configured API contexts",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_context_use",
      "description": "Set the active API context",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Context name to activate"
          }
        },
        "required": [
          "name"
        ]
      }
    },
    {
      "name": "myapp_context_current",
      "description": "Show the currently active API context",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_context_delete",
      "description": "Delete an API context",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Context name to delete"
          }
        },
        "required": [
          "name"
        ]
      }
    },
    {
      "name": "myapp_auth_set_token",
      "description": "Store a bearer token for the current context",
      "inputSchema": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Bearer token value"
          }
        },
        "required": [
          "token"
        ]
      }
    },
    {
      "name": "myapp_auth_status",
      "description": "Show authentication status for all contexts",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_auth_logout",
      "description": "Remove credentials for the current context",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_car_list",
      "description": "List all Car records",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_car_get",
      "description": "Get a single Car record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_car_create",
      "description": "Create a new Car record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "make": {
            "type": "string",
            "description": "Car make"
          },
          "model": {
            "type": "string",
            "description": "Car model"
          },
          "year": {
            "type": "integer",
            "description": "Car year"
          },
          "isElectric": {
            "type": "boolean",
            "description": "Car isElectric"
          }
        },
        "required": [
          "make",
          "model",
          "year",
          "isElectric"
        ]
      }
    },
    {
      "name": "myapp_car_update",
      "description": "Update an existing Car record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          },
          "make": {
            "type": "string",
            "description": "Car make"
          },
          "model": {
            "type": "string",
            "description": "Car model"
          },
          "year": {
            "type": "integer",
            "description": "Car year"
          },
          "isElectric": {
            "type": "boolean",
            "description": "Car isElectric"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_car_delete",
      "description": "Delete a Car record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_car_fields",
      "description": "List available fields for Car",
      "inputSchema": {
        "type": "object",
        "properties": {}
      },
      "_meta": {
        "fields": [
          {
            "name": "id",
            "type": "UUID",
            "editable": false,
            "primaryKey": true
          },
          {
            "name": "make",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "model",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "year",
            "type": "Int",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "isElectric",
            "type": "Boolean",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "createdAt",
            "type": "Datetime",
            "editable": false,
            "primaryKey": false
          }
        ]
      }
    },
    {
      "name": "myapp_driver_list",
      "description": "List all Driver records",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_driver_get",
      "description": "Get a single Driver record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_driver_create",
      "description": "Create a new Driver record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Driver name"
          },
          "licenseNumber": {
            "type": "string",
            "description": "Driver licenseNumber"
          }
        },
        "required": [
          "name",
          "licenseNumber"
        ]
      }
    },
    {
      "name": "myapp_driver_update",
      "description": "Update an existing Driver record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          },
          "name": {
            "type": "string",
            "description": "Driver name"
          },
          "licenseNumber": {
            "type": "string",
            "description": "Driver licenseNumber"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_driver_delete",
      "description": "Delete a Driver record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "myapp_driver_fields",
      "description": "List available fields for Driver",
      "inputSchema": {
        "type": "object",
        "properties": {}
      },
      "_meta": {
        "fields": [
          {
            "name": "id",
            "type": "UUID",
            "editable": false,
            "primaryKey": true
          },
          {
            "name": "name",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "licenseNumber",
            "type": "String",
            "editable": true,
            "primaryKey": false
          }
        ]
      }
    },
    {
      "name": "myapp_current-user",
      "description": "Get the currently authenticated user",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "myapp_login",
      "description": "Authenticate a user",
      "inputSchema": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "email"
          },
          "password": {
            "type": "string",
            "description": "password"
          }
        },
        "required": [
          "email",
          "password"
        ]
      }
    },
    {
      "name": "orm_car_findMany",
      "description": "List all Car records via ORM",
      "inputSchema": {
        "type": "object",
        "properties": {
          "first": {
            "type": "integer",
            "description": "Limit number of results"
          },
          "offset": {
            "type": "integer",
            "description": "Offset for pagination"
          }
        }
      }
    },
    {
      "name": "orm_car_findOne",
      "description": "Get a single Car record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "orm_car_create",
      "description": "Create a new Car record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "make": {
            "type": "string",
            "description": "Car make"
          },
          "model": {
            "type": "string",
            "description": "Car model"
          },
          "year": {
            "type": "integer",
            "description": "Car year"
          },
          "isElectric": {
            "type": "boolean",
            "description": "Car isElectric"
          }
        },
        "required": [
          "make",
          "model",
          "year",
          "isElectric"
        ]
      }
    },
    {
      "name": "orm_car_update",
      "description": "Update an existing Car record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          },
          "make": {
            "type": "string",
            "description": "Car make"
          },
          "model": {
            "type": "string",
            "description": "Car model"
          },
          "year": {
            "type": "integer",
            "description": "Car year"
          },
          "isElectric": {
            "type": "boolean",
            "description": "Car isElectric"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "orm_car_delete",
      "description": "Delete a Car record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Car id"
          }
        },
        "required": [
          "id"
        ]
      },
      "_meta": {
        "fields": [
          {
            "name": "id",
            "type": "UUID",
            "editable": false,
            "primaryKey": true
          },
          {
            "name": "make",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "model",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "year",
            "type": "Int",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "isElectric",
            "type": "Boolean",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "createdAt",
            "type": "Datetime",
            "editable": false,
            "primaryKey": false
          }
        ]
      }
    },
    {
      "name": "orm_driver_findMany",
      "description": "List all Driver records via ORM",
      "inputSchema": {
        "type": "object",
        "properties": {
          "first": {
            "type": "integer",
            "description": "Limit number of results"
          },
          "offset": {
            "type": "integer",
            "description": "Offset for pagination"
          }
        }
      }
    },
    {
      "name": "orm_driver_findOne",
      "description": "Get a single Driver record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "orm_driver_create",
      "description": "Create a new Driver record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Driver name"
          },
          "licenseNumber": {
            "type": "string",
            "description": "Driver licenseNumber"
          }
        },
        "required": [
          "name",
          "licenseNumber"
        ]
      }
    },
    {
      "name": "orm_driver_update",
      "description": "Update an existing Driver record",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          },
          "name": {
            "type": "string",
            "description": "Driver name"
          },
          "licenseNumber": {
            "type": "string",
            "description": "Driver licenseNumber"
          }
        },
        "required": [
          "id"
        ]
      }
    },
    {
      "name": "orm_driver_delete",
      "description": "Delete a Driver record by id",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Driver id"
          }
        },
        "required": [
          "id"
        ]
      },
      "_meta": {
        "fields": [
          {
            "name": "id",
            "type": "UUID",
            "editable": false,
            "primaryKey": true
          },
          {
            "name": "name",
            "type": "String",
            "editable": true,
            "primaryKey": false
          },
          {
            "name": "licenseNumber",
            "type": "String",
            "editable": true,
            "primaryKey": false
          }
        ]
      }
    },
    {
      "name": "orm_query_currentUser",
      "description": "Get the currently authenticated user",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "orm_mutation_login",
      "description": "Authenticate a user",
      "inputSchema": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "email"
          },
          "password": {
            "type": "string",
            "description": "password"
          }
        },
        "required": [
          "email",
          "password"
        ]
      }
    }
  ]
}
"
`;

exports[`target docs generator generates per-target README 1`] = `
"# Generated GraphQL SDK

<p align="center" width="100%">
  <img height="120" src="https://raw.githubusercontent.com/constructive-io/constructive/refs/heads/main/assets/outline-logo.svg" />
</p>

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## Overview

- **Tables:** 2
- **Custom queries:** 1
- **Custom mutations:** 1

**Generators:** ORM, React Query, CLI

## Modules

### ORM Client (\`./orm\`)

Prisma-like ORM client for programmatic GraphQL access.

\`\`\`typescript
import { createClient } from './orm';

const db = createClient({
  endpoint: 'https://api.example.com/graphql',
});
\`\`\`

See [orm/README.md](./orm/README.md) for full API reference.

### React Query Hooks (\`./hooks\`)

Type-safe React Query hooks for data fetching and mutations.

\`\`\`typescript
import { configure } from './hooks';
import { useCarsQuery } from './hooks';

configure({ endpoint: 'https://api.example.com/graphql' });
\`\`\`

See [hooks/README.md](./hooks/README.md) for full hook reference.

### CLI Commands (\`./cli\`)

inquirerer-based CLI commands for \`myapp\`.

See [cli/README.md](./cli/README.md) for command reference.

---

Built by the [Constructive](https://constructive.io) team.

## Disclaimer

AS DESCRIBED IN THE LICENSES, THE SOFTWARE IS PROVIDED "AS IS", AT YOUR OWN RISK, AND WITHOUT WARRANTIES OF ANY KIND.

No developer or entity involved in creating this software will be liable for any claims or damages whatsoever associated with your use, inability to use, or your interaction with other users of the code, including any direct, indirect, incidental, special, exemplary, punitive or consequential damages, or loss of profits, cryptocurrencies, tokens, or anything else of value.
"
`;

exports[`target docs generator generates root-root README for multi-target 1`] = `
"# GraphQL SDK

<p align="center" width="100%">
  <img height="120" src="https://raw.githubusercontent.com/constructive-io/constructive/refs/heads/main/assets/outline-logo.svg" />
</p>

> @generated by @constructive-io/graphql-codegen - DO NOT EDIT

## APIs

| API | Endpoint | Generators | Docs |
|-----|----------|------------|------|
| auth | http://auth.localhost/graphql | ORM | [./generated/auth/README.md](./generated/auth/README.md) |
| app | http://app.localhost/graphql | ORM, React Query, CLI | [./generated/app/README.md](./generated/app/README.md) |

---

Built by the [Constructive](https://constructive.io) team.

## Disclaimer

AS DESCRIBED IN THE LICENSES, THE SOFTWARE IS PROVIDED "AS IS", AT YOUR OWN RISK, AND WITHOUT WARRANTIES OF ANY KIND.

No developer or entity involved in creating this software will be liable for any claims or damages whatsoever associated with your use, inability to use, or your interaction with other users of the code, including any direct, indirect, incidental, special, exemplary, punitive or consequential damages, or loss of profits, cryptocurrencies, tokens, or anything else of value.
"
`;
