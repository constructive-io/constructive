// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`client-generator generateCreateClientFile generates createClient factory with models 1`] = `
"/**
 * ORM Client - createClient factory
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { OrmClient } from "./client";
import type { OrmClientConfig } from "./client";
import { UserModel } from "./models/user";
import { PostModel } from "./models/post";
export type { OrmClientConfig, QueryResult, GraphQLError, GraphQLAdapter } from "./client";
export { GraphQLRequestError } from "./client";
export { QueryBuilder } from "./query-builder";
export * from "./select-types";
export * from "./models";
/**
 * Create an ORM client instance
 *
 * @example
 * \`\`\`typescript
 * const db = createClient({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer token' },
 * });
 *
 * // Query users
 * const users = await db.user.findMany({
 *   select: { id: true, name: true },
 *   first: 10,
 * }).execute();
 *
 * // Create a user
 * const newUser = await db.user.create({
 *   data: { name: 'John', email: 'john@example.com' },
 *   select: { id: true },
 * }).execute();
 * \`\`\`
 */
export function createClient(config: OrmClientConfig) {
  const client = new OrmClient(config);
  return {
    user: new UserModel(client),
    post: new PostModel(client)
  };
}"
`;

exports[`client-generator generateCreateClientFile includes custom query/mutation operations when available 1`] = `
"/**
 * ORM Client - createClient factory
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { OrmClient } from "./client";
import type { OrmClientConfig } from "./client";
import { UserModel } from "./models/user";
import { createQueryOperations } from "./query";
import { createMutationOperations } from "./mutation";
export type { OrmClientConfig, QueryResult, GraphQLError, GraphQLAdapter } from "./client";
export { GraphQLRequestError } from "./client";
export { QueryBuilder } from "./query-builder";
export * from "./select-types";
export * from "./models";
export { createQueryOperations } from "./query";
export { createMutationOperations } from "./mutation";
/**
 * Create an ORM client instance
 *
 * @example
 * \`\`\`typescript
 * const db = createClient({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer token' },
 * });
 *
 * // Query users
 * const users = await db.user.findMany({
 *   select: { id: true, name: true },
 *   first: 10,
 * }).execute();
 *
 * // Create a user
 * const newUser = await db.user.create({
 *   data: { name: 'John', email: 'john@example.com' },
 *   select: { id: true },
 * }).execute();
 * \`\`\`
 */
export function createClient(config: OrmClientConfig) {
  const client = new OrmClient(config);
  return {
    user: new UserModel(client),
    query: createQueryOperations(client),
    mutation: createMutationOperations(client)
  };
}"
`;

exports[`client-generator generateOrmClientFile generates OrmClient class with execute method 1`] = `
"/**
 * ORM Client - Runtime GraphQL executor
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import type {
  GraphQLAdapter,
  GraphQLError,
  QueryResult,
} from '@constructive-io/graphql-types';

export type {
  GraphQLAdapter,
  GraphQLError,
  QueryResult,
} from '@constructive-io/graphql-types';

/**
 * Default adapter that uses fetch for HTTP requests.
 * This is used when no custom adapter is provided.
 */
export class FetchAdapter implements GraphQLAdapter {
  private headers: Record<string, string>;

  constructor(
    private endpoint: string,
    headers?: Record<string, string>,
  ) {
    this.headers = headers ?? {};
  }

  async execute<T>(
    document: string,
    variables?: Record<string, unknown>,
  ): Promise<QueryResult<T>> {
    const response = await fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
        ...this.headers,
      },
      body: JSON.stringify({
        query: document,
        variables: variables ?? {},
      }),
    });

    if (!response.ok) {
      return {
        ok: false,
        data: null,
        errors: [
          { message: \`HTTP \${response.status}: \${response.statusText}\` },
        ],
      };
    }

    const json = (await response.json()) as {
      data?: T;
      errors?: GraphQLError[];
    };

    if (json.errors && json.errors.length > 0) {
      return {
        ok: false,
        data: null,
        errors: json.errors,
      };
    }

    return {
      ok: true,
      data: json.data as T,
      errors: undefined,
    };
  }

  setHeaders(headers: Record<string, string>): void {
    this.headers = { ...this.headers, ...headers };
  }

  getEndpoint(): string {
    return this.endpoint;
  }
}

/**
 * Configuration for creating an ORM client.
 * Either provide endpoint (and optional headers) for HTTP requests,
 * or provide a custom adapter for alternative execution strategies.
 */
export interface OrmClientConfig {
  /** GraphQL endpoint URL (required if adapter not provided) */
  endpoint?: string;
  /** Default headers for HTTP requests (only used with endpoint) */
  headers?: Record<string, string>;
  /** Custom adapter for GraphQL execution (overrides endpoint/headers) */
  adapter?: GraphQLAdapter;
}

/**
 * Error thrown when GraphQL request fails
 */
export class GraphQLRequestError extends Error {
  constructor(
    public readonly errors: GraphQLError[],
    public readonly data: unknown = null,
  ) {
    const messages = errors.map((e) => e.message).join('; ');
    super(\`GraphQL Error: \${messages}\`);
    this.name = 'GraphQLRequestError';
  }
}

export class OrmClient {
  private adapter: GraphQLAdapter;

  constructor(config: OrmClientConfig) {
    if (config.adapter) {
      this.adapter = config.adapter;
    } else if (config.endpoint) {
      this.adapter = new FetchAdapter(config.endpoint, config.headers);
    } else {
      throw new Error(
        'OrmClientConfig requires either an endpoint or a custom adapter',
      );
    }
  }

  async execute<T>(
    document: string,
    variables?: Record<string, unknown>,
  ): Promise<QueryResult<T>> {
    return this.adapter.execute<T>(document, variables);
  }

  /**
   * Set headers for requests.
   * Only works if the adapter supports headers.
   */
  setHeaders(headers: Record<string, string>): void {
    if (this.adapter.setHeaders) {
      this.adapter.setHeaders(headers);
    }
  }

  /**
   * Get the endpoint URL.
   * Returns empty string if the adapter doesn't have an endpoint.
   */
  getEndpoint(): string {
    return this.adapter.getEndpoint?.() ?? '';
  }
}
"
`;

exports[`client-generator generateSelectTypesFile generates select type utilities 1`] = `
"/**
 * Type utilities for select inference
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export interface ConnectionResult<T> {
  nodes: T[];
  totalCount: number;
  pageInfo: PageInfo;
}

export interface PageInfo {
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor?: string | null;
  endCursor?: string | null;
}

export interface FindManyArgs<TSelect, TWhere, TOrderBy> {
  select?: TSelect;
  where?: TWhere;
  orderBy?: TOrderBy[];
  first?: number;
  last?: number;
  after?: string;
  before?: string;
  offset?: number;
}

export interface FindFirstArgs<TSelect, TWhere> {
  select?: TSelect;
  where?: TWhere;
}

export interface CreateArgs<TSelect, TData> {
  data: TData;
  select?: TSelect;
}

export interface UpdateArgs<TSelect, TWhere, TData> {
  where: TWhere;
  data: TData;
  select?: TSelect;
}

export type FindOneArgs<
  TSelect,
  TIdName extends string = 'id',
  TId = string,
> = {
  select?: TSelect;
} & Record<TIdName, TId>;

export interface DeleteArgs<TWhere, TSelect = undefined> {
  where: TWhere;
  select?: TSelect;
}

type DepthLevel = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
type DecrementDepth = {
  0: 0;
  1: 0;
  2: 1;
  3: 2;
  4: 3;
  5: 4;
  6: 5;
  7: 6;
  8: 7;
  9: 8;
  10: 9;
};

/**
 * Recursively validates select objects, rejecting unknown keys.
 *
 * NOTE: Depth is intentionally capped to avoid circular-instantiation issues
 * in very large cyclic schemas.
 */
export type DeepExact<
  T,
  Shape,
  Depth extends DepthLevel = 10,
> = Depth extends 0
  ? T extends Shape
    ? T
    : never
  : T extends Shape
    ? Exclude<keyof T, keyof Shape> extends never
      ? {
          [K in keyof T]: K extends keyof Shape
            ? T[K] extends { select: infer NS }
              ? Extract<Shape[K], { select?: unknown }> extends {
                  select?: infer ShapeNS;
                }
                ? DeepExact<
                    Omit<T[K], 'select'> & {
                      select: DeepExact<
                        NS,
                        NonNullable<ShapeNS>,
                        DecrementDepth[Depth]
                      >;
                    },
                    Extract<Shape[K], { select?: unknown }>,
                    DecrementDepth[Depth]
                  >
                : never
              : T[K]
            : never;
        }
      : never
    : never;

/**
 * Enforces exact select shape while keeping contextual typing on \`S extends XxxSelect\`.
 * Use this as an intersection in overloads:
 * \`{ select: S } & StrictSelect<S, XxxSelect>\`.
 */
export type StrictSelect<S, Shape> = S extends DeepExact<S, Shape> ? {} : never;

/**
 * Hook-optimized strict select variant.
 *
 * Uses a shallower recursion depth to keep editor autocomplete responsive
 * in large schemas while still validating common nested-select mistakes.
 */
export type HookStrictSelect<S, Shape> = S extends DeepExact<S, Shape, 5>
  ? {}
  : never;

/**
 * Infer result type from select configuration
 */
export type InferSelectResult<TEntity, TSelect> = TSelect extends undefined
  ? TEntity
  : {
      [K in keyof TSelect as TSelect[K] extends false | undefined
        ? never
        : K]: TSelect[K] extends true
        ? K extends keyof TEntity
          ? TEntity[K]
          : never
        : TSelect[K] extends { select: infer NestedSelect }
          ? K extends keyof TEntity
            ? NonNullable<TEntity[K]> extends ConnectionResult<infer NodeType>
              ? ConnectionResult<InferSelectResult<NodeType, NestedSelect>>
              :
                  | InferSelectResult<NonNullable<TEntity[K]>, NestedSelect>
                  | (null extends TEntity[K] ? null : never)
            : never
          : K extends keyof TEntity
            ? TEntity[K]
            : never;
    };
"
`;
