// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`Barrel File Generators generateCustomMutationsBarrel generates custom mutations barrel 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";
export * from "./useLoginMutation";
export * from "./useLogoutMutation";
export * from "./useRegisterMutation";"
`;

exports[`Barrel File Generators generateCustomQueriesBarrel generates custom queries barrel 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";
export * from "./useCurrentUserQuery";
export * from "./useSearchUsersQuery";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel with all options enabled 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User, Post
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({ first: 10 });
 *   const { mutate } = useCreateCarMutation();
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./types";
export * from "./schema-types";
export * from "./query-keys";
export * from "./mutation-keys";
export * from "./invalidation";
export * from "./queries";
export * from "./mutations";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel without custom operations 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({ first: 10 });
 *   const { mutate } = useCreateCarMutation();
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./types";
export * from "./queries";
export * from "./mutations";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel without mutations 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User, Post
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({ first: 10 });
 *   const { mutate } = useCreateCarMutation();
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./types";
export * from "./schema-types";
export * from "./queries";"
`;

exports[`Barrel File Generators generateMutationsBarrel generates mutations barrel for multiple tables 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";
export * from "./useCreatePostMutation";
export * from "./useUpdatePostMutation";
export * from "./useDeletePostMutation";"
`;

exports[`Barrel File Generators generateMutationsBarrel generates mutations barrel for single table 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";"
`;

exports[`Barrel File Generators generateQueriesBarrel generates queries barrel for multiple tables 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";
export * from "./usePostsQuery";
export * from "./usePostQuery";"
`;

exports[`Barrel File Generators generateQueriesBarrel generates queries barrel for single table 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook with arguments 1`] = `
"/**
 * Custom mutation hook for login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { LoginPayload } from "../schema-types";
import { customMutationKeys } from "../mutation-keys";
/** GraphQL mutation document */
export const loginMutationDocument = \`
mutation LoginMutation($email: String!, $password: String!) {
  login(email: $email, password: $password) {
    token
  }
}
\`;
export interface LoginMutationVariables {
  email: string;
  password: string;
}
export interface LoginMutationResult {
  login: LoginPayload;
}
export function useLoginMutation(options?: Omit<UseMutationOptions<LoginMutationResult, Error, LoginMutationVariables>, 'mutationFn'>) {
  return useMutation({
    mutationKey: customMutationKeys.login(),
    mutationFn: (variables: LoginMutationVariables) => execute<LoginMutationResult, LoginMutationVariables>(loginMutationDocument, variables),
    ...options
  });
}"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook with input object argument 1`] = `
"/**
 * Custom mutation hook for register
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { RegisterInput, RegisterPayload } from "../schema-types";
import { customMutationKeys } from "../mutation-keys";
/** GraphQL mutation document */
export const registerMutationDocument = \`
mutation RegisterMutation($input: RegisterInput!) {
  register(input: $input) {
    token
  }
}
\`;
export interface RegisterMutationVariables {
  input: RegisterInput;
}
export interface RegisterMutationResult {
  register: RegisterPayload;
}
export function useRegisterMutation(options?: Omit<UseMutationOptions<RegisterMutationResult, Error, RegisterMutationVariables>, 'mutationFn'>) {
  return useMutation({
    mutationKey: customMutationKeys.register(),
    mutationFn: (variables: RegisterMutationVariables) => execute<RegisterMutationResult, RegisterMutationVariables>(registerMutationDocument, variables),
    ...options
  });
}"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook without arguments 1`] = `
"/**
 * Custom mutation hook for logout
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { LogoutPayload } from "../schema-types";
import { customMutationKeys } from "../mutation-keys";
/** GraphQL mutation document */
export const logoutMutationDocument = \`
mutation LogoutMutation {
  logout {
    success
  }
}
\`;
export interface LogoutMutationResult {
  logout: LogoutPayload;
}
export function useLogoutMutation(options?: Omit<UseMutationOptions<LogoutMutationResult, Error, void>, 'mutationFn'>) {
  return useMutation({
    mutationKey: customMutationKeys.logout(),
    mutationFn: () => execute<LogoutMutationResult>(logoutMutationDocument),
    ...options
  });
}"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook without centralized keys 1`] = `
"/**
 * Custom mutation hook for login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { LoginPayload } from "../schema-types";
/** GraphQL mutation document */
export const loginMutationDocument = \`
mutation LoginMutation($email: String!, $password: String!) {
  login(email: $email, password: $password) {
    token
  }
}
\`;
export interface LoginMutationVariables {
  email: string;
  password: string;
}
export interface LoginMutationResult {
  login: LoginPayload;
}
export function useLoginMutation(options?: Omit<UseMutationOptions<LoginMutationResult, Error, LoginMutationVariables>, 'mutationFn'>) {
  return useMutation({
    mutationFn: (variables: LoginMutationVariables) => execute<LoginMutationResult, LoginMutationVariables>(loginMutationDocument, variables),
    ...options
  });
}"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook with arguments 1`] = `
"/**
 * Custom query hook for searchUsers
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { User } from "../schema-types";
import { customQueryKeys } from "../query-keys";
/** GraphQL query document */
export const searchUsersQueryDocument = \`
query SearchUsersQuery($query: String!, $limit: Int) {
  searchUsers(query: $query, limit: $limit)
}
\`;
export interface SearchUsersQueryVariables {
  query: string;
  limit?: number;
}
export interface SearchUsersQueryResult {
  searchUsers: User[];
}
/** Query key factory - re-exported from query-keys.ts */
export const searchUsersQueryKey = customQueryKeys.searchUsers;
/**
 * Search users by name or email
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useSearchUsersQuery({ query, limit });
 * 
 * if (data?.searchUsers) {
 *   console.log(data.searchUsers);
 * }
 * \`\`\`
 */
export function useSearchUsersQuery(variables: SearchUsersQueryVariables, options?: Omit<UseQueryOptions<SearchUsersQueryResult, Error>, 'queryKey' | 'queryFn'>) {
  return useQuery({
    queryKey: searchUsersQueryKey(variables),
    queryFn: () => execute<SearchUsersQueryResult, SearchUsersQueryVariables>(searchUsersQueryDocument, variables),
    enabled: !!variables && options?.enabled !== false,
    ...options
  });
}
/**
 * Fetch searchUsers without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchSearchUsersQuery({ query, limit });
 * \`\`\`
 */
export async function fetchSearchUsersQuery(variables: SearchUsersQueryVariables, options?: ExecuteOptions): Promise<SearchUsersQueryResult> {
  return execute<SearchUsersQueryResult, SearchUsersQueryVariables>(searchUsersQueryDocument, variables, options);
}
/**
 * Prefetch searchUsers for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchSearchUsersQuery(queryClient, { query, limit });
 * \`\`\`
 */
export async function prefetchSearchUsersQuery(queryClient: QueryClient, variables: SearchUsersQueryVariables, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: searchUsersQueryKey(variables),
    queryFn: () => execute<SearchUsersQueryResult, SearchUsersQueryVariables>(searchUsersQueryDocument, variables, options)
  });
}"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook without arguments 1`] = `
"/**
 * Custom query hook for currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { User } from "../schema-types";
import { customQueryKeys } from "../query-keys";
/** GraphQL query document */
export const currentUserQueryDocument = \`
query CurrentUserQuery {
  currentUser
}
\`;
export interface CurrentUserQueryResult {
  currentUser: User;
}
/** Query key factory - re-exported from query-keys.ts */
export const currentUserQueryKey = customQueryKeys.currentUser;
/**
 * Get the current authenticated user
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useCurrentUserQuery();
 * 
 * if (data?.currentUser) {
 *   console.log(data.currentUser);
 * }
 * \`\`\`
 */
export function useCurrentUserQuery(options?: Omit<UseQueryOptions<CurrentUserQueryResult, Error>, 'queryKey' | 'queryFn'>) {
  return useQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => execute<CurrentUserQueryResult>(currentUserQueryDocument),
    ...options
  });
}
/**
 * Fetch currentUser without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchCurrentUserQuery();
 * \`\`\`
 */
export async function fetchCurrentUserQuery(options?: ExecuteOptions): Promise<CurrentUserQueryResult> {
  return execute<CurrentUserQueryResult>(currentUserQueryDocument, undefined, options);
}
/**
 * Prefetch currentUser for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchCurrentUserQuery(queryClient);
 * \`\`\`
 */
export async function prefetchCurrentUserQuery(queryClient: QueryClient, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => execute<CurrentUserQueryResult>(currentUserQueryDocument, undefined, options)
  });
}"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook without centralized keys 1`] = `
"/**
 * Custom query hook for currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { User } from "../schema-types";
/** GraphQL query document */
export const currentUserQueryDocument = \`
query CurrentUserQuery {
  currentUser
}
\`;
export interface CurrentUserQueryResult {
  currentUser: User;
}
/** Query key factory for caching */
export const currentUserQueryKey = () => ["currentUser"] as const;
/**
 * Get the current authenticated user
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useCurrentUserQuery();
 * 
 * if (data?.currentUser) {
 *   console.log(data.currentUser);
 * }
 * \`\`\`
 */
export function useCurrentUserQuery(options?: Omit<UseQueryOptions<CurrentUserQueryResult, Error>, 'queryKey' | 'queryFn'>) {
  return useQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => execute<CurrentUserQueryResult>(currentUserQueryDocument),
    ...options
  });
}
/**
 * Fetch currentUser without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchCurrentUserQuery();
 * \`\`\`
 */
export async function fetchCurrentUserQuery(options?: ExecuteOptions): Promise<CurrentUserQueryResult> {
  return execute<CurrentUserQueryResult>(currentUserQueryDocument, undefined, options);
}
/**
 * Prefetch currentUser for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchCurrentUserQuery(queryClient);
 * \`\`\`
 */
export async function prefetchCurrentUserQuery(queryClient: QueryClient, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => execute<CurrentUserQueryResult>(currentUserQueryDocument, undefined, options)
  });
}"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook for simple table 1`] = `
"/**
 * Create mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { User } from "../types";
import { userKeys } from "../query-keys";
import { userMutationKeys } from "../mutation-keys";
export type { User } from "../types";
export const createUserMutationDocument = \`
mutation CreateUserMutation($input: CreateUserInput!) {
  createUser(input: $input) {
    user {
      id
      email
      name
      createdAt
    }
  }
}
\`;
/** Input type for creating a User */
interface UserCreateInput {
  email?: string | null;
  name?: string | null;
}
export interface CreateUserMutationVariables {
  input: {
    user: UserCreateInput;
  };
}
export interface CreateUserMutationResult {
  createUser: {
    user: User;
  };
}
/**
 * Mutation hook for creating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreateUserMutation();
 * 
 * mutate({
 *   input: {
 *     user: {
 *       // ... fields
 *     },
 *   },
 * });
 * \`\`\`
 */
export function useCreateUserMutation(options?: Omit<UseMutationOptions<CreateUserMutationResult, Error, CreateUserMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.create(),
    mutationFn: (variables: CreateUserMutationVariables) => execute<CreateUserMutationResult, CreateUserMutationVariables>(createUserMutationDocument, variables),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: userKeys.lists()
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook for table with relationships 1`] = `
"/**
 * Create mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { Post } from "../types";
import { postKeys } from "../query-keys";
import type { PostScope } from "../query-keys";
import { postMutationKeys } from "../mutation-keys";
export type { Post } from "../types";
export const createPostMutationDocument = \`
mutation CreatePostMutation($input: CreatePostInput!) {
  createPost(input: $input) {
    post {
      id
      title
      content
      authorId
      published
      createdAt
    }
  }
}
\`;
/** Input type for creating a Post */
interface PostCreateInput {
  title?: string | null;
  content?: string | null;
  authorId?: string | null;
  published?: boolean | null;
}
export interface CreatePostMutationVariables {
  input: {
    post: PostCreateInput;
  };
}
export interface CreatePostMutationResult {
  createPost: {
    post: Post;
  };
}
/**
 * Mutation hook for creating a Post
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreatePostMutation();
 * 
 * mutate({
 *   input: {
 *     post: {
 *       // ... fields
 *     },
 *   },
 * });
 * \`\`\`
 */
export function useCreatePostMutation(options?: Omit<UseMutationOptions<CreatePostMutationResult, Error, CreatePostMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.create(),
    mutationFn: (variables: CreatePostMutationVariables) => execute<CreatePostMutationResult, CreatePostMutationVariables>(createPostMutationDocument, variables),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: postKeys.lists()
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook without centralized keys 1`] = `
"/**
 * Create mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { User } from "../types";
export type { User } from "../types";
export const createUserMutationDocument = \`
mutation CreateUserMutation($input: CreateUserInput!) {
  createUser(input: $input) {
    user {
      id
      email
      name
      createdAt
    }
  }
}
\`;
/** Input type for creating a User */
interface UserCreateInput {
  email?: string | null;
  name?: string | null;
}
export interface CreateUserMutationVariables {
  input: {
    user: UserCreateInput;
  };
}
export interface CreateUserMutationResult {
  createUser: {
    user: User;
  };
}
/**
 * Mutation hook for creating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreateUserMutation();
 * 
 * mutate({
 *   input: {
 *     user: {
 *       // ... fields
 *     },
 *   },
 * });
 * \`\`\`
 */
export function useCreateUserMutation(options?: Omit<UseMutationOptions<CreateUserMutationResult, Error, CreateUserMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (variables: CreateUserMutationVariables) => execute<CreateUserMutationResult, CreateUserMutationVariables>(createUserMutationDocument, variables),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: ["user", "list"]
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook for simple table 1`] = `
"/**
 * Delete mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import { userKeys } from "../query-keys";
import { userMutationKeys } from "../mutation-keys";
export const deleteUserMutationDocument = \`
mutation DeleteUserMutation($input: DeleteUserInput!) {
  deleteUser(input: $input) {
    clientMutationId
    deletedId
  }
}
\`;
export interface DeleteUserMutationVariables {
  input: {
    id: string;
  };
}
export interface DeleteUserMutationResult {
  deleteUser: {
    clientMutationId: string | null;
    deletedId: string | null;
  };
}
/**
 * Mutation hook for deleting a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeleteUserMutation();
 * 
 * mutate({
 *   input: {
 *     id: 'value-to-delete',
 *   },
 * });
 * \`\`\`
 */
export function useDeleteUserMutation(options?: Omit<UseMutationOptions<DeleteUserMutationResult, Error, DeleteUserMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.all,
    mutationFn: (variables: DeleteUserMutationVariables) => execute<DeleteUserMutationResult, DeleteUserMutationVariables>(deleteUserMutationDocument, variables),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({
        queryKey: userKeys.detail(variables.input.id)
      });
      queryClient.invalidateQueries({
        queryKey: userKeys.lists()
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook for table with relationships 1`] = `
"/**
 * Delete mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import { postKeys } from "../query-keys";
import type { PostScope } from "../query-keys";
import { postMutationKeys } from "../mutation-keys";
export const deletePostMutationDocument = \`
mutation DeletePostMutation($input: DeletePostInput!) {
  deletePost(input: $input) {
    clientMutationId
    deletedId
  }
}
\`;
export interface DeletePostMutationVariables {
  input: {
    id: string;
  };
}
export interface DeletePostMutationResult {
  deletePost: {
    clientMutationId: string | null;
    deletedId: string | null;
  };
}
/**
 * Mutation hook for deleting a Post
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeletePostMutation();
 * 
 * mutate({
 *   input: {
 *     id: 'value-to-delete',
 *   },
 * });
 * \`\`\`
 */
export function useDeletePostMutation(options?: Omit<UseMutationOptions<DeletePostMutationResult, Error, DeletePostMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.all,
    mutationFn: (variables: DeletePostMutationVariables) => execute<DeletePostMutationResult, DeletePostMutationVariables>(deletePostMutationDocument, variables),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({
        queryKey: postKeys.detail(variables.input.id)
      });
      queryClient.invalidateQueries({
        queryKey: postKeys.lists()
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook without centralized keys 1`] = `
"/**
 * Delete mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
export const deleteUserMutationDocument = \`
mutation DeleteUserMutation($input: DeleteUserInput!) {
  deleteUser(input: $input) {
    clientMutationId
    deletedId
  }
}
\`;
export interface DeleteUserMutationVariables {
  input: {
    id: string;
  };
}
export interface DeleteUserMutationResult {
  deleteUser: {
    clientMutationId: string | null;
    deletedId: string | null;
  };
}
/**
 * Mutation hook for deleting a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeleteUserMutation();
 * 
 * mutate({
 *   input: {
 *     id: 'value-to-delete',
 *   },
 * });
 * \`\`\`
 */
export function useDeleteUserMutation(options?: Omit<UseMutationOptions<DeleteUserMutationResult, Error, DeleteUserMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (variables: DeleteUserMutationVariables) => execute<DeleteUserMutationResult, DeleteUserMutationVariables>(deleteUserMutationDocument, variables),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({
        queryKey: ["user", "detail", variables.input.id]
      });
      queryClient.invalidateQueries({
        queryKey: ["user", "list"]
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook for simple table 1`] = `
"/**
 * Update mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { User } from "../types";
import { userKeys } from "../query-keys";
import { userMutationKeys } from "../mutation-keys";
export type { User } from "../types";
export const updateUserMutationDocument = \`
mutation UpdateUserMutation($input: UpdateUserInput!) {
  updateUser(input: $input) {
    user {
      id
      email
      name
      createdAt
    }
  }
}
\`;
/** Patch type for updating a User - all fields optional */
interface UserPatch {
  email?: string | null;
  name?: string | null;
  createdAt?: string | null;
}
export interface UpdateUserMutationVariables {
  input: {
    id: string;
    patch: UserPatch;
  };
}
export interface UpdateUserMutationResult {
  updateUser: {
    user: User;
  };
}
/**
 * Mutation hook for updating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdateUserMutation();
 * 
 * mutate({
 *   input: {
 *     id: 'value-here',
 *     patch: {
 *       // ... fields to update
 *     },
 *   },
 * });
 * \`\`\`
 */
export function useUpdateUserMutation(options?: Omit<UseMutationOptions<UpdateUserMutationResult, Error, UpdateUserMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.all,
    mutationFn: (variables: UpdateUserMutationVariables) => execute<UpdateUserMutationResult, UpdateUserMutationVariables>(updateUserMutationDocument, variables),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: userKeys.detail(variables.input.id)
      });
      queryClient.invalidateQueries({
        queryKey: userKeys.lists()
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook for table with relationships 1`] = `
"/**
 * Update mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { Post } from "../types";
import { postKeys } from "../query-keys";
import type { PostScope } from "../query-keys";
import { postMutationKeys } from "../mutation-keys";
export type { Post } from "../types";
export const updatePostMutationDocument = \`
mutation UpdatePostMutation($input: UpdatePostInput!) {
  updatePost(input: $input) {
    post {
      id
      title
      content
      authorId
      published
      createdAt
    }
  }
}
\`;
/** Patch type for updating a Post - all fields optional */
interface PostPatch {
  title?: string | null;
  content?: string | null;
  authorId?: string | null;
  published?: boolean | null;
  createdAt?: string | null;
}
export interface UpdatePostMutationVariables {
  input: {
    id: string;
    patch: PostPatch;
  };
}
export interface UpdatePostMutationResult {
  updatePost: {
    post: Post;
  };
}
/**
 * Mutation hook for updating a Post
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdatePostMutation();
 * 
 * mutate({
 *   input: {
 *     id: 'value-here',
 *     patch: {
 *       // ... fields to update
 *     },
 *   },
 * });
 * \`\`\`
 */
export function useUpdatePostMutation(options?: Omit<UseMutationOptions<UpdatePostMutationResult, Error, UpdatePostMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.all,
    mutationFn: (variables: UpdatePostMutationVariables) => execute<UpdatePostMutationResult, UpdatePostMutationVariables>(updatePostMutationDocument, variables),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: postKeys.detail(variables.input.id)
      });
      queryClient.invalidateQueries({
        queryKey: postKeys.lists()
      });
    },
    ...options
  });
}"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook without centralized keys 1`] = `
"/**
 * Update mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions } from "@tanstack/react-query";
import { execute } from "../client";
import type { User } from "../types";
export type { User } from "../types";
export const updateUserMutationDocument = \`
mutation UpdateUserMutation($input: UpdateUserInput!) {
  updateUser(input: $input) {
    user {
      id
      email
      name
      createdAt
    }
  }
}
\`;
/** Patch type for updating a User - all fields optional */
interface UserPatch {
  email?: string | null;
  name?: string | null;
  createdAt?: string | null;
}
export interface UpdateUserMutationVariables {
  input: {
    id: string;
    patch: UserPatch;
  };
}
export interface UpdateUserMutationResult {
  updateUser: {
    user: User;
  };
}
/**
 * Mutation hook for updating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdateUserMutation();
 * 
 * mutate({
 *   input: {
 *     id: 'value-here',
 *     patch: {
 *       // ... fields to update
 *     },
 *   },
 * });
 * \`\`\`
 */
export function useUpdateUserMutation(options?: Omit<UseMutationOptions<UpdateUserMutationResult, Error, UpdateUserMutationVariables>, 'mutationFn'>) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (variables: UpdateUserMutationVariables) => execute<UpdateUserMutationResult, UpdateUserMutationVariables>(updateUserMutationDocument, variables),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: ["user", "detail", variables.input.id]
      });
      queryClient.invalidateQueries({
        queryKey: ["user", "list"]
      });
    },
    ...options
  });
}"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook for simple table 1`] = `
"/**
 * List query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { User, UUIDFilter, StringFilter, DatetimeFilter } from "../types";
import { userKeys } from "../query-keys";
export type { User } from "../types";
export const usersQueryDocument = \`
query UsersQuery($first: Int, $last: Int, $offset: Int, $before: Cursor, $after: Cursor, $filter: UserFilter, $condition: UserCondition, $orderBy: [UsersOrderBy!]) {
  users(
    first: $first
    last: $last
    offset: $offset
    before: $before
    after: $after
    filter: $filter
    condition: $condition
    orderBy: $orderBy
  ) {
    totalCount
    nodes {
      id
      email
      name
      createdAt
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
\`;
interface UserFilter {
  id?: UUIDFilter;
  email?: StringFilter;
  name?: StringFilter;
  createdAt?: DatetimeFilter;
  and?: UserFilter[];
  or?: UserFilter[];
  not?: UserFilter;
}
interface UserCondition {
  id?: string;
  email?: string;
  name?: string;
  createdAt?: string;
}
type UsersOrderBy = "ID_ASC" | "ID_DESC" | "EMAIL_ASC" | "EMAIL_DESC" | "NAME_ASC" | "NAME_DESC" | "CREATED_AT_ASC" | "CREATED_AT_DESC" | "NATURAL" | "PRIMARY_KEY_ASC" | "PRIMARY_KEY_DESC";
export interface UsersQueryVariables {
  first?: number;
  last?: number;
  offset?: number;
  before?: string;
  after?: string;
  filter?: UserFilter;
  condition?: UserCondition;
  orderBy?: UsersOrderBy[];
}
export interface UsersQueryResult {
  users: {
    totalCount: number;
    nodes: User[];
    pageInfo: {
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor: string | null;
      endCursor: string | null;
    };
  };
}
/** Query key factory - re-exported from query-keys.ts */
export const usersQueryKey = userKeys.list;
/**
 * Query hook for fetching User list
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUsersQuery({
 *   first: 10,
 *   filter: { name: { equalTo: "example" } },
 *   orderBy: ['CREATED_AT_DESC'],
 * });
 * \`\`\`
 */
export function useUsersQuery(variables?: UsersQueryVariables, options?: Omit<UseQueryOptions<UsersQueryResult, Error>, 'queryKey' | 'queryFn'>) {
  return useQuery({
    queryKey: userKeys.list(variables),
    queryFn: () => execute<UsersQueryResult, UsersQueryVariables>(usersQueryDocument, variables),
    ...options
  });
}
/**
 * Fetch User list without React hooks
 * 
 * @example
 * \`\`\`ts
 * // Direct fetch
 * const data = await fetchUsersQuery({ first: 10 });
 * 
 * // With QueryClient
 * const data = await queryClient.fetchQuery({
 *   queryKey: usersQueryKey(variables),
 *   queryFn: () => fetchUsersQuery(variables),
 * });
 * \`\`\`
 */
export async function fetchUsersQuery(variables?: UsersQueryVariables, options?: ExecuteOptions): Promise<UsersQueryResult> {
  return execute<UsersQueryResult, UsersQueryVariables>(usersQueryDocument, variables, options);
}
/**
 * Prefetch User list for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUsersQuery(queryClient, { first: 10 });
 * \`\`\`
 */
export async function prefetchUsersQuery(queryClient: QueryClient, variables?: UsersQueryVariables, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: userKeys.list(variables),
    queryFn: () => execute<UsersQueryResult, UsersQueryVariables>(usersQueryDocument, variables, options)
  });
}"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook for table with relationships 1`] = `
"/**
 * List query hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { Post, UUIDFilter, StringFilter, BooleanFilter, DatetimeFilter } from "../types";
import { postKeys } from "../query-keys";
import type { PostScope } from "../query-keys";
export type { Post } from "../types";
export const postsQueryDocument = \`
query PostsQuery($first: Int, $last: Int, $offset: Int, $before: Cursor, $after: Cursor, $filter: PostFilter, $condition: PostCondition, $orderBy: [PostsOrderBy!]) {
  posts(
    first: $first
    last: $last
    offset: $offset
    before: $before
    after: $after
    filter: $filter
    condition: $condition
    orderBy: $orderBy
  ) {
    totalCount
    nodes {
      id
      title
      content
      authorId
      published
      createdAt
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
\`;
interface PostFilter {
  id?: UUIDFilter;
  title?: StringFilter;
  content?: StringFilter;
  authorId?: UUIDFilter;
  published?: BooleanFilter;
  createdAt?: DatetimeFilter;
  and?: PostFilter[];
  or?: PostFilter[];
  not?: PostFilter;
}
interface PostCondition {
  id?: string;
  title?: string;
  content?: string;
  authorId?: string;
  published?: boolean;
  createdAt?: string;
}
type PostsOrderBy = "ID_ASC" | "ID_DESC" | "TITLE_ASC" | "TITLE_DESC" | "CONTENT_ASC" | "CONTENT_DESC" | "AUTHOR_ID_ASC" | "AUTHOR_ID_DESC" | "PUBLISHED_ASC" | "PUBLISHED_DESC" | "CREATED_AT_ASC" | "CREATED_AT_DESC" | "NATURAL" | "PRIMARY_KEY_ASC" | "PRIMARY_KEY_DESC";
export interface PostsQueryVariables {
  first?: number;
  last?: number;
  offset?: number;
  before?: string;
  after?: string;
  filter?: PostFilter;
  condition?: PostCondition;
  orderBy?: PostsOrderBy[];
}
export interface PostsQueryResult {
  posts: {
    totalCount: number;
    nodes: Post[];
    pageInfo: {
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor: string | null;
      endCursor: string | null;
    };
  };
}
/** Query key factory - re-exported from query-keys.ts */
export const postsQueryKey = postKeys.list;
/**
 * Query hook for fetching Post list
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = usePostsQuery({
 *   first: 10,
 *   filter: { name: { equalTo: "example" } },
 *   orderBy: ['CREATED_AT_DESC'],
 * });
 * \`\`\`
 * 
 * @example With scope for hierarchical cache invalidation
 * \`\`\`tsx
 * const { data } = usePostsQuery(
 *   { first: 10 },
 *   { scope: { parentId: 'parent-id' } }
 * );
 * \`\`\`
 */
export function usePostsQuery(variables?: PostsQueryVariables, options?: Omit<UseQueryOptions<PostsQueryResult, Error>, 'queryKey' | 'queryFn'> & { scope?: PostScope }) {
  const {
    scope,
    ...queryOptions
  } = options ?? {};
  return useQuery({
    queryKey: postKeys.list(variables, scope),
    queryFn: () => execute<PostsQueryResult, PostsQueryVariables>(postsQueryDocument, variables),
    ...queryOptions
  });
}
/**
 * Fetch Post list without React hooks
 * 
 * @example
 * \`\`\`ts
 * // Direct fetch
 * const data = await fetchPostsQuery({ first: 10 });
 * 
 * // With QueryClient
 * const data = await queryClient.fetchQuery({
 *   queryKey: postsQueryKey(variables),
 *   queryFn: () => fetchPostsQuery(variables),
 * });
 * \`\`\`
 */
export async function fetchPostsQuery(variables?: PostsQueryVariables, options?: ExecuteOptions): Promise<PostsQueryResult> {
  return execute<PostsQueryResult, PostsQueryVariables>(postsQueryDocument, variables, options);
}
/**
 * Prefetch Post list for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchPostsQuery(queryClient, { first: 10 });
 * \`\`\`
 */
export async function prefetchPostsQuery(queryClient: QueryClient, variables?: PostsQueryVariables, scope?: PostScope, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: postKeys.list(variables, scope),
    queryFn: () => execute<PostsQueryResult, PostsQueryVariables>(postsQueryDocument, variables, options)
  });
}"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook without centralized keys 1`] = `
"/**
 * List query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { User, UUIDFilter, StringFilter, DatetimeFilter } from "../types";
export type { User } from "../types";
export const usersQueryDocument = \`
query UsersQuery($first: Int, $last: Int, $offset: Int, $before: Cursor, $after: Cursor, $filter: UserFilter, $condition: UserCondition, $orderBy: [UsersOrderBy!]) {
  users(
    first: $first
    last: $last
    offset: $offset
    before: $before
    after: $after
    filter: $filter
    condition: $condition
    orderBy: $orderBy
  ) {
    totalCount
    nodes {
      id
      email
      name
      createdAt
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
\`;
interface UserFilter {
  id?: UUIDFilter;
  email?: StringFilter;
  name?: StringFilter;
  createdAt?: DatetimeFilter;
  and?: UserFilter[];
  or?: UserFilter[];
  not?: UserFilter;
}
interface UserCondition {
  id?: string;
  email?: string;
  name?: string;
  createdAt?: string;
}
type UsersOrderBy = "ID_ASC" | "ID_DESC" | "EMAIL_ASC" | "EMAIL_DESC" | "NAME_ASC" | "NAME_DESC" | "CREATED_AT_ASC" | "CREATED_AT_DESC" | "NATURAL" | "PRIMARY_KEY_ASC" | "PRIMARY_KEY_DESC";
export interface UsersQueryVariables {
  first?: number;
  last?: number;
  offset?: number;
  before?: string;
  after?: string;
  filter?: UserFilter;
  condition?: UserCondition;
  orderBy?: UsersOrderBy[];
}
export interface UsersQueryResult {
  users: {
    totalCount: number;
    nodes: User[];
    pageInfo: {
      hasNextPage: boolean;
      hasPreviousPage: boolean;
      startCursor: string | null;
      endCursor: string | null;
    };
  };
}
export const usersQueryKey = (variables?: UsersQueryVariables) => ["user", "list", variables] as const;
/**
 * Query hook for fetching User list
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUsersQuery({
 *   first: 10,
 *   filter: { name: { equalTo: "example" } },
 *   orderBy: ['CREATED_AT_DESC'],
 * });
 * \`\`\`
 */
export function useUsersQuery(variables?: UsersQueryVariables, options?: Omit<UseQueryOptions<UsersQueryResult, Error>, 'queryKey' | 'queryFn'>) {
  return useQuery({
    queryKey: usersQueryKey(variables),
    queryFn: () => execute<UsersQueryResult, UsersQueryVariables>(usersQueryDocument, variables),
    ...options
  });
}
/**
 * Fetch User list without React hooks
 * 
 * @example
 * \`\`\`ts
 * // Direct fetch
 * const data = await fetchUsersQuery({ first: 10 });
 * 
 * // With QueryClient
 * const data = await queryClient.fetchQuery({
 *   queryKey: usersQueryKey(variables),
 *   queryFn: () => fetchUsersQuery(variables),
 * });
 * \`\`\`
 */
export async function fetchUsersQuery(variables?: UsersQueryVariables, options?: ExecuteOptions): Promise<UsersQueryResult> {
  return execute<UsersQueryResult, UsersQueryVariables>(usersQueryDocument, variables, options);
}
/**
 * Prefetch User list for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUsersQuery(queryClient, { first: 10 });
 * \`\`\`
 */
export async function prefetchUsersQuery(queryClient: QueryClient, variables?: UsersQueryVariables, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: usersQueryKey(variables),
    queryFn: () => execute<UsersQueryResult, UsersQueryVariables>(usersQueryDocument, variables, options)
  });
}"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook for simple table 1`] = `
"/**
 * Single item query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { User } from "../types";
import { userKeys } from "../query-keys";
export type { User } from "../types";
export const userQueryDocument = \`
query UserQuery($id: UUID!) {
  user(id: $id) {
    id
    email
    name
    createdAt
  }
}
\`;
export interface UserQueryVariables {
  id: string;
}
export interface UserQueryResult {
  user: User | null;
}
/** Query key factory - re-exported from query-keys.ts */
export const userQueryKey = userKeys.detail;
/**
 * Query hook for fetching a single User
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUserQuery({ id: 'some-id' });
 * \`\`\`
 */
export function useUserQuery(variables: UserQueryVariables, options?: Omit<UseQueryOptions<UserQueryResult, Error>, 'queryKey' | 'queryFn'>) {
  return useQuery({
    queryKey: userKeys.detail(variables.id),
    queryFn: () => execute<UserQueryResult, UserQueryVariables>(userQueryDocument, variables),
    ...options
  });
}
/**
 * Fetch a single User without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchUserQuery({ id: 'some-id' });
 * \`\`\`
 */
export async function fetchUserQuery(variables: UserQueryVariables, options?: ExecuteOptions): Promise<UserQueryResult> {
  return execute<UserQueryResult, UserQueryVariables>(userQueryDocument, variables, options);
}
/**
 * Prefetch a single User for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUserQuery(queryClient, { id: 'some-id' });
 * \`\`\`
 */
export async function prefetchUserQuery(queryClient: QueryClient, variables: UserQueryVariables, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: userKeys.detail(variables.id),
    queryFn: () => execute<UserQueryResult, UserQueryVariables>(userQueryDocument, variables, options)
  });
}"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook for table with relationships 1`] = `
"/**
 * Single item query hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { Post } from "../types";
import { postKeys } from "../query-keys";
import type { PostScope } from "../query-keys";
export type { Post } from "../types";
export const postQueryDocument = \`
query PostQuery($id: UUID!) {
  post(id: $id) {
    id
    title
    content
    authorId
    published
    createdAt
  }
}
\`;
export interface PostQueryVariables {
  id: string;
}
export interface PostQueryResult {
  post: Post | null;
}
/** Query key factory - re-exported from query-keys.ts */
export const postQueryKey = postKeys.detail;
/**
 * Query hook for fetching a single Post
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = usePostQuery({ id: 'some-id' });
 * \`\`\`
 * 
 * @example With scope for hierarchical cache invalidation
 * \`\`\`tsx
 * const { data } = usePostQuery(
 *   { id: 'some-id' },
 *   { scope: { parentId: 'parent-id' } }
 * );
 * \`\`\`
 */
export function usePostQuery(variables: PostQueryVariables, options?: Omit<UseQueryOptions<PostQueryResult, Error>, 'queryKey' | 'queryFn'> & { scope?: PostScope }) {
  const {
    scope,
    ...queryOptions
  } = options ?? {};
  return useQuery({
    queryKey: postKeys.detail(variables.id, scope),
    queryFn: () => execute<PostQueryResult, PostQueryVariables>(postQueryDocument, variables),
    ...queryOptions
  });
}
/**
 * Fetch a single Post without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchPostQuery({ id: 'some-id' });
 * \`\`\`
 */
export async function fetchPostQuery(variables: PostQueryVariables, options?: ExecuteOptions): Promise<PostQueryResult> {
  return execute<PostQueryResult, PostQueryVariables>(postQueryDocument, variables, options);
}
/**
 * Prefetch a single Post for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchPostQuery(queryClient, { id: 'some-id' });
 * \`\`\`
 */
export async function prefetchPostQuery(queryClient: QueryClient, variables: PostQueryVariables, scope?: PostScope, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: postKeys.detail(variables.id, scope),
    queryFn: () => execute<PostQueryResult, PostQueryVariables>(postQueryDocument, variables, options)
  });
}"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook without centralized keys 1`] = `
"/**
 * Single item query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, QueryClient } from "@tanstack/react-query";
import { execute } from "../client";
import type { ExecuteOptions } from "../client";
import type { User } from "../types";
export type { User } from "../types";
export const userQueryDocument = \`
query UserQuery($id: UUID!) {
  user(id: $id) {
    id
    email
    name
    createdAt
  }
}
\`;
export interface UserQueryVariables {
  id: string;
}
export interface UserQueryResult {
  user: User | null;
}
export const userQueryKey = (id: string) => ["user", "detail", id] as const;
/**
 * Query hook for fetching a single User
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUserQuery({ id: 'some-id' });
 * \`\`\`
 */
export function useUserQuery(variables: UserQueryVariables, options?: Omit<UseQueryOptions<UserQueryResult, Error>, 'queryKey' | 'queryFn'>) {
  return useQuery({
    queryKey: userQueryKey(variables.id),
    queryFn: () => execute<UserQueryResult, UserQueryVariables>(userQueryDocument, variables),
    ...options
  });
}
/**
 * Fetch a single User without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchUserQuery({ id: 'some-id' });
 * \`\`\`
 */
export async function fetchUserQuery(variables: UserQueryVariables, options?: ExecuteOptions): Promise<UserQueryResult> {
  return execute<UserQueryResult, UserQueryVariables>(userQueryDocument, variables, options);
}
/**
 * Prefetch a single User for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUserQuery(queryClient, { id: 'some-id' });
 * \`\`\`
 */
export async function prefetchUserQuery(queryClient: QueryClient, variables: UserQueryVariables, options?: ExecuteOptions): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: userQueryKey(variables.id),
    queryFn: () => execute<UserQueryResult, UserQueryVariables>(userQueryDocument, variables, options)
  });
}"
`;

exports[`Schema Types Generator generateSchemaTypesFile generates schema types file with empty table types 1`] = `
"/**
 * GraphQL schema types for custom operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import type { BigFloatFilter, BigIntFilter, BitStringFilter, BooleanFilter, DateFilter, DatetimeFilter, FloatFilter, FullTextFilter, IntFilter, IntListFilter, InternetAddressFilter, JSONFilter, StringFilter, StringListFilter, UUIDFilter, UUIDListFilter } from "./types";
export type UserRole = "ADMIN" | "USER" | "GUEST";
export interface RegisterInput {
  email: string;
  password: string;
  name?: string;
}
export interface LoginPayload {
  token?: string | null;
  user?: User | null;
}
export interface LogoutPayload {
  success?: boolean | null;
}
export interface RegisterPayload {
  token?: string | null;
  user?: User | null;
}"
`;

exports[`Schema Types Generator generateSchemaTypesFile generates schema types file with enums and input objects 1`] = `
"/**
 * GraphQL schema types for custom operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import type { User, BigFloatFilter, BigIntFilter, BitStringFilter, BooleanFilter, DateFilter, DatetimeFilter, FloatFilter, FullTextFilter, IntFilter, IntListFilter, InternetAddressFilter, JSONFilter, StringFilter, StringListFilter, UUIDFilter, UUIDListFilter } from "./types";
export type UserRole = "ADMIN" | "USER" | "GUEST";
export interface RegisterInput {
  email: string;
  password: string;
  name?: string;
}
export interface LoginPayload {
  token?: string | null;
  user?: User | null;
}
export interface LogoutPayload {
  success?: boolean | null;
}
export interface RegisterPayload {
  token?: string | null;
  user?: User | null;
}"
`;
