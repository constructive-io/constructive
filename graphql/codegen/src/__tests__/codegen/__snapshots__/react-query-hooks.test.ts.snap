// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`Barrel File Generators generateCustomMutationsBarrel generates custom mutations barrel 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";
export * from "./useLoginMutation";
export * from "./useLogoutMutation";
export * from "./useRegisterMutation";"
`;

exports[`Barrel File Generators generateCustomQueriesBarrel generates custom queries barrel 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";
export * from "./useCurrentUserQuery";
export * from "./useSearchUsersQuery";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel with all options enabled 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User, Post
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({
 *     selection: { fields: { id: true }, first: 10 },
 *   });
 *   const { mutate } = useCreateCarMutation({
 *     selection: { fields: { id: true } },
 *   });
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./query-keys";
export * from "./mutation-keys";
export * from "./invalidation";
export * from "./queries";
export * from "./mutations";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel without custom operations 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({
 *     selection: { fields: { id: true }, first: 10 },
 *   });
 *   const { mutate } = useCreateCarMutation({
 *     selection: { fields: { id: true } },
 *   });
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./queries";
export * from "./mutations";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel without mutations 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User, Post
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({
 *     selection: { fields: { id: true }, first: 10 },
 *   });
 *   const { mutate } = useCreateCarMutation({
 *     selection: { fields: { id: true } },
 *   });
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./queries";"
`;

exports[`Barrel File Generators generateMutationsBarrel generates mutations barrel for multiple tables 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";
export * from "./useCreatePostMutation";
export * from "./useUpdatePostMutation";
export * from "./useDeletePostMutation";"
`;

exports[`Barrel File Generators generateMutationsBarrel generates mutations barrel for single table 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";"
`;

exports[`Barrel File Generators generateQueriesBarrel generates queries barrel for multiple tables 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";
export * from "./usePostsQuery";
export * from "./usePostQuery";"
`;

exports[`Barrel File Generators generateQueriesBarrel generates queries barrel for single table 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook with arguments 1`] = `
"/**
 * Custom mutation hook for login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { customMutationKeys } from "../mutation-keys";
import type { LoginVariables } from "../../orm/mutation";
import type { LoginPayloadSelect, LoginPayload } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { LoginVariables } from "../../orm/mutation";
export type { LoginPayloadSelect } from "../../orm/input-types";
export function useLoginMutation<S extends LoginPayloadSelect>(params: {
  selection: ({
    fields: S & LoginPayloadSelect;
  } & HookStrictSelect<NoInfer<S>, LoginPayloadSelect>);
} & Omit<UseMutationOptions<{
  login: InferSelectResult<LoginPayload, S> | null;
}, Error, LoginVariables>, "mutationFn">): UseMutationResult<{
  login: InferSelectResult<LoginPayload, S> | null;
}, Error, LoginVariables> {
  const args = buildSelectionArgs<S>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  return useMutation({
    mutationKey: customMutationKeys.login(),
    mutationFn: (variables: LoginVariables) => getClient().mutation.login(variables, {
      select: args.select
    } as {
      select: S;
    } & HookStrictSelect<NoInfer<S>, LoginPayloadSelect>).unwrap(),
    ...mutationOptions
  });
}
"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook with input object argument 1`] = `
"/**
 * Custom mutation hook for register
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { customMutationKeys } from "../mutation-keys";
import type { RegisterVariables } from "../../orm/mutation";
import type { RegisterPayloadSelect, RegisterPayload } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { RegisterVariables } from "../../orm/mutation";
export type { RegisterPayloadSelect } from "../../orm/input-types";
export function useRegisterMutation<S extends RegisterPayloadSelect>(params: {
  selection: ({
    fields: S & RegisterPayloadSelect;
  } & HookStrictSelect<NoInfer<S>, RegisterPayloadSelect>);
} & Omit<UseMutationOptions<{
  register: InferSelectResult<RegisterPayload, S> | null;
}, Error, RegisterVariables>, "mutationFn">): UseMutationResult<{
  register: InferSelectResult<RegisterPayload, S> | null;
}, Error, RegisterVariables> {
  const args = buildSelectionArgs<S>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  return useMutation({
    mutationKey: customMutationKeys.register(),
    mutationFn: (variables: RegisterVariables) => getClient().mutation.register(variables, {
      select: args.select
    } as {
      select: S;
    } & HookStrictSelect<NoInfer<S>, RegisterPayloadSelect>).unwrap(),
    ...mutationOptions
  });
}
"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook without arguments 1`] = `
"/**
 * Custom mutation hook for logout
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { customMutationKeys } from "../mutation-keys";
import type { LogoutPayloadSelect, LogoutPayload } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { LogoutPayloadSelect } from "../../orm/input-types";
export function useLogoutMutation<S extends LogoutPayloadSelect>(params: {
  selection: ({
    fields: S & LogoutPayloadSelect;
  } & HookStrictSelect<NoInfer<S>, LogoutPayloadSelect>);
} & Omit<UseMutationOptions<{
  logout: InferSelectResult<LogoutPayload, S> | null;
}, Error, void>, "mutationFn">): UseMutationResult<{
  logout: InferSelectResult<LogoutPayload, S> | null;
}, Error, void> {
  const args = buildSelectionArgs<S>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  return useMutation({
    mutationKey: customMutationKeys.logout(),
    mutationFn: () => getClient().mutation.logout({
      select: args.select
    } as {
      select: S;
    } & HookStrictSelect<NoInfer<S>, LogoutPayloadSelect>).unwrap(),
    ...mutationOptions
  });
}
"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook without centralized keys 1`] = `
"/**
 * Custom mutation hook for login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import type { LoginVariables } from "../../orm/mutation";
import type { LoginPayloadSelect, LoginPayload } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { LoginVariables } from "../../orm/mutation";
export type { LoginPayloadSelect } from "../../orm/input-types";
export function useLoginMutation<S extends LoginPayloadSelect>(params: {
  selection: ({
    fields: S & LoginPayloadSelect;
  } & HookStrictSelect<NoInfer<S>, LoginPayloadSelect>);
} & Omit<UseMutationOptions<{
  login: InferSelectResult<LoginPayload, S> | null;
}, Error, LoginVariables>, "mutationFn">): UseMutationResult<{
  login: InferSelectResult<LoginPayload, S> | null;
}, Error, LoginVariables> {
  const args = buildSelectionArgs<S>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  return useMutation({
    mutationFn: (variables: LoginVariables) => getClient().mutation.login(variables, {
      select: args.select
    } as {
      select: S;
    } & HookStrictSelect<NoInfer<S>, LoginPayloadSelect>).unwrap(),
    ...mutationOptions
  });
}
"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook with arguments 1`] = `
"/**
 * Custom query hook for searchUsers
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { customQueryKeys } from "../query-keys";
import type { SearchUsersVariables } from "../../orm/query";
import type { UserSelect, User } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { SearchUsersVariables } from "../../orm/query";
export type { UserSelect } from "../../orm/input-types";
/** Query key factory - re-exported from query-keys.ts */
export const searchUsersQueryKey = customQueryKeys.searchUsers;
/**
 * Search users by name or email
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useSearchUsersQuery({ variables: { query, limit }, selection: { fields: { id: true } } });
 * 
 * if (data?.searchUsers) {
 *   console.log(data.searchUsers);
 * }
 * \`\`\`
 */
export function useSearchUsersQuery<S extends UserSelect, TData = {
  searchUsers: (InferSelectResult<User, S> | null)[] | null;
}>(params: {
  variables: SearchUsersVariables;
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseQueryOptions<{
  searchUsers: (InferSelectResult<User, S> | null)[] | null;
}, Error, TData>, "queryKey" | "queryFn">): UseQueryResult<TData>;
export function useSearchUsersQuery(params: {
  variables: SearchUsersVariables;
  selection: SelectionConfig<UserSelect>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn">) {
  const variables = params.variables;
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    variables: _variables,
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _variables;
  void _selection;
  return useQuery({
    queryKey: searchUsersQueryKey(variables),
    queryFn: () => getClient().query.searchUsers(variables!, {
      select: args.select
    }).unwrap(),
    enabled: !!variables && params?.enabled !== false,
    ...queryOptions
  });
}
/**
 * Fetch searchUsers without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchSearchUsersQuery({ variables: { query, limit }, selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function fetchSearchUsersQuery<S extends UserSelect>(params: {
  variables: SearchUsersVariables;
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
}): Promise<{
  searchUsers: (InferSelectResult<User, S> | null)[] | null;
}>;
export async function fetchSearchUsersQuery(params: {
  variables: SearchUsersVariables;
  selection: SelectionConfig<UserSelect>;
}) {
  const variables = params.variables;
  const args = buildSelectionArgs<UserSelect>(params.selection);
  return getClient().query.searchUsers(variables!, {
    select: args.select
  }).unwrap();
}
/**
 * Prefetch searchUsers for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchSearchUsersQuery(queryClient, { variables: { query, limit }, selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function prefetchSearchUsersQuery<S extends UserSelect>(queryClient: QueryClient, params: {
  variables: SearchUsersVariables;
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
}): Promise<void>;
export async function prefetchSearchUsersQuery(queryClient: QueryClient, params: {
  variables: SearchUsersVariables;
  selection: SelectionConfig<UserSelect>;
}): Promise<void> {
  const variables = params.variables;
  const args = buildSelectionArgs<UserSelect>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: searchUsersQueryKey(variables),
    queryFn: () => getClient().query.searchUsers(variables!, {
      select: args.select
    }).unwrap()
  });
}
"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook without arguments 1`] = `
"/**
 * Custom query hook for currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { customQueryKeys } from "../query-keys";
import type { UserSelect, User } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect } from "../../orm/input-types";
/** Query key factory - re-exported from query-keys.ts */
export const currentUserQueryKey = customQueryKeys.currentUser;
/**
 * Get the current authenticated user
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useCurrentUserQuery({ selection: { fields: { id: true } } });
 * 
 * if (data?.currentUser) {
 *   console.log(data.currentUser);
 * }
 * \`\`\`
 */
export function useCurrentUserQuery<S extends UserSelect, TData = {
  currentUser: InferSelectResult<User, S> | null;
}>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseQueryOptions<{
  currentUser: InferSelectResult<User, S> | null;
}, Error, TData>, "queryKey" | "queryFn">): UseQueryResult<TData>;
export function useCurrentUserQuery(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({
      select: args.select
    }).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch currentUser without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchCurrentUserQuery({ selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function fetchCurrentUserQuery<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
}): Promise<{
  currentUser: InferSelectResult<User, S> | null;
}>;
export async function fetchCurrentUserQuery(params: {
  selection: SelectionConfig<UserSelect>;
}) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  return getClient().query.currentUser({
    select: args.select
  }).unwrap();
}
/**
 * Prefetch currentUser for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchCurrentUserQuery(queryClient, { selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function prefetchCurrentUserQuery<S extends UserSelect>(queryClient: QueryClient, params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
}): Promise<void>;
export async function prefetchCurrentUserQuery(queryClient: QueryClient, params: {
  selection: SelectionConfig<UserSelect>;
}): Promise<void> {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({
      select: args.select
    }).unwrap()
  });
}
"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook without centralized keys 1`] = `
"/**
 * Custom query hook for currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import type { UserSelect, User } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect } from "../../orm/input-types";
/** Query key factory for caching */
export const currentUserQueryKey = () => ["currentUser"] as const;
/**
 * Get the current authenticated user
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useCurrentUserQuery({ selection: { fields: { id: true } } });
 * 
 * if (data?.currentUser) {
 *   console.log(data.currentUser);
 * }
 * \`\`\`
 */
export function useCurrentUserQuery<S extends UserSelect, TData = {
  currentUser: InferSelectResult<User, S> | null;
}>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseQueryOptions<{
  currentUser: InferSelectResult<User, S> | null;
}, Error, TData>, "queryKey" | "queryFn">): UseQueryResult<TData>;
export function useCurrentUserQuery(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({
      select: args.select
    }).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch currentUser without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchCurrentUserQuery({ selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function fetchCurrentUserQuery<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
}): Promise<{
  currentUser: InferSelectResult<User, S> | null;
}>;
export async function fetchCurrentUserQuery(params: {
  selection: SelectionConfig<UserSelect>;
}) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  return getClient().query.currentUser({
    select: args.select
  }).unwrap();
}
/**
 * Prefetch currentUser for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchCurrentUserQuery(queryClient, { selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function prefetchCurrentUserQuery<S extends UserSelect>(queryClient: QueryClient, params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
}): Promise<void>;
export async function prefetchCurrentUserQuery(queryClient: QueryClient, params: {
  selection: SelectionConfig<UserSelect>;
}): Promise<void> {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({
      select: args.select
    }).unwrap()
  });
}
"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook for simple table 1`] = `
"/**
 * Create mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { userKeys } from "../query-keys";
import { userMutationKeys } from "../mutation-keys";
import type { UserSelect, UserWithRelations, CreateUserInput } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations, CreateUserInput } from "../../orm/input-types";
/**
 * Mutation hook for creating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreateUserMutation({
 *   selection: { fields: { id: true, name: true } },
 * });
 * 
 * mutate({ name: 'New item' });
 * \`\`\`
 */
export function useCreateUserMutation<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseMutationOptions<{
  createUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, CreateUserInput["user"]>, "mutationFn">): UseMutationResult<{
  createUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, CreateUserInput["user"]>;
export function useCreateUserMutation(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseMutationOptions<any, Error, CreateUserInput["user"]>, "mutationFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.create(),
    mutationFn: (data: CreateUserInput["user"]) => getClient().user.create({
      data,
      select: args.select
    }).unwrap(),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: userKeys.lists()
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook for table with relationships 1`] = `
"/**
 * Create mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { postKeys } from "../query-keys";
import { postMutationKeys } from "../mutation-keys";
import type { PostSelect, PostWithRelations, CreatePostInput } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { PostSelect, PostWithRelations, CreatePostInput } from "../../orm/input-types";
/**
 * Mutation hook for creating a Post
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreatePostMutation({
 *   selection: { fields: { id: true, name: true } },
 * });
 * 
 * mutate({ name: 'New item' });
 * \`\`\`
 */
export function useCreatePostMutation<S extends PostSelect>(params: {
  selection: ({
    fields: S & PostSelect;
  } & HookStrictSelect<NoInfer<S>, PostSelect>);
} & Omit<UseMutationOptions<{
  createPost: {
    post: InferSelectResult<PostWithRelations, S>;
  };
}, Error, CreatePostInput["post"]>, "mutationFn">): UseMutationResult<{
  createPost: {
    post: InferSelectResult<PostWithRelations, S>;
  };
}, Error, CreatePostInput["post"]>;
export function useCreatePostMutation(params: {
  selection: SelectionConfig<PostSelect>;
} & Omit<UseMutationOptions<any, Error, CreatePostInput["post"]>, "mutationFn">) {
  const args = buildSelectionArgs<PostSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.create(),
    mutationFn: (data: CreatePostInput["post"]) => getClient().post.create({
      data,
      select: args.select
    }).unwrap(),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: postKeys.lists()
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook without centralized keys 1`] = `
"/**
 * Create mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import type { UserSelect, UserWithRelations, CreateUserInput } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations, CreateUserInput } from "../../orm/input-types";
/**
 * Mutation hook for creating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreateUserMutation({
 *   selection: { fields: { id: true, name: true } },
 * });
 * 
 * mutate({ name: 'New item' });
 * \`\`\`
 */
export function useCreateUserMutation<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseMutationOptions<{
  createUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, CreateUserInput["user"]>, "mutationFn">): UseMutationResult<{
  createUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, CreateUserInput["user"]>;
export function useCreateUserMutation(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseMutationOptions<any, Error, CreateUserInput["user"]>, "mutationFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreateUserInput["user"]) => getClient().user.create({
      data,
      select: args.select
    }).unwrap(),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: ["user", "list"]
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook for simple table 1`] = `
"/**
 * Delete mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { userKeys } from "../query-keys";
import { userMutationKeys } from "../mutation-keys";
import type { UserSelect, UserWithRelations } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations } from "../../orm/input-types";
/**
 * Mutation hook for deleting a User with typed selection
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeleteUserMutation({
 *   selection: { fields: { id: true } },
 * });
 * 
 * mutate({ id: 'value-to-delete' });
 * \`\`\`
 */
export function useDeleteUserMutation<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseMutationOptions<{
  deleteUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
}>, "mutationFn">): UseMutationResult<{
  deleteUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
}>;
export function useDeleteUserMutation(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseMutationOptions<any, Error, {
  id: string;
}>, "mutationFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.all,
    mutationFn: ({
      id
    }: {
      id: string;
    }) => getClient().user.delete({
      where: {
        id
      },
      select: args.select
    }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({
        queryKey: userKeys.detail(variables.id)
      });
      queryClient.invalidateQueries({
        queryKey: userKeys.lists()
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook for table with relationships 1`] = `
"/**
 * Delete mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { postKeys } from "../query-keys";
import { postMutationKeys } from "../mutation-keys";
import type { PostSelect, PostWithRelations } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { PostSelect, PostWithRelations } from "../../orm/input-types";
/**
 * Mutation hook for deleting a Post with typed selection
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeletePostMutation({
 *   selection: { fields: { id: true } },
 * });
 * 
 * mutate({ id: 'value-to-delete' });
 * \`\`\`
 */
export function useDeletePostMutation<S extends PostSelect>(params: {
  selection: ({
    fields: S & PostSelect;
  } & HookStrictSelect<NoInfer<S>, PostSelect>);
} & Omit<UseMutationOptions<{
  deletePost: {
    post: InferSelectResult<PostWithRelations, S>;
  };
}, Error, {
  id: string;
}>, "mutationFn">): UseMutationResult<{
  deletePost: {
    post: InferSelectResult<PostWithRelations, S>;
  };
}, Error, {
  id: string;
}>;
export function useDeletePostMutation(params: {
  selection: SelectionConfig<PostSelect>;
} & Omit<UseMutationOptions<any, Error, {
  id: string;
}>, "mutationFn">) {
  const args = buildSelectionArgs<PostSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.all,
    mutationFn: ({
      id
    }: {
      id: string;
    }) => getClient().post.delete({
      where: {
        id
      },
      select: args.select
    }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({
        queryKey: postKeys.detail(variables.id)
      });
      queryClient.invalidateQueries({
        queryKey: postKeys.lists()
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook without centralized keys 1`] = `
"/**
 * Delete mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import type { UserSelect, UserWithRelations } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations } from "../../orm/input-types";
/**
 * Mutation hook for deleting a User with typed selection
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeleteUserMutation({
 *   selection: { fields: { id: true } },
 * });
 * 
 * mutate({ id: 'value-to-delete' });
 * \`\`\`
 */
export function useDeleteUserMutation<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseMutationOptions<{
  deleteUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
}>, "mutationFn">): UseMutationResult<{
  deleteUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
}>;
export function useDeleteUserMutation(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseMutationOptions<any, Error, {
  id: string;
}>, "mutationFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      id
    }: {
      id: string;
    }) => getClient().user.delete({
      where: {
        id
      },
      select: args.select
    }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({
        queryKey: ["user", "detail", variables.id]
      });
      queryClient.invalidateQueries({
        queryKey: ["user", "list"]
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook for simple table 1`] = `
"/**
 * Update mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { userKeys } from "../query-keys";
import { userMutationKeys } from "../mutation-keys";
import type { UserSelect, UserWithRelations, UserPatch } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations, UserPatch } from "../../orm/input-types";
/**
 * Mutation hook for updating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdateUserMutation({
 *   selection: { fields: { id: true, name: true } },
 * });
 * 
 * mutate({ id: 'value-here', patch: { name: 'Updated' } });
 * \`\`\`
 */
export function useUpdateUserMutation<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseMutationOptions<{
  updateUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
  patch: UserPatch;
}>, "mutationFn">): UseMutationResult<{
  updateUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
  patch: UserPatch;
}>;
export function useUpdateUserMutation(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseMutationOptions<any, Error, {
  id: string;
  patch: UserPatch;
}>, "mutationFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.all,
    mutationFn: ({
      id,
      patch
    }: {
      id: string;
      patch: UserPatch;
    }) => getClient().user.update({
      where: {
        id
      },
      data: patch,
      select: args.select
    }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: userKeys.detail(variables.id)
      });
      queryClient.invalidateQueries({
        queryKey: userKeys.lists()
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook for table with relationships 1`] = `
"/**
 * Update mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { postKeys } from "../query-keys";
import { postMutationKeys } from "../mutation-keys";
import type { PostSelect, PostWithRelations, PostPatch } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { PostSelect, PostWithRelations, PostPatch } from "../../orm/input-types";
/**
 * Mutation hook for updating a Post
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdatePostMutation({
 *   selection: { fields: { id: true, name: true } },
 * });
 * 
 * mutate({ id: 'value-here', patch: { name: 'Updated' } });
 * \`\`\`
 */
export function useUpdatePostMutation<S extends PostSelect>(params: {
  selection: ({
    fields: S & PostSelect;
  } & HookStrictSelect<NoInfer<S>, PostSelect>);
} & Omit<UseMutationOptions<{
  updatePost: {
    post: InferSelectResult<PostWithRelations, S>;
  };
}, Error, {
  id: string;
  patch: PostPatch;
}>, "mutationFn">): UseMutationResult<{
  updatePost: {
    post: InferSelectResult<PostWithRelations, S>;
  };
}, Error, {
  id: string;
  patch: PostPatch;
}>;
export function useUpdatePostMutation(params: {
  selection: SelectionConfig<PostSelect>;
} & Omit<UseMutationOptions<any, Error, {
  id: string;
  patch: PostPatch;
}>, "mutationFn">) {
  const args = buildSelectionArgs<PostSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.all,
    mutationFn: ({
      id,
      patch
    }: {
      id: string;
      patch: PostPatch;
    }) => getClient().post.update({
      where: {
        id
      },
      data: patch,
      select: args.select
    }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: postKeys.detail(variables.id)
      });
      queryClient.invalidateQueries({
        queryKey: postKeys.lists()
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook without centralized keys 1`] = `
"/**
 * Update mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from "@tanstack/react-query";
import type { UseMutationOptions, UseMutationResult } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import type { UserSelect, UserWithRelations, UserPatch } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations, UserPatch } from "../../orm/input-types";
/**
 * Mutation hook for updating a User
 * 
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdateUserMutation({
 *   selection: { fields: { id: true, name: true } },
 * });
 * 
 * mutate({ id: 'value-here', patch: { name: 'Updated' } });
 * \`\`\`
 */
export function useUpdateUserMutation<S extends UserSelect>(params: {
  selection: ({
    fields: S & UserSelect;
  } & HookStrictSelect<NoInfer<S>, UserSelect>);
} & Omit<UseMutationOptions<{
  updateUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
  patch: UserPatch;
}>, "mutationFn">): UseMutationResult<{
  updateUser: {
    user: InferSelectResult<UserWithRelations, S>;
  };
}, Error, {
  id: string;
  patch: UserPatch;
}>;
export function useUpdateUserMutation(params: {
  selection: SelectionConfig<UserSelect>;
} & Omit<UseMutationOptions<any, Error, {
  id: string;
  patch: UserPatch;
}>, "mutationFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...mutationOptions
  } = params ?? {};
  void _selection;
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      id,
      patch
    }: {
      id: string;
      patch: UserPatch;
    }) => getClient().user.update({
      where: {
        id
      },
      data: patch,
      select: args.select
    }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: ["user", "detail", variables.id]
      });
      queryClient.invalidateQueries({
        queryKey: ["user", "list"]
      });
    },
    ...mutationOptions
  });
}
"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook for simple table 1`] = `
"/**
 * List query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildListSelectionArgs } from "../selection";
import type { ListSelectionConfig } from "../selection";
import { userKeys } from "../query-keys";
import type { UserSelect, UserWithRelations, UserFilter, UsersOrderBy } from "../../orm/input-types";
import type { FindManyArgs, InferSelectResult, ConnectionResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations, UserFilter, UsersOrderBy } from "../../orm/input-types";
/** Query key factory - re-exported from query-keys.ts */
export const usersQueryKey = userKeys.list;
/**
 * Query hook for fetching User list
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUsersQuery({
 *   selection: {
 *     fields: { id: true, name: true },
 *     where: { name: { equalTo: "example" } },
 *     orderBy: ['CREATED_AT_DESC'],
 *     first: 10,
 *   },
 * });
 * \`\`\`
 */
export function useUsersQuery<S extends UserSelect, TData = {
  users: ConnectionResult<InferSelectResult<UserWithRelations, S>>;
}>(params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, UserFilter, UsersOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, UserSelect>;
} & Omit<UseQueryOptions<{
  users: ConnectionResult<InferSelectResult<UserWithRelations, S>>;
}, Error, TData>, "queryKey" | "queryFn">): UseQueryResult<TData>;
export function useUsersQuery(params: {
  selection: ListSelectionConfig<UserSelect, UserFilter, UsersOrderBy>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn">) {
  const args = buildListSelectionArgs<UserSelect, UserFilter, UsersOrderBy>(params.selection);
  const {
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: userKeys.list(args),
    queryFn: () => getClient().user.findMany(args).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch User list without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchUsersQuery({
 *   selection: {
 *     fields: { id: true },
 *     first: 10,
 *   },
 * });
 * \`\`\`
 */
export async function fetchUsersQuery<S extends UserSelect>(params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, UserFilter, UsersOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<{
  users: ConnectionResult<InferSelectResult<UserWithRelations, S>>;
}>;
export async function fetchUsersQuery(params: {
  selection: ListSelectionConfig<UserSelect, UserFilter, UsersOrderBy>;
}) {
  const args = buildListSelectionArgs<UserSelect, UserFilter, UsersOrderBy>(params.selection);
  return getClient().user.findMany(args).unwrap();
}
/**
 * Prefetch User list for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUsersQuery(queryClient, { selection: { fields: { id: true }, first: 10 } });
 * \`\`\`
 */
export async function prefetchUsersQuery<S extends UserSelect>(queryClient: QueryClient, params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, UserFilter, UsersOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<void>;
export async function prefetchUsersQuery(queryClient: QueryClient, params: {
  selection: ListSelectionConfig<UserSelect, UserFilter, UsersOrderBy>;
}): Promise<void> {
  const args = buildListSelectionArgs<UserSelect, UserFilter, UsersOrderBy>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: userKeys.list(args),
    queryFn: () => getClient().user.findMany(args).unwrap()
  });
}
"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook for table with relationships 1`] = `
"/**
 * List query hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildListSelectionArgs } from "../selection";
import type { ListSelectionConfig } from "../selection";
import { postKeys } from "../query-keys";
import type { PostScope } from "../query-keys";
import type { PostSelect, PostWithRelations, PostFilter, PostsOrderBy } from "../../orm/input-types";
import type { FindManyArgs, InferSelectResult, ConnectionResult, HookStrictSelect } from "../../orm/select-types";
export type { PostSelect, PostWithRelations, PostFilter, PostsOrderBy } from "../../orm/input-types";
/** Query key factory - re-exported from query-keys.ts */
export const postsQueryKey = postKeys.list;
/**
 * Query hook for fetching Post list
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = usePostsQuery({
 *   selection: {
 *     fields: { id: true, name: true },
 *     where: { name: { equalTo: "example" } },
 *     orderBy: ['CREATED_AT_DESC'],
 *     first: 10,
 *   },
 * });
 * \`\`\`
 * 
 * @example With scope for hierarchical cache invalidation
 * \`\`\`tsx
 * const { data } = usePostsQuery({
 *   selection: { fields: { id: true }, first: 10 },
 *   scope: { parentId: 'parent-id' },
 * });
 * \`\`\`
 */
export function usePostsQuery<S extends PostSelect, TData = {
  posts: ConnectionResult<InferSelectResult<PostWithRelations, S>>;
}>(params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, PostFilter, PostsOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, PostSelect>;
} & Omit<UseQueryOptions<{
  posts: ConnectionResult<InferSelectResult<PostWithRelations, S>>;
}, Error, TData>, "queryKey" | "queryFn"> & {
  scope?: PostScope;
}): UseQueryResult<TData>;
export function usePostsQuery(params: {
  selection: ListSelectionConfig<PostSelect, PostFilter, PostsOrderBy>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn"> & {
  scope?: PostScope;
}) {
  const args = buildListSelectionArgs<PostSelect, PostFilter, PostsOrderBy>(params.selection);
  const {
    scope,
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: postKeys.list(args, scope),
    queryFn: () => getClient().post.findMany(args).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch Post list without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchPostsQuery({
 *   selection: {
 *     fields: { id: true },
 *     first: 10,
 *   },
 * });
 * \`\`\`
 */
export async function fetchPostsQuery<S extends PostSelect>(params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, PostFilter, PostsOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, PostSelect>;
}): Promise<{
  posts: ConnectionResult<InferSelectResult<PostWithRelations, S>>;
}>;
export async function fetchPostsQuery(params: {
  selection: ListSelectionConfig<PostSelect, PostFilter, PostsOrderBy>;
}) {
  const args = buildListSelectionArgs<PostSelect, PostFilter, PostsOrderBy>(params.selection);
  return getClient().post.findMany(args).unwrap();
}
/**
 * Prefetch Post list for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchPostsQuery(queryClient, { selection: { fields: { id: true }, first: 10 } });
 * \`\`\`
 */
export async function prefetchPostsQuery<S extends PostSelect>(queryClient: QueryClient, params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, PostFilter, PostsOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, PostSelect>;
} & {
  scope?: PostScope;
}): Promise<void>;
export async function prefetchPostsQuery(queryClient: QueryClient, params: {
  selection: ListSelectionConfig<PostSelect, PostFilter, PostsOrderBy>;
} & {
  scope?: PostScope;
}): Promise<void> {
  const args = buildListSelectionArgs<PostSelect, PostFilter, PostsOrderBy>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: postKeys.list(args, params?.scope),
    queryFn: () => getClient().post.findMany(args).unwrap()
  });
}
"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook without centralized keys 1`] = `
"/**
 * List query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildListSelectionArgs } from "../selection";
import type { ListSelectionConfig } from "../selection";
import type { UserSelect, UserWithRelations, UserFilter, UsersOrderBy } from "../../orm/input-types";
import type { FindManyArgs, InferSelectResult, ConnectionResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations, UserFilter, UsersOrderBy } from "../../orm/input-types";
export const usersQueryKey = (variables?: FindManyArgs<unknown, UserFilter, UsersOrderBy>) => ["user", "list", variables] as const;
/**
 * Query hook for fetching User list
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUsersQuery({
 *   selection: {
 *     fields: { id: true, name: true },
 *     where: { name: { equalTo: "example" } },
 *     orderBy: ['CREATED_AT_DESC'],
 *     first: 10,
 *   },
 * });
 * \`\`\`
 */
export function useUsersQuery<S extends UserSelect, TData = {
  users: ConnectionResult<InferSelectResult<UserWithRelations, S>>;
}>(params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, UserFilter, UsersOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, UserSelect>;
} & Omit<UseQueryOptions<{
  users: ConnectionResult<InferSelectResult<UserWithRelations, S>>;
}, Error, TData>, "queryKey" | "queryFn">): UseQueryResult<TData>;
export function useUsersQuery(params: {
  selection: ListSelectionConfig<UserSelect, UserFilter, UsersOrderBy>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn">) {
  const args = buildListSelectionArgs<UserSelect, UserFilter, UsersOrderBy>(params.selection);
  const {
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: usersQueryKey(args),
    queryFn: () => getClient().user.findMany(args).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch User list without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchUsersQuery({
 *   selection: {
 *     fields: { id: true },
 *     first: 10,
 *   },
 * });
 * \`\`\`
 */
export async function fetchUsersQuery<S extends UserSelect>(params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, UserFilter, UsersOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<{
  users: ConnectionResult<InferSelectResult<UserWithRelations, S>>;
}>;
export async function fetchUsersQuery(params: {
  selection: ListSelectionConfig<UserSelect, UserFilter, UsersOrderBy>;
}) {
  const args = buildListSelectionArgs<UserSelect, UserFilter, UsersOrderBy>(params.selection);
  return getClient().user.findMany(args).unwrap();
}
/**
 * Prefetch User list for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUsersQuery(queryClient, { selection: { fields: { id: true }, first: 10 } });
 * \`\`\`
 */
export async function prefetchUsersQuery<S extends UserSelect>(queryClient: QueryClient, params: {
  selection: {
    fields: S;
  } & Omit<ListSelectionConfig<S, UserFilter, UsersOrderBy>, "fields"> & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<void>;
export async function prefetchUsersQuery(queryClient: QueryClient, params: {
  selection: ListSelectionConfig<UserSelect, UserFilter, UsersOrderBy>;
}): Promise<void> {
  const args = buildListSelectionArgs<UserSelect, UserFilter, UsersOrderBy>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: usersQueryKey(args),
    queryFn: () => getClient().user.findMany(args).unwrap()
  });
}
"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook for simple table 1`] = `
"/**
 * Single item query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { userKeys } from "../query-keys";
import type { UserSelect, UserWithRelations } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations } from "../../orm/input-types";
/** Query key factory - re-exported from query-keys.ts */
export const userQueryKey = userKeys.detail;
/**
 * Query hook for fetching a single User
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUserQuery({
 *   id: 'some-id',
 *   selection: { fields: { id: true, name: true } },
 * });
 * \`\`\`
 */
export function useUserQuery<S extends UserSelect, TData = {
  user: InferSelectResult<UserWithRelations, S> | null;
}>(params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, UserSelect>;
} & Omit<UseQueryOptions<{
  user: InferSelectResult<UserWithRelations, S> | null;
}, Error, TData>, "queryKey" | "queryFn">): UseQueryResult<TData>;
export function useUserQuery(params: {
  id: string;
  selection: SelectionConfig<UserSelect>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: userKeys.detail(params.id),
    queryFn: () => getClient().user.findOne({
      id: params.id,
      select: args.select
    }).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch a single User without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchUserQuery({
 *   id: 'some-id',
 *   selection: { fields: { id: true } },
 * });
 * \`\`\`
 */
export async function fetchUserQuery<S extends UserSelect>(params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<{
  user: InferSelectResult<UserWithRelations, S> | null;
}>;
export async function fetchUserQuery(params: {
  id: string;
  selection: SelectionConfig<UserSelect>;
}) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  return getClient().user.findOne({
    id: params.id,
    select: args.select
  }).unwrap();
}
/**
 * Prefetch a single User for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUserQuery(queryClient, { id: 'some-id', selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function prefetchUserQuery<S extends UserSelect>(queryClient: QueryClient, params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<void>;
export async function prefetchUserQuery(queryClient: QueryClient, params: {
  id: string;
  selection: SelectionConfig<UserSelect>;
}): Promise<void> {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: userKeys.detail(params.id),
    queryFn: () => getClient().user.findOne({
      id: params.id,
      select: args.select
    }).unwrap()
  });
}
"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook for table with relationships 1`] = `
"/**
 * Single item query hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import { postKeys } from "../query-keys";
import type { PostScope } from "../query-keys";
import type { PostSelect, PostWithRelations } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { PostSelect, PostWithRelations } from "../../orm/input-types";
/** Query key factory - re-exported from query-keys.ts */
export const postQueryKey = postKeys.detail;
/**
 * Query hook for fetching a single Post
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = usePostQuery({
 *   id: 'some-id',
 *   selection: { fields: { id: true, name: true } },
 * });
 * \`\`\`
 * 
 * @example With scope for hierarchical cache invalidation
 * \`\`\`tsx
 * const { data } = usePostQuery({
 *   id: 'some-id',
 *   selection: { fields: { id: true } },
 *   scope: { parentId: 'parent-id' },
 * });
 * \`\`\`
 */
export function usePostQuery<S extends PostSelect, TData = {
  post: InferSelectResult<PostWithRelations, S> | null;
}>(params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, PostSelect>;
} & Omit<UseQueryOptions<{
  post: InferSelectResult<PostWithRelations, S> | null;
}, Error, TData>, "queryKey" | "queryFn"> & {
  scope?: PostScope;
}): UseQueryResult<TData>;
export function usePostQuery(params: {
  id: string;
  selection: SelectionConfig<PostSelect>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn"> & {
  scope?: PostScope;
}) {
  const args = buildSelectionArgs<PostSelect>(params.selection);
  const {
    scope,
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: postKeys.detail(params.id, scope),
    queryFn: () => getClient().post.findOne({
      id: params.id,
      select: args.select
    }).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch a single Post without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchPostQuery({
 *   id: 'some-id',
 *   selection: { fields: { id: true } },
 * });
 * \`\`\`
 */
export async function fetchPostQuery<S extends PostSelect>(params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, PostSelect>;
}): Promise<{
  post: InferSelectResult<PostWithRelations, S> | null;
}>;
export async function fetchPostQuery(params: {
  id: string;
  selection: SelectionConfig<PostSelect>;
}) {
  const args = buildSelectionArgs<PostSelect>(params.selection);
  return getClient().post.findOne({
    id: params.id,
    select: args.select
  }).unwrap();
}
/**
 * Prefetch a single Post for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchPostQuery(queryClient, { id: 'some-id', selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function prefetchPostQuery<S extends PostSelect>(queryClient: QueryClient, params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, PostSelect>;
} & {
  scope?: PostScope;
}): Promise<void>;
export async function prefetchPostQuery(queryClient: QueryClient, params: {
  id: string;
  selection: SelectionConfig<PostSelect>;
} & {
  scope?: PostScope;
}): Promise<void> {
  const args = buildSelectionArgs<PostSelect>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: postKeys.detail(params.id, params?.scope),
    queryFn: () => getClient().post.findOne({
      id: params.id,
      select: args.select
    }).unwrap()
  });
}
"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook without centralized keys 1`] = `
"/**
 * Single item query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from "@tanstack/react-query";
import type { UseQueryOptions, UseQueryResult, QueryClient } from "@tanstack/react-query";
import { getClient } from "../client";
import { buildSelectionArgs } from "../selection";
import type { SelectionConfig } from "../selection";
import type { UserSelect, UserWithRelations } from "../../orm/input-types";
import type { InferSelectResult, HookStrictSelect } from "../../orm/select-types";
export type { UserSelect, UserWithRelations } from "../../orm/input-types";
export const userQueryKey = (id: string) => ["user", "detail", id] as const;
/**
 * Query hook for fetching a single User
 * 
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUserQuery({
 *   id: 'some-id',
 *   selection: { fields: { id: true, name: true } },
 * });
 * \`\`\`
 */
export function useUserQuery<S extends UserSelect, TData = {
  user: InferSelectResult<UserWithRelations, S> | null;
}>(params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, UserSelect>;
} & Omit<UseQueryOptions<{
  user: InferSelectResult<UserWithRelations, S> | null;
}, Error, TData>, "queryKey" | "queryFn">): UseQueryResult<TData>;
export function useUserQuery(params: {
  id: string;
  selection: SelectionConfig<UserSelect>;
} & Omit<UseQueryOptions<any, Error, any, any>, "queryKey" | "queryFn">) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  const {
    selection: _selection,
    ...queryOptions
  } = params ?? {};
  void _selection;
  return useQuery({
    queryKey: userQueryKey(params.id),
    queryFn: () => getClient().user.findOne({
      id: params.id,
      select: args.select
    }).unwrap(),
    ...queryOptions
  });
}
/**
 * Fetch a single User without React hooks
 * 
 * @example
 * \`\`\`ts
 * const data = await fetchUserQuery({
 *   id: 'some-id',
 *   selection: { fields: { id: true } },
 * });
 * \`\`\`
 */
export async function fetchUserQuery<S extends UserSelect>(params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<{
  user: InferSelectResult<UserWithRelations, S> | null;
}>;
export async function fetchUserQuery(params: {
  id: string;
  selection: SelectionConfig<UserSelect>;
}) {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  return getClient().user.findOne({
    id: params.id,
    select: args.select
  }).unwrap();
}
/**
 * Prefetch a single User for SSR or cache warming
 * 
 * @example
 * \`\`\`ts
 * await prefetchUserQuery(queryClient, { id: 'some-id', selection: { fields: { id: true } } });
 * \`\`\`
 */
export async function prefetchUserQuery<S extends UserSelect>(queryClient: QueryClient, params: {
  id: string;
  selection: {
    fields: S;
  } & HookStrictSelect<NoInfer<S>, UserSelect>;
}): Promise<void>;
export async function prefetchUserQuery(queryClient: QueryClient, params: {
  id: string;
  selection: SelectionConfig<UserSelect>;
}): Promise<void> {
  const args = buildSelectionArgs<UserSelect>(params.selection);
  await queryClient.prefetchQuery({
    queryKey: userQueryKey(params.id),
    queryFn: () => getClient().user.findOne({
      id: params.id,
      select: args.select
    }).unwrap()
  });
}
"
`;

exports[`Schema Types Generator generateSchemaTypesFile generates schema types file with empty table types 1`] = `
"/**
 * GraphQL schema types for custom operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import type { BigFloatFilter, BigIntFilter, BitStringFilter, BooleanFilter, DateFilter, DatetimeFilter, FloatFilter, FullTextFilter, IntFilter, IntListFilter, InternetAddressFilter, JSONFilter, StringFilter, StringListFilter, UUIDFilter, UUIDListFilter } from "./types";
export type UserRole = "ADMIN" | "USER" | "GUEST";
export interface RegisterInput {
  email: string;
  password: string;
  name?: string;
}
export interface LoginPayload {
  token?: string | null;
  user?: User | null;
}
export interface LogoutPayload {
  success?: boolean | null;
}
export interface RegisterPayload {
  token?: string | null;
  user?: User | null;
}"
`;

exports[`Schema Types Generator generateSchemaTypesFile generates schema types file with enums and input objects 1`] = `
"/**
 * GraphQL schema types for custom operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import type { User, BigFloatFilter, BigIntFilter, BitStringFilter, BooleanFilter, DateFilter, DatetimeFilter, FloatFilter, FullTextFilter, IntFilter, IntListFilter, InternetAddressFilter, JSONFilter, StringFilter, StringListFilter, UUIDFilter, UUIDListFilter } from "./types";
export type UserRole = "ADMIN" | "USER" | "GUEST";
export interface RegisterInput {
  email: string;
  password: string;
  name?: string;
}
export interface LoginPayload {
  token?: string | null;
  user?: User | null;
}
export interface LogoutPayload {
  success?: boolean | null;
}
export interface RegisterPayload {
  token?: string | null;
  user?: User | null;
}"
`;
