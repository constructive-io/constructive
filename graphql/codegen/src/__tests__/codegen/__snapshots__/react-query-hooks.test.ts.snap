// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`Barrel File Generators generateCustomMutationsBarrel generates custom mutations barrel 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";
export * from "./useLoginMutation";
export * from "./useLogoutMutation";
export * from "./useRegisterMutation";"
`;

exports[`Barrel File Generators generateCustomQueriesBarrel generates custom queries barrel 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";
export * from "./useCurrentUserQuery";
export * from "./useSearchUsersQuery";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel with all options enabled 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User, Post
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({ first: 10 });
 *   const { mutate } = useCreateCarMutation();
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./query-keys";
export * from "./mutation-keys";
export * from "./invalidation";
export * from "./queries";
export * from "./mutations";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel without custom operations 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({ first: 10 });
 *   const { mutate } = useCreateCarMutation();
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./queries";
export * from "./mutations";"
`;

exports[`Barrel File Generators generateMainBarrel generates main barrel without mutations 1`] = `
"/**
 * Auto-generated GraphQL SDK
 * @generated by @constructive-io/graphql-codegen
 * 
 * Tables: User, Post
 * 
 * Usage:
 * 
 * 1. Configure the client:
 * \`\`\`ts
 * import { configure } from './generated';
 * 
 * configure({
 *   endpoint: 'https://api.example.com/graphql',
 *   headers: { Authorization: 'Bearer <token>' },
 * });
 * \`\`\`
 * 
 * 2. Use the hooks:
 * \`\`\`tsx
 * import { useCarsQuery, useCreateCarMutation } from './generated';
 * 
 * function MyComponent() {
 *   const { data, isLoading } = useCarsQuery({ first: 10 });
 *   const { mutate } = useCreateCarMutation();
 *   // ...
 * }
 * \`\`\`
 */
export * from "./client";
export * from "./queries";"
`;

exports[`Barrel File Generators generateMutationsBarrel generates mutations barrel for multiple tables 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";
export * from "./useCreatePostMutation";
export * from "./useUpdatePostMutation";
export * from "./useDeletePostMutation";"
`;

exports[`Barrel File Generators generateMutationsBarrel generates mutations barrel for single table 1`] = `
"/**
 * Mutation hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useCreateUserMutation";
export * from "./useUpdateUserMutation";
export * from "./useDeleteUserMutation";"
`;

exports[`Barrel File Generators generateQueriesBarrel generates queries barrel for multiple tables 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";
export * from "./usePostsQuery";
export * from "./usePostQuery";"
`;

exports[`Barrel File Generators generateQueriesBarrel generates queries barrel for single table 1`] = `
"/**
 * Query hooks barrel export
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
export * from "./useUsersQuery";
export * from "./useUserQuery";"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook with arguments 1`] = `
"/**
 * Custom mutation hook for login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { customMutationKeys } from '../mutation-keys';
import type { LoginVariables } from '../../orm/mutation';
import type { LoginPayloadSelect, LoginPayload } from '../../orm/input-types';
import type { DeepExact, InferSelectResult } from '../../orm/select-types';

export type { LoginVariables } from '../../orm/mutation';
export type { LoginPayloadSelect } from '../../orm/input-types';

const defaultSelect = { token: true } as const;

export function useLoginMutation<const S extends LoginPayloadSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, LoginPayloadSelect> },
  options?: Omit<UseMutationOptions<{ login: InferSelectResult<LoginPayload, S> }, Error, LoginVariables>, 'mutationFn'>
) {
  return useMutation({
    mutationKey: customMutationKeys.login(),
    mutationFn: (variables: LoginVariables) => getClient().mutation.login(variables, { select: (args?.select ?? defaultSelect) as DeepExact<S, LoginPayloadSelect> }).unwrap(),
    ...options,
  });
}
"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook with input object argument 1`] = `
"/**
 * Custom mutation hook for register
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { customMutationKeys } from '../mutation-keys';
import type { RegisterVariables } from '../../orm/mutation';
import type { RegisterPayloadSelect, RegisterPayload } from '../../orm/input-types';
import type { DeepExact, InferSelectResult } from '../../orm/select-types';

export type { RegisterVariables } from '../../orm/mutation';
export type { RegisterPayloadSelect } from '../../orm/input-types';

const defaultSelect = { token: true } as const;

export function useRegisterMutation<const S extends RegisterPayloadSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, RegisterPayloadSelect> },
  options?: Omit<UseMutationOptions<{ register: InferSelectResult<RegisterPayload, S> }, Error, RegisterVariables>, 'mutationFn'>
) {
  return useMutation({
    mutationKey: customMutationKeys.register(),
    mutationFn: (variables: RegisterVariables) => getClient().mutation.register(variables, { select: (args?.select ?? defaultSelect) as DeepExact<S, RegisterPayloadSelect> }).unwrap(),
    ...options,
  });
}
"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook without arguments 1`] = `
"/**
 * Custom mutation hook for logout
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { customMutationKeys } from '../mutation-keys';
import type { LogoutPayloadSelect, LogoutPayload } from '../../orm/input-types';
import type { DeepExact, InferSelectResult } from '../../orm/select-types';

export type { LogoutPayloadSelect } from '../../orm/input-types';

const defaultSelect = { success: true } as const;

export function useLogoutMutation<const S extends LogoutPayloadSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, LogoutPayloadSelect> },
  options?: Omit<UseMutationOptions<{ logout: InferSelectResult<LogoutPayload, S> }, Error, void>, 'mutationFn'>
) {
  return useMutation({
    mutationKey: customMutationKeys.logout(),
    mutationFn: () => getClient().mutation.logout({ select: (args?.select ?? defaultSelect) as DeepExact<S, LogoutPayloadSelect> }).unwrap(),
    ...options,
  });
}
"
`;

exports[`Custom Mutation Hook Generators generateCustomMutationHook generates custom mutation hook without centralized keys 1`] = `
"/**
 * Custom mutation hook for login
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import type { LoginVariables } from '../../orm/mutation';
import type { LoginPayloadSelect, LoginPayload } from '../../orm/input-types';
import type { DeepExact, InferSelectResult } from '../../orm/select-types';

export type { LoginVariables } from '../../orm/mutation';
export type { LoginPayloadSelect } from '../../orm/input-types';

const defaultSelect = { token: true } as const;

export function useLoginMutation<const S extends LoginPayloadSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, LoginPayloadSelect> },
  options?: Omit<UseMutationOptions<{ login: InferSelectResult<LoginPayload, S> }, Error, LoginVariables>, 'mutationFn'>
) {
  return useMutation({
    mutationFn: (variables: LoginVariables) => getClient().mutation.login(variables, { select: (args?.select ?? defaultSelect) as DeepExact<S, LoginPayloadSelect> }).unwrap(),
    ...options,
  });
}
"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook with arguments 1`] = `
"/**
 * Custom query hook for searchUsers
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import { customQueryKeys } from '../query-keys';
import type { SearchUsersVariables } from '../../orm/query';
import type { UserSelect, User } from '../../orm/input-types';
import type { DeepExact, InferSelectResult } from '../../orm/select-types';

export type { SearchUsersVariables } from '../../orm/query';
export type { UserSelect } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/** Query key factory - re-exported from query-keys.ts */
export const searchUsersQueryKey = customQueryKeys.searchUsers;

/**
 * Search users by name or email
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useSearchUsersQuery({ query, limit });
 *
 * if (data?.searchUsers) {
 *   console.log(data.searchUsers);
 * }
 * \`\`\`
 */
export function useSearchUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  variables: SearchUsersVariables,
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseQueryOptions<{ searchUsers: InferSelectResult<User, S>[] }, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: searchUsersQueryKey(variables),
    queryFn: () => getClient().query.searchUsers(variables!, { select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    enabled: !!variables && options?.enabled !== false,
    ...options,
  });
}

/**
 * Fetch searchUsers without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchSearchUsersQuery({ query, limit });
 * \`\`\`
 */
export async function fetchSearchUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  variables: SearchUsersVariables,
  args?: { select?: DeepExact<S, UserSelect> }
) {
  return getClient().query.searchUsers(variables!, { select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap();
}

/**
 * Prefetch searchUsers for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchSearchUsersQuery(queryClient, { query, limit });
 * \`\`\`
 */
export async function prefetchSearchUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  variables: SearchUsersVariables,
  args?: { select?: DeepExact<S, UserSelect> }
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: searchUsersQueryKey(variables),
    queryFn: () => getClient().query.searchUsers(variables!, { select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
  });
}
"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook without arguments 1`] = `
"/**
 * Custom query hook for currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import { customQueryKeys } from '../query-keys';
import type { UserSelect, User } from '../../orm/input-types';
import type { DeepExact, InferSelectResult } from '../../orm/select-types';

export type { UserSelect } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/** Query key factory - re-exported from query-keys.ts */
export const currentUserQueryKey = customQueryKeys.currentUser;

/**
 * Get the current authenticated user
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useCurrentUserQuery();
 *
 * if (data?.currentUser) {
 *   console.log(data.currentUser);
 * }
 * \`\`\`
 */
export function useCurrentUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseQueryOptions<{ currentUser: InferSelectResult<User, S> }, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({ select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    ...options,
  });
}

/**
 * Fetch currentUser without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchCurrentUserQuery();
 * \`\`\`
 */
export async function fetchCurrentUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> }
) {
  return getClient().query.currentUser({ select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap();
}

/**
 * Prefetch currentUser for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchCurrentUserQuery(queryClient);
 * \`\`\`
 */
export async function prefetchCurrentUserQuery<const S extends UserSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args?: { select?: DeepExact<S, UserSelect> }
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({ select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
  });
}
"
`;

exports[`Custom Query Hook Generators generateCustomQueryHook generates custom query hook without centralized keys 1`] = `
"/**
 * Custom query hook for currentUser
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import type { UserSelect, User } from '../../orm/input-types';
import type { DeepExact, InferSelectResult } from '../../orm/select-types';

export type { UserSelect } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/** Query key factory for caching */
export const currentUserQueryKey = () => ['currentUser'] as const;

/**
 * Get the current authenticated user
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useCurrentUserQuery();
 *
 * if (data?.currentUser) {
 *   console.log(data.currentUser);
 * }
 * \`\`\`
 */
export function useCurrentUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseQueryOptions<{ currentUser: InferSelectResult<User, S> }, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({ select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    ...options,
  });
}

/**
 * Fetch currentUser without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchCurrentUserQuery();
 * \`\`\`
 */
export async function fetchCurrentUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> }
) {
  return getClient().query.currentUser({ select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap();
}

/**
 * Prefetch currentUser for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchCurrentUserQuery(queryClient);
 * \`\`\`
 */
export async function prefetchCurrentUserQuery<const S extends UserSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args?: { select?: DeepExact<S, UserSelect> }
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: currentUserQueryKey(),
    queryFn: () => getClient().query.currentUser({ select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
  });
}
"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook for simple table 1`] = `
"/**
 * Create mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { userKeys } from '../query-keys';
import { userMutationKeys } from '../mutation-keys';
import type {
  UserSelect,
  UserWithRelations,
  CreateUserInput,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations, CreateUserInput } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for creating a User
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreateUserMutation({
 *   select: { id: true, name: true },
 * });
 *
 * mutate({ name: 'New item' });
 * \`\`\`
 */
export function useCreateUserMutation<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseMutationOptions<{ createUser: { user: InferSelectResult<UserWithRelations, S> } }, Error, CreateUserInput['user']>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.create(),
    mutationFn: (data: CreateUserInput['user']) => getClient().user.create({ data, select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook for table with relationships 1`] = `
"/**
 * Create mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { postKeys } from '../query-keys';
import { postMutationKeys } from '../mutation-keys';
import type {
  PostSelect,
  PostWithRelations,
  CreatePostInput,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { PostSelect, PostWithRelations, CreatePostInput } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for creating a Post
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreatePostMutation({
 *   select: { id: true, name: true },
 * });
 *
 * mutate({ name: 'New item' });
 * \`\`\`
 */
export function useCreatePostMutation<const S extends PostSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, PostSelect> },
  options?: Omit<UseMutationOptions<{ createPost: { post: InferSelectResult<PostWithRelations, S> } }, Error, CreatePostInput['post']>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.create(),
    mutationFn: (data: CreatePostInput['post']) => getClient().post.create({ data, select: (args?.select ?? defaultSelect) as DeepExact<S, PostSelect> }).unwrap(),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateCreateMutationHook generates create mutation hook without centralized keys 1`] = `
"/**
 * Create mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import type {
  UserSelect,
  UserWithRelations,
  CreateUserInput,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations, CreateUserInput } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for creating a User
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useCreateUserMutation({
 *   select: { id: true, name: true },
 * });
 *
 * mutate({ name: 'New item' });
 * \`\`\`
 */
export function useCreateUserMutation<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseMutationOptions<{ createUser: { user: InferSelectResult<UserWithRelations, S> } }, Error, CreateUserInput['user']>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreateUserInput['user']) => getClient().user.create({ data, select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user', 'list'] });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook for simple table 1`] = `
"/**
 * Delete mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { userKeys } from '../query-keys';
import { userMutationKeys } from '../mutation-keys';
import type {
  UserSelect,
  UserWithRelations,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for deleting a User
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeleteUserMutation({
 *   select: { id: true },
 * });
 *
 * mutate({ id: 'value-to-delete' });
 * \`\`\`
 */
export function useDeleteUserMutation<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseMutationOptions<{ deleteUser: { user: InferSelectResult<UserWithRelations, S> } }, Error, { id: string }>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.all,
    mutationFn: ({ id }: { id: string }) => getClient().user.delete({ where: { id }, select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({ queryKey: userKeys.detail(variables.id) });
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook for table with relationships 1`] = `
"/**
 * Delete mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { postKeys } from '../query-keys';
import { postMutationKeys } from '../mutation-keys';
import type {
  PostSelect,
  PostWithRelations,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { PostSelect, PostWithRelations } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for deleting a Post
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeletePostMutation({
 *   select: { id: true },
 * });
 *
 * mutate({ id: 'value-to-delete' });
 * \`\`\`
 */
export function useDeletePostMutation<const S extends PostSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, PostSelect> },
  options?: Omit<UseMutationOptions<{ deletePost: { post: InferSelectResult<PostWithRelations, S> } }, Error, { id: string }>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.all,
    mutationFn: ({ id }: { id: string }) => getClient().post.delete({ where: { id }, select: (args?.select ?? defaultSelect) as DeepExact<S, PostSelect> }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({ queryKey: postKeys.detail(variables.id) });
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateDeleteMutationHook generates delete mutation hook without centralized keys 1`] = `
"/**
 * Delete mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import type {
  UserSelect,
  UserWithRelations,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for deleting a User
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useDeleteUserMutation({
 *   select: { id: true },
 * });
 *
 * mutate({ id: 'value-to-delete' });
 * \`\`\`
 */
export function useDeleteUserMutation<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseMutationOptions<{ deleteUser: { user: InferSelectResult<UserWithRelations, S> } }, Error, { id: string }>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id }: { id: string }) => getClient().user.delete({ where: { id }, select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.removeQueries({ queryKey: ['user', 'detail', variables.id] });
      queryClient.invalidateQueries({ queryKey: ['user', 'list'] });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook for simple table 1`] = `
"/**
 * Update mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { userKeys } from '../query-keys';
import { userMutationKeys } from '../mutation-keys';
import type {
  UserSelect,
  UserWithRelations,
  UserPatch,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations, UserPatch } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for updating a User
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdateUserMutation({
 *   select: { id: true, name: true },
 * });
 *
 * mutate({ id: 'value-here', patch: { name: 'Updated' } });
 * \`\`\`
 */
export function useUpdateUserMutation<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseMutationOptions<{ updateUser: { user: InferSelectResult<UserWithRelations, S> } }, Error, { id: string; patch: UserPatch }>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: userMutationKeys.all,
    mutationFn: ({ id, patch }: { id: string; patch: UserPatch }) => getClient().user.update({ where: { id }, data: patch, select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: userKeys.detail(variables.id) });
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook for table with relationships 1`] = `
"/**
 * Update mutation hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import { postKeys } from '../query-keys';
import { postMutationKeys } from '../mutation-keys';
import type {
  PostSelect,
  PostWithRelations,
  PostPatch,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { PostSelect, PostWithRelations, PostPatch } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for updating a Post
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdatePostMutation({
 *   select: { id: true, name: true },
 * });
 *
 * mutate({ id: 'value-here', patch: { name: 'Updated' } });
 * \`\`\`
 */
export function useUpdatePostMutation<const S extends PostSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, PostSelect> },
  options?: Omit<UseMutationOptions<{ updatePost: { post: InferSelectResult<PostWithRelations, S> } }, Error, { id: string; patch: PostPatch }>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationKey: postMutationKeys.all,
    mutationFn: ({ id, patch }: { id: string; patch: PostPatch }) => getClient().post.update({ where: { id }, data: patch, select: (args?.select ?? defaultSelect) as DeepExact<S, PostSelect> }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: postKeys.detail(variables.id) });
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
    },
    ...options,
  });
}
"
`;

exports[`Mutation Hook Generators generateUpdateMutationHook generates update mutation hook without centralized keys 1`] = `
"/**
 * Update mutation hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useMutation, useQueryClient } from '@tanstack/react-query';
import type { UseMutationOptions } from '@tanstack/react-query';
import { getClient } from '../client';
import type {
  UserSelect,
  UserWithRelations,
  UserPatch,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations, UserPatch } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/**
 * Mutation hook for updating a User
 *
 * @example
 * \`\`\`tsx
 * const { mutate, isPending } = useUpdateUserMutation({
 *   select: { id: true, name: true },
 * });
 *
 * mutate({ id: 'value-here', patch: { name: 'Updated' } });
 * \`\`\`
 */
export function useUpdateUserMutation<const S extends UserSelect = typeof defaultSelect>(
  args?: { select?: DeepExact<S, UserSelect> },
  options?: Omit<UseMutationOptions<{ updateUser: { user: InferSelectResult<UserWithRelations, S> } }, Error, { id: string; patch: UserPatch }>, 'mutationFn'>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, patch }: { id: string; patch: UserPatch }) => getClient().user.update({ where: { id }, data: patch, select: (args?.select ?? defaultSelect) as DeepExact<S, UserSelect> }).unwrap(),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['user', 'detail', variables.id] });
      queryClient.invalidateQueries({ queryKey: ['user', 'list'] });
    },
    ...options,
  });
}
"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook for simple table 1`] = `
"/**
 * List query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import { userKeys } from '../query-keys';
import type {
  UserSelect,
  UserWithRelations,
  UserFilter,
  UsersOrderBy,
} from '../../orm/input-types';
import type {
  FindManyArgs,
  DeepExact,
  InferSelectResult,
  ConnectionResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations, UserFilter, UsersOrderBy } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/** Query key factory - re-exported from query-keys.ts */
export const usersQueryKey = userKeys.list;

/**
 * Query hook for fetching User list
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUsersQuery({
 *   select: { id: true, name: true },
 *   first: 10,
 *   where: { name: { equalTo: "example" } },
 *   orderBy: ['CREATED_AT_DESC'],
 * });
 * \`\`\`
 */
export function useUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: FindManyArgs<DeepExact<S, UserSelect>, UserFilter, UsersOrderBy>,
  options?: Omit<UseQueryOptions<{ users: ConnectionResult<InferSelectResult<UserWithRelations, S>> }, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: userKeys.list(args),
    queryFn: () => getClient().user.findMany(args).unwrap(),
    ...options,
  });
}

/**
 * Fetch User list without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchUsersQuery({ first: 10, select: { id: true } });
 * \`\`\`
 */
export async function fetchUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: FindManyArgs<DeepExact<S, UserSelect>, UserFilter, UsersOrderBy>,
) {
  return getClient().user.findMany(args).unwrap();
}

/**
 * Prefetch User list for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchUsersQuery(queryClient, { first: 10 });
 * \`\`\`
 */
export async function prefetchUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args?: FindManyArgs<DeepExact<S, UserSelect>, UserFilter, UsersOrderBy>,
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: userKeys.list(args),
    queryFn: () => getClient().user.findMany(args).unwrap(),
  });
}
"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook for table with relationships 1`] = `
"/**
 * List query hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import { postKeys } from '../query-keys';
import type { PostScope } from '../query-keys';
import type {
  PostSelect,
  PostWithRelations,
  PostFilter,
  PostsOrderBy,
} from '../../orm/input-types';
import type {
  FindManyArgs,
  DeepExact,
  InferSelectResult,
  ConnectionResult,
} from '../../orm/select-types';

export type { PostSelect, PostWithRelations, PostFilter, PostsOrderBy } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/** Query key factory - re-exported from query-keys.ts */
export const postsQueryKey = postKeys.list;

/**
 * Query hook for fetching Post list
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = usePostsQuery({
 *   select: { id: true, name: true },
 *   first: 10,
 *   where: { name: { equalTo: "example" } },
 *   orderBy: ['CREATED_AT_DESC'],
 * });
 * \`\`\`
 *
 * @example With scope for hierarchical cache invalidation
 * \`\`\`tsx
 * const { data } = usePostsQuery(
 *   { first: 10 },
 *   { scope: { parentId: 'parent-id' } }
 * );
 * \`\`\`
 */
export function usePostsQuery<const S extends PostSelect = typeof defaultSelect>(
  args?: FindManyArgs<DeepExact<S, PostSelect>, PostFilter, PostsOrderBy>,
  options?: Omit<UseQueryOptions<{ posts: ConnectionResult<InferSelectResult<PostWithRelations, S>> }, Error>, 'queryKey' | 'queryFn'> & { scope?: PostScope }
) {
  const { scope, ...queryOptions } = options ?? {};
  return useQuery({
    queryKey: postKeys.list(args, scope),
    queryFn: () => getClient().post.findMany(args).unwrap(),
    ...queryOptions,
  });
}

/**
 * Fetch Post list without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchPostsQuery({ first: 10, select: { id: true } });
 * \`\`\`
 */
export async function fetchPostsQuery<const S extends PostSelect = typeof defaultSelect>(
  args?: FindManyArgs<DeepExact<S, PostSelect>, PostFilter, PostsOrderBy>,
) {
  return getClient().post.findMany(args).unwrap();
}

/**
 * Prefetch Post list for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchPostsQuery(queryClient, { first: 10 });
 * \`\`\`
 */
export async function prefetchPostsQuery<const S extends PostSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args?: FindManyArgs<DeepExact<S, PostSelect>, PostFilter, PostsOrderBy>,
  scope?: PostScope,
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: postKeys.list(args, scope),
    queryFn: () => getClient().post.findMany(args).unwrap(),
  });
}
"
`;

exports[`Query Hook Generators generateListQueryHook generates list query hook without centralized keys 1`] = `
"/**
 * List query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import type {
  UserSelect,
  UserWithRelations,
  UserFilter,
  UsersOrderBy,
} from '../../orm/input-types';
import type {
  FindManyArgs,
  DeepExact,
  InferSelectResult,
  ConnectionResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations, UserFilter, UsersOrderBy } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

export const usersQueryKey = (variables?: FindManyArgs<any, UserFilter, UsersOrderBy>) => ['user', 'list', variables] as const;

/**
 * Query hook for fetching User list
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUsersQuery({
 *   select: { id: true, name: true },
 *   first: 10,
 *   where: { name: { equalTo: "example" } },
 *   orderBy: ['CREATED_AT_DESC'],
 * });
 * \`\`\`
 */
export function useUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: FindManyArgs<DeepExact<S, UserSelect>, UserFilter, UsersOrderBy>,
  options?: Omit<UseQueryOptions<{ users: ConnectionResult<InferSelectResult<UserWithRelations, S>> }, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: usersQueryKey(args),
    queryFn: () => getClient().user.findMany(args).unwrap(),
    ...options,
  });
}

/**
 * Fetch User list without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchUsersQuery({ first: 10, select: { id: true } });
 * \`\`\`
 */
export async function fetchUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  args?: FindManyArgs<DeepExact<S, UserSelect>, UserFilter, UsersOrderBy>,
) {
  return getClient().user.findMany(args).unwrap();
}

/**
 * Prefetch User list for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchUsersQuery(queryClient, { first: 10 });
 * \`\`\`
 */
export async function prefetchUsersQuery<const S extends UserSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args?: FindManyArgs<DeepExact<S, UserSelect>, UserFilter, UsersOrderBy>,
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: usersQueryKey(args),
    queryFn: () => getClient().user.findMany(args).unwrap(),
  });
}
"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook for simple table 1`] = `
"/**
 * Single item query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import { userKeys } from '../query-keys';
import type {
  UserSelect,
  UserWithRelations,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/** Query key factory - re-exported from query-keys.ts */
export const userQueryKey = userKeys.detail;

/**
 * Query hook for fetching a single User
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUserQuery({
 *   id: 'some-id',
 *   select: { id: true, name: true },
 * });
 * \`\`\`
 */
export function useUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args: { id: string; select?: DeepExact<S, UserSelect> },
  options?: Omit<UseQueryOptions<{ user: InferSelectResult<UserWithRelations, S> | null }, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: userKeys.detail(args.id),
    queryFn: () => getClient().user.findOne(args).unwrap(),
    ...options,
  });
}

/**
 * Fetch a single User without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchUserQuery({ id: 'some-id', select: { id: true } });
 * \`\`\`
 */
export async function fetchUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args: { id: string; select?: DeepExact<S, UserSelect> },
) {
  return getClient().user.findOne(args).unwrap();
}

/**
 * Prefetch a single User for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchUserQuery(queryClient, { id: 'some-id' });
 * \`\`\`
 */
export async function prefetchUserQuery<const S extends UserSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args: { id: string; select?: DeepExact<S, UserSelect> },
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: userKeys.detail(args.id),
    queryFn: () => getClient().user.findOne(args).unwrap(),
  });
}
"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook for table with relationships 1`] = `
"/**
 * Single item query hook for Post
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import { postKeys } from '../query-keys';
import type { PostScope } from '../query-keys';
import type {
  PostSelect,
  PostWithRelations,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { PostSelect, PostWithRelations } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

/** Query key factory - re-exported from query-keys.ts */
export const postQueryKey = postKeys.detail;

/**
 * Query hook for fetching a single Post
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = usePostQuery({
 *   id: 'some-id',
 *   select: { id: true, name: true },
 * });
 * \`\`\`
 *
 * @example With scope for hierarchical cache invalidation
 * \`\`\`tsx
 * const { data } = usePostQuery(
 *   { id: 'some-id' },
 *   { scope: { parentId: 'parent-id' } }
 * );
 * \`\`\`
 */
export function usePostQuery<const S extends PostSelect = typeof defaultSelect>(
  args: { id: string; select?: DeepExact<S, PostSelect> },
  options?: Omit<UseQueryOptions<{ post: InferSelectResult<PostWithRelations, S> | null }, Error>, 'queryKey' | 'queryFn'> & { scope?: PostScope }
) {
  const { scope, ...queryOptions } = options ?? {};
  return useQuery({
    queryKey: postKeys.detail(args.id, scope),
    queryFn: () => getClient().post.findOne(args).unwrap(),
    ...queryOptions,
  });
}

/**
 * Fetch a single Post without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchPostQuery({ id: 'some-id', select: { id: true } });
 * \`\`\`
 */
export async function fetchPostQuery<const S extends PostSelect = typeof defaultSelect>(
  args: { id: string; select?: DeepExact<S, PostSelect> },
) {
  return getClient().post.findOne(args).unwrap();
}

/**
 * Prefetch a single Post for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchPostQuery(queryClient, { id: 'some-id' });
 * \`\`\`
 */
export async function prefetchPostQuery<const S extends PostSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args: { id: string; select?: DeepExact<S, PostSelect> },
  scope?: PostScope,
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: postKeys.detail(args.id, scope),
    queryFn: () => getClient().post.findOne(args).unwrap(),
  });
}
"
`;

exports[`Query Hook Generators generateSingleQueryHook generates single query hook without centralized keys 1`] = `
"/**
 * Single item query hook for User
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import { useQuery } from '@tanstack/react-query';
import type { UseQueryOptions, QueryClient } from '@tanstack/react-query';
import { getClient } from '../client';
import type {
  UserSelect,
  UserWithRelations,
} from '../../orm/input-types';
import type {
  DeepExact,
  InferSelectResult,
} from '../../orm/select-types';

export type { UserSelect, UserWithRelations } from '../../orm/input-types';

const defaultSelect = { id: true } as const;

export const userQueryKey = (id: string) => ['user', 'detail', id] as const;

/**
 * Query hook for fetching a single User
 *
 * @example
 * \`\`\`tsx
 * const { data, isLoading } = useUserQuery({
 *   id: 'some-id',
 *   select: { id: true, name: true },
 * });
 * \`\`\`
 */
export function useUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args: { id: string; select?: DeepExact<S, UserSelect> },
  options?: Omit<UseQueryOptions<{ user: InferSelectResult<UserWithRelations, S> | null }, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: userQueryKey(args.id),
    queryFn: () => getClient().user.findOne(args).unwrap(),
    ...options,
  });
}

/**
 * Fetch a single User without React hooks
 *
 * @example
 * \`\`\`ts
 * const data = await fetchUserQuery({ id: 'some-id', select: { id: true } });
 * \`\`\`
 */
export async function fetchUserQuery<const S extends UserSelect = typeof defaultSelect>(
  args: { id: string; select?: DeepExact<S, UserSelect> },
) {
  return getClient().user.findOne(args).unwrap();
}

/**
 * Prefetch a single User for SSR or cache warming
 *
 * @example
 * \`\`\`ts
 * await prefetchUserQuery(queryClient, { id: 'some-id' });
 * \`\`\`
 */
export async function prefetchUserQuery<const S extends UserSelect = typeof defaultSelect>(
  queryClient: QueryClient,
  args: { id: string; select?: DeepExact<S, UserSelect> },
): Promise<void> {
  await queryClient.prefetchQuery({
    queryKey: userQueryKey(args.id),
    queryFn: () => getClient().user.findOne(args).unwrap(),
  });
}
"
`;

exports[`Schema Types Generator generateSchemaTypesFile generates schema types file with empty table types 1`] = `
"/**
 * GraphQL schema types for custom operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import type { BigFloatFilter, BigIntFilter, BitStringFilter, BooleanFilter, DateFilter, DatetimeFilter, FloatFilter, FullTextFilter, IntFilter, IntListFilter, InternetAddressFilter, JSONFilter, StringFilter, StringListFilter, UUIDFilter, UUIDListFilter } from "./types";
export type UserRole = "ADMIN" | "USER" | "GUEST";
export interface RegisterInput {
  email: string;
  password: string;
  name?: string;
}
export interface LoginPayload {
  token?: string | null;
  user?: User | null;
}
export interface LogoutPayload {
  success?: boolean | null;
}
export interface RegisterPayload {
  token?: string | null;
  user?: User | null;
}"
`;

exports[`Schema Types Generator generateSchemaTypesFile generates schema types file with enums and input objects 1`] = `
"/**
 * GraphQL schema types for custom operations
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */

import type { User, BigFloatFilter, BigIntFilter, BitStringFilter, BooleanFilter, DateFilter, DatetimeFilter, FloatFilter, FullTextFilter, IntFilter, IntListFilter, InternetAddressFilter, JSONFilter, StringFilter, StringListFilter, UUIDFilter, UUIDListFilter } from "./types";
export type UserRole = "ADMIN" | "USER" | "GUEST";
export interface RegisterInput {
  email: string;
  password: string;
  name?: string;
}
export interface LoginPayload {
  token?: string | null;
  user?: User | null;
}
export interface LogoutPayload {
  success?: boolean | null;
}
export interface RegisterPayload {
  token?: string | null;
  user?: User | null;
}"
`;
