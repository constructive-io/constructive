/**
 * Barrel file generators - creates index.ts files for exports
 *
 * Using Babel AST for generating barrel (index.ts) files with re-exports.
 */
import * as t from '@babel/types';

import type { CleanTable } from '../../types/schema';
import { addJSDocComment, generateCode } from './babel-ast';
import { getOperationHookName } from './type-resolver';
import {
  getCreateMutationHookName,
  getDeleteMutationHookName,
  getListQueryHookName,
  getSingleQueryHookName,
  getUpdateMutationHookName,
  hasValidPrimaryKey,
} from './utils';

/**
 * Helper to create export * from './module' statement
 */
function exportAllFrom(modulePath: string): t.ExportAllDeclaration {
  return t.exportAllDeclaration(t.stringLiteral(modulePath));
}

/**
 * Generate the queries/index.ts barrel file
 */
export function generateQueriesBarrel(tables: CleanTable[]): string {
  const statements: t.Statement[] = [];

  // Export all query hooks
  for (const table of tables) {
    const listHookName = getListQueryHookName(table);
    statements.push(exportAllFrom(`./${listHookName}`));

    // Only export single query hook if table has valid primary key
    if (hasValidPrimaryKey(table)) {
      const singleHookName = getSingleQueryHookName(table);
      statements.push(exportAllFrom(`./${singleHookName}`));
    }
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Query hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}

/**
 * Generate the mutations/index.ts barrel file
 */
export function generateMutationsBarrel(tables: CleanTable[]): string {
  const statements: t.Statement[] = [];

  // Export all mutation hooks
  for (const table of tables) {
    const createHookName = getCreateMutationHookName(table);

    statements.push(exportAllFrom(`./${createHookName}`));

    // Only add update/delete if they exist AND table has valid PK
    if (table.query?.update !== null && hasValidPrimaryKey(table)) {
      const updateHookName = getUpdateMutationHookName(table);
      statements.push(exportAllFrom(`./${updateHookName}`));
    }
    if (table.query?.delete !== null && hasValidPrimaryKey(table)) {
      const deleteHookName = getDeleteMutationHookName(table);
      statements.push(exportAllFrom(`./${deleteHookName}`));
    }
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Mutation hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}

/**
 * Generate the main index.ts barrel file
 *
 * @param tables - The tables to include in the SDK
 * @param hasSchemaTypes - Whether schema-types.ts was generated
 */
export interface MainBarrelOptions {
  hasMutations?: boolean;
  /** Whether query-keys.ts was generated */
  hasQueryKeys?: boolean;
  /** Whether mutation-keys.ts was generated */
  hasMutationKeys?: boolean;
  /** Whether invalidation.ts was generated */
  hasInvalidation?: boolean;
}

export function generateMainBarrel(
  tables: CleanTable[],
  options: MainBarrelOptions = {},
): string {
  const opts: MainBarrelOptions = options;

  const {
    hasMutations = true,
    hasQueryKeys = false,
    hasMutationKeys = false,
    hasInvalidation = false,
  } = opts;
  const tableNames = tables.map((tbl) => tbl.name).join(', ');

  const statements: t.Statement[] = [];

  // Client configuration (ORM wrapper with configure/getClient)
  statements.push(exportAllFrom('./client'));

  // Centralized query keys (for cache management)
  if (hasQueryKeys) {
    statements.push(exportAllFrom('./query-keys'));
  }

  // Centralized mutation keys (for tracking in-flight mutations)
  if (hasMutationKeys) {
    statements.push(exportAllFrom('./mutation-keys'));
  }

  // Cache invalidation helpers
  if (hasInvalidation) {
    statements.push(exportAllFrom('./invalidation'));
  }

  // Query hooks
  statements.push(exportAllFrom('./queries'));

  // Mutation hooks
  if (hasMutations) {
    statements.push(exportAllFrom('./mutations'));
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Auto-generated GraphQL SDK',
      '@generated by @constructive-io/graphql-codegen',
      '',
      `Tables: ${tableNames}`,
      '',
      'Usage:',
      '',
      '1. Configure the client:',
      '```ts',
      "import { configure } from './generated';",
      '',
      'configure({',
      "  endpoint: 'https://api.example.com/graphql',",
      "  headers: { Authorization: 'Bearer <token>' },",
      '});',
      '```',
      '',
      '2. Use the hooks:',
      '```tsx',
      "import { useCarsQuery, useCreateCarMutation } from './generated';",
      '',
      'function MyComponent() {',
      '  const { data, isLoading } = useCarsQuery({ first: 10 });',
      '  const { mutate } = useCreateCarMutation();',
      '  // ...',
      '}',
      '```',
    ]);
  }

  return generateCode(statements);
}

// ============================================================================
// Root barrel for unified output
// ============================================================================

export interface RootBarrelOptions {
  hasTypes?: boolean;
  hasHooks?: boolean;
  hasOrm?: boolean;
}

/**
 * Generate the root index.ts barrel file for the output directory.
 * Re-exports from subdirectories based on which generators are enabled.
 */
export function generateRootBarrel(options: RootBarrelOptions = {}): string {
  const { hasTypes = false, hasHooks = false, hasOrm = false } = options;
  const statements: t.Statement[] = [];

  if (hasTypes) {
    statements.push(exportAllFrom('./types'));
  }
  if (hasHooks) {
    statements.push(exportAllFrom('./hooks'));
  }
  if (hasOrm) {
    statements.push(exportAllFrom('./orm'));
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Generated SDK - auto-generated, do not edit',
      '@generated by @constructive-io/graphql-codegen',
    ]);
  }

  return generateCode(statements);
}

// ============================================================================
// Custom operation barrels (includes both table and custom hooks)
// ============================================================================

/**
 * Generate queries barrel including custom query operations
 */
export function generateCustomQueriesBarrel(
  tables: CleanTable[],
  customQueryNames: string[],
): string {
  const statements: t.Statement[] = [];
  const exportedHooks = new Set<string>();

  // Export all table query hooks
  for (const table of tables) {
    const listHookName = getListQueryHookName(table);
    if (!exportedHooks.has(listHookName)) {
      statements.push(exportAllFrom(`./${listHookName}`));
      exportedHooks.add(listHookName);
    }

    // Only export single query hook if table has valid primary key
    if (hasValidPrimaryKey(table)) {
      const singleHookName = getSingleQueryHookName(table);
      if (!exportedHooks.has(singleHookName)) {
        statements.push(exportAllFrom(`./${singleHookName}`));
        exportedHooks.add(singleHookName);
      }
    }
  }

  // Add custom query hooks (skip if already exported from table hooks)
  for (const name of customQueryNames) {
    const hookName = getOperationHookName(name, 'query');
    if (!exportedHooks.has(hookName)) {
      statements.push(exportAllFrom(`./${hookName}`));
      exportedHooks.add(hookName);
    }
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Query hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}

/**
 * Generate mutations barrel including custom mutation operations
 */
export function generateCustomMutationsBarrel(
  tables: CleanTable[],
  customMutationNames: string[],
): string {
  const statements: t.Statement[] = [];
  const exportedHooks = new Set<string>();

  // Export all table mutation hooks
  for (const table of tables) {
    const createHookName = getCreateMutationHookName(table);
    if (!exportedHooks.has(createHookName)) {
      statements.push(exportAllFrom(`./${createHookName}`));
      exportedHooks.add(createHookName);
    }

    // Only add update/delete if they exist AND table has valid PK
    if (table.query?.update !== null && hasValidPrimaryKey(table)) {
      const updateHookName = getUpdateMutationHookName(table);
      if (!exportedHooks.has(updateHookName)) {
        statements.push(exportAllFrom(`./${updateHookName}`));
        exportedHooks.add(updateHookName);
      }
    }
    if (table.query?.delete !== null && hasValidPrimaryKey(table)) {
      const deleteHookName = getDeleteMutationHookName(table);
      if (!exportedHooks.has(deleteHookName)) {
        statements.push(exportAllFrom(`./${deleteHookName}`));
        exportedHooks.add(deleteHookName);
      }
    }
  }

  // Add custom mutation hooks (skip if already exported from table hooks)
  for (const name of customMutationNames) {
    const hookName = getOperationHookName(name, 'mutation');
    if (!exportedHooks.has(hookName)) {
      statements.push(exportAllFrom(`./${hookName}`));
      exportedHooks.add(hookName);
    }
  }

  // Add file header as leading comment on first statement
  if (statements.length > 0) {
    addJSDocComment(statements[0], [
      'Mutation hooks barrel export',
      '@generated by @constructive-io/graphql-codegen',
      'DO NOT EDIT - changes will be overwritten',
    ]);
  }

  return generateCode(statements);
}
