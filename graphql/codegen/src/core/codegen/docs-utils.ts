import type { DocsConfig } from '../../types/config';
import type { CleanField, CleanOperation, CleanTable } from '../../types/schema';
import { getScalarFields, getPrimaryKeyInfo } from './utils';

export interface GeneratedDocFile {
  fileName: string;
  content: string;
}

export interface McpTool {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
  _meta?: Record<string, unknown>;
}

export interface SkillDefinition {
  name: string;
  description: string;
  usage: string[];
  examples: { description: string; code: string[] }[];
  language?: string;
}

export function resolveDocsConfig(
  docs: DocsConfig | boolean | undefined,
): DocsConfig {
  if (docs === true) {
    return { readme: true, agents: true, mcp: true, skills: true };
  }
  if (docs === false) {
    return { readme: false, agents: false, mcp: false, skills: false };
  }
  if (!docs) {
    return { readme: true, agents: true, mcp: false, skills: false };
  }
  return {
    readme: docs.readme ?? true,
    agents: docs.agents ?? true,
    mcp: docs.mcp ?? false,
    skills: docs.skills ?? false,
  };
}

export function formatArgType(arg: CleanOperation['args'][number]): string {
  const t = arg.type;
  if (t.kind === 'NON_NULL' && t.ofType) {
    return `${formatTypeRef(t.ofType)} (required)`;
  }
  return formatTypeRef(t);
}

export function formatTypeRef(
  t: CleanOperation['args'][number]['type'],
): string {
  if (t.kind === 'LIST' && t.ofType) {
    return `[${formatTypeRef(t.ofType)}]`;
  }
  if (t.kind === 'NON_NULL' && t.ofType) {
    return `${formatTypeRef(t.ofType)}!`;
  }
  return t.name ?? 'unknown';
}

export function getEditableFields(table: CleanTable): CleanField[] {
  const pk = getPrimaryKeyInfo(table)[0];
  return getScalarFields(table).filter(
    (f) =>
      f.name !== pk.name &&
      f.name !== 'nodeId' &&
      f.name !== 'createdAt' &&
      f.name !== 'updatedAt',
  );
}

export function gqlTypeToJsonSchemaType(gqlType: string): string {
  switch (gqlType) {
    case 'Int':
      return 'integer';
    case 'Float':
      return 'number';
    case 'Boolean':
      return 'boolean';
    default:
      return 'string';
  }
}

export function buildSkillFile(skill: SkillDefinition): string {
  const lang = skill.language ?? 'bash';
  const lines: string[] = [];

  lines.push(`# ${skill.name}`);
  lines.push('');
  lines.push('> @generated by @constructive-io/graphql-codegen - DO NOT EDIT');
  lines.push('');
  lines.push(skill.description);
  lines.push('');
  lines.push('## Usage');
  lines.push('');
  lines.push(`\`\`\`${lang}`);
  for (const u of skill.usage) {
    lines.push(u);
  }
  lines.push('```');
  lines.push('');
  lines.push('## Examples');
  lines.push('');
  for (const ex of skill.examples) {
    lines.push(`### ${ex.description}`);
    lines.push('');
    lines.push(`\`\`\`${lang}`);
    for (const cmd of ex.code) {
      lines.push(cmd);
    }
    lines.push('```');
    lines.push('');
  }

  return lines.join('\n');
}
