import { toKebabCase } from 'komoji';

import type { CleanTable, CleanOperation } from '../../../types/schema';
import {
  formatArgType,
  getEditableFields,
  gqlTypeToJsonSchemaType,
  buildSkillFile,
} from '../docs-utils';
import type { GeneratedDocFile, McpTool } from '../docs-utils';
import {
  getScalarFields,
  getTableNames,
  getPrimaryKeyInfo,
} from '../utils';

export { resolveDocsConfig } from '../docs-utils';
export type { GeneratedDocFile, McpTool } from '../docs-utils';

export function generateReadme(
  tables: CleanTable[],
  customOperations: CleanOperation[],
  toolName: string,
): GeneratedDocFile {
  const lines: string[] = [];

  lines.push(`# ${toolName} CLI`);
  lines.push('');
  lines.push('> Auto-generated CLI commands from GraphQL schema');
  lines.push('> @generated by @constructive-io/graphql-codegen - DO NOT EDIT');
  lines.push('');
  lines.push('## Setup');
  lines.push('');
  lines.push('```bash');
  lines.push(`# Create a context pointing at your GraphQL endpoint`);
  lines.push(`${toolName} context create production --endpoint https://api.example.com/graphql`);
  lines.push('');
  lines.push(`# Set the active context`);
  lines.push(`${toolName} context use production`);
  lines.push('');
  lines.push(`# Authenticate`);
  lines.push(`${toolName} auth set-token <your-token>`);
  lines.push('```');
  lines.push('');

  lines.push('## Commands');
  lines.push('');
  lines.push('| Command | Description |');
  lines.push('|---------|-------------|');
  lines.push('| `context` | Manage API contexts (endpoints) |');
  lines.push('| `auth` | Manage authentication tokens |');
  for (const table of tables) {
    const { singularName } = getTableNames(table);
    const kebab = toKebabCase(singularName);
    lines.push(`| \`${kebab}\` | ${singularName} CRUD operations |`);
  }
  for (const op of customOperations) {
    const kebab = toKebabCase(op.name);
    lines.push(`| \`${kebab}\` | ${op.description || op.name} |`);
  }
  lines.push('');

  lines.push('## Infrastructure Commands');
  lines.push('');
  lines.push('### `context`');
  lines.push('');
  lines.push('Manage named API contexts (kubectl-style).');
  lines.push('');
  lines.push('| Subcommand | Description |');
  lines.push('|------------|-------------|');
  lines.push('| `create <name> --endpoint <url>` | Create a new context |');
  lines.push('| `list` | List all contexts |');
  lines.push('| `use <name>` | Set the active context |');
  lines.push('| `current` | Show current context |');
  lines.push('| `delete <name>` | Delete a context |');
  lines.push('');
  lines.push(`Configuration is stored at \`~/.${toolName}/config/\`.`);
  lines.push('');
  lines.push('### `auth`');
  lines.push('');
  lines.push('Manage authentication tokens per context.');
  lines.push('');
  lines.push('| Subcommand | Description |');
  lines.push('|------------|-------------|');
  lines.push('| `set-token <token>` | Store bearer token for current context |');
  lines.push('| `status` | Show auth status across all contexts |');
  lines.push('| `logout` | Remove credentials for current context |');
  lines.push('');

  if (tables.length > 0) {
    lines.push('## Table Commands');
    lines.push('');
    for (const table of tables) {
      const { singularName } = getTableNames(table);
      const kebab = toKebabCase(singularName);
      const pk = getPrimaryKeyInfo(table)[0];
      const scalarFields = getScalarFields(table);
      const editableFields = getEditableFields(table);

      lines.push(`### \`${kebab}\``);
      lines.push('');
      lines.push(`CRUD operations for ${table.name} records.`);
      lines.push('');
      lines.push('| Subcommand | Description |');
      lines.push('|------------|-------------|');
      lines.push(`| \`list\` | List all ${singularName} records |`);
      lines.push(`| \`get\` | Get a ${singularName} by ${pk.name} |`);
      lines.push(`| \`create\` | Create a new ${singularName} |`);
      lines.push(`| \`update\` | Update an existing ${singularName} |`);
      lines.push(`| \`delete\` | Delete a ${singularName} |`);
      lines.push('');
      lines.push('**Fields:**');
      lines.push('');
      lines.push('| Field | Type |');
      lines.push('|-------|------|');
      for (const f of scalarFields) {
        lines.push(`| \`${f.name}\` | ${f.type.gqlType} |`);
      }
      lines.push('');
      lines.push(`**Create fields:** ${editableFields.map((f) => `\`${f.name}\``).join(', ')}`);
      lines.push('');
    }
  }

  if (customOperations.length > 0) {
    lines.push('## Custom Operations');
    lines.push('');
    for (const op of customOperations) {
      const kebab = toKebabCase(op.name);
      lines.push(`### \`${kebab}\``);
      lines.push('');
      lines.push(op.description || op.name);
      lines.push('');
      lines.push(`- **Type:** ${op.kind}`);
      if (op.args.length > 0) {
        lines.push('- **Arguments:**');
        lines.push('');
        lines.push('  | Argument | Type |');
        lines.push('  |----------|------|');
        for (const arg of op.args) {
          lines.push(`  | \`${arg.name}\` | ${formatArgType(arg)} |`);
        }
      } else {
        lines.push('- **Arguments:** none');
      }
      lines.push('');
    }
  }

  lines.push('## Output');
  lines.push('');
  lines.push('All commands output JSON to stdout. Pipe to `jq` for formatting:');
  lines.push('');
  lines.push('```bash');
  lines.push(`${toolName} car list | jq '.[]'`);
  lines.push(`${toolName} car get --id <uuid> | jq '.'`);
  lines.push('```');
  lines.push('');

  return {
    fileName: 'README.md',
    content: lines.join('\n'),
  };
}

export function generateAgentsDocs(
  tables: CleanTable[],
  customOperations: CleanOperation[],
  toolName: string,
): GeneratedDocFile {
  const lines: string[] = [];

  lines.push(`# ${toolName} CLI - Agent Reference`);
  lines.push('');
  lines.push('> @generated by @constructive-io/graphql-codegen - DO NOT EDIT');
  lines.push('> This document is structured for LLM/agent consumption.');
  lines.push('');

  lines.push('## OVERVIEW');
  lines.push('');
  lines.push(`\`${toolName}\` is a CLI tool for interacting with a GraphQL API.`);
  lines.push('All commands output JSON to stdout. All commands accept `--help` or `-h` for usage.');
  lines.push(`Configuration is stored at \`~/.${toolName}/config/\` via appstash.`);
  lines.push('');

  lines.push('## PREREQUISITES');
  lines.push('');
  lines.push('Before running any data commands, you must:');
  lines.push('');
  lines.push(`1. Create a context: \`${toolName} context create <name> --endpoint <url>\``);
  lines.push(`2. Activate it: \`${toolName} context use <name>\``);
  lines.push(`3. Authenticate: \`${toolName} auth set-token <token>\``);
  lines.push('');

  lines.push('## TOOLS');
  lines.push('');

  lines.push('### TOOL: context');
  lines.push('');
  lines.push('Manage named API endpoint contexts (like kubectl contexts).');
  lines.push('');
  lines.push('```');
  lines.push('SUBCOMMANDS:');
  lines.push(`  ${toolName} context create <name> --endpoint <url>   Create a new context`);
  lines.push(`  ${toolName} context list                              List all contexts`);
  lines.push(`  ${toolName} context use <name>                        Set active context`);
  lines.push(`  ${toolName} context current                           Show active context`);
  lines.push(`  ${toolName} context delete <name>                     Delete a context`);
  lines.push('');
  lines.push('INPUT:');
  lines.push('  name:     string (required) - Context identifier');
  lines.push('  endpoint: string (required for create) - GraphQL endpoint URL');
  lines.push('');
  lines.push('OUTPUT: JSON');
  lines.push('  create:  { name, endpoint }');
  lines.push('  list:    [{ name, endpoint, isCurrent, hasCredentials }]');
  lines.push('  use:     { name, endpoint }');
  lines.push('  current: { name, endpoint }');
  lines.push('  delete:  { deleted: name }');
  lines.push('```');
  lines.push('');

  lines.push('### TOOL: auth');
  lines.push('');
  lines.push('Manage authentication tokens per context.');
  lines.push('');
  lines.push('```');
  lines.push('SUBCOMMANDS:');
  lines.push(`  ${toolName} auth set-token <token>   Store bearer token for current context`);
  lines.push(`  ${toolName} auth status               Show auth status for all contexts`);
  lines.push(`  ${toolName} auth logout                Remove credentials for current context`);
  lines.push('');
  lines.push('INPUT:');
  lines.push('  token: string (required for set-token) - Bearer token value');
  lines.push('');
  lines.push('OUTPUT: JSON');
  lines.push('  set-token: { context, status: "authenticated" }');
  lines.push('  status:    [{ context, authenticated: boolean }]');
  lines.push('  logout:    { context, status: "logged out" }');
  lines.push('```');
  lines.push('');

  for (const table of tables) {
    const { singularName } = getTableNames(table);
    const kebab = toKebabCase(singularName);
    const pk = getPrimaryKeyInfo(table)[0];
    const scalarFields = getScalarFields(table);
    const editableFields = getEditableFields(table);

    lines.push(`### TOOL: ${kebab}`);
    lines.push('');
    lines.push(`CRUD operations for ${table.name} records.`);
    lines.push('');
    lines.push('```');
    lines.push('SUBCOMMANDS:');
    lines.push(`  ${toolName} ${kebab} list                               List all records`);
    lines.push(`  ${toolName} ${kebab} get --${pk.name} <value>              Get one record`);
    lines.push(`  ${toolName} ${kebab} create ${editableFields.map((f) => `--${f.name} <value>`).join(' ')}`);
    lines.push(`  ${toolName} ${kebab} update --${pk.name} <value> ${editableFields.map((f) => `[--${f.name} <value>]`).join(' ')}`);
    lines.push(`  ${toolName} ${kebab} delete --${pk.name} <value>           Delete one record`);
    lines.push('');
    lines.push('INPUT FIELDS:');
    for (const f of scalarFields) {
      const isPk = f.name === pk.name;
      lines.push(`  ${f.name}: ${f.type.gqlType}${isPk ? ' (primary key)' : ''}`);
    }
    lines.push('');
    lines.push('EDITABLE FIELDS (for create/update):');
    for (const f of editableFields) {
      lines.push(`  ${f.name}: ${f.type.gqlType}`);
    }
    lines.push('');
    lines.push('OUTPUT: JSON');
    lines.push(`  list:   [{ ${scalarFields.map((f) => f.name).join(', ')} }]`);
    lines.push(`  get:    { ${scalarFields.map((f) => f.name).join(', ')} }`);
    lines.push(`  create: { ${scalarFields.map((f) => f.name).join(', ')} }`);
    lines.push(`  update: { ${scalarFields.map((f) => f.name).join(', ')} }`);
    lines.push(`  delete: { ${pk.name} }`);
    lines.push('```');
    lines.push('');
  }

  for (const op of customOperations) {
    const kebab = toKebabCase(op.name);

    lines.push(`### TOOL: ${kebab}`);
    lines.push('');
    lines.push(op.description || op.name);
    lines.push('');
    lines.push('```');
    lines.push(`TYPE: ${op.kind}`);
    if (op.args.length > 0) {
      const flags = op.args.map((a) => `--${a.name} <value>`).join(' ');
      lines.push(`USAGE: ${toolName} ${kebab} ${flags}`);
      lines.push('');
      lines.push('INPUT:');
      for (const arg of op.args) {
        lines.push(`  ${arg.name}: ${formatArgType(arg)}`);
      }
    } else {
      lines.push(`USAGE: ${toolName} ${kebab}`);
      lines.push('');
      lines.push('INPUT: none');
    }
    lines.push('');
    lines.push('OUTPUT: JSON');
    lines.push('```');
    lines.push('');
  }

  lines.push('## WORKFLOWS');
  lines.push('');
  lines.push('### Initial setup');
  lines.push('');
  lines.push('```bash');
  lines.push(`${toolName} context create dev --endpoint http://localhost:5000/graphql`);
  lines.push(`${toolName} context use dev`);
  lines.push(`${toolName} auth set-token eyJhbGciOiJIUzI1NiIs...`);
  lines.push('```');
  lines.push('');

  if (tables.length > 0) {
    const firstTable = tables[0];
    const { singularName } = getTableNames(firstTable);
    const kebab = toKebabCase(singularName);
    const editableFields = getEditableFields(firstTable);
    const pk = getPrimaryKeyInfo(firstTable)[0];

    lines.push(`### CRUD workflow (${kebab})`);
    lines.push('');
    lines.push('```bash');
    lines.push(`# List all`);
    lines.push(`${toolName} ${kebab} list`);
    lines.push('');
    lines.push(`# Create`);
    lines.push(`${toolName} ${kebab} create ${editableFields.map((f) => `--${f.name} "value"`).join(' ')}`);
    lines.push('');
    lines.push(`# Get by ${pk.name}`);
    lines.push(`${toolName} ${kebab} get --${pk.name} <value>`);
    lines.push('');
    lines.push(`# Update`);
    lines.push(`${toolName} ${kebab} update --${pk.name} <value> --${editableFields[0]?.name || 'field'} "new-value"`);
    lines.push('');
    lines.push(`# Delete`);
    lines.push(`${toolName} ${kebab} delete --${pk.name} <value>`);
    lines.push('```');
    lines.push('');
  }

  lines.push('### Piping output');
  lines.push('');
  lines.push('```bash');
  lines.push(`# Pretty print`);
  lines.push(`${toolName} car list | jq '.'`);
  lines.push('');
  lines.push(`# Extract field`);
  lines.push(`${toolName} car list | jq '.[].id'`);
  lines.push('');
  lines.push(`# Count results`);
  lines.push(`${toolName} car list | jq 'length'`);
  lines.push('```');
  lines.push('');

  lines.push('## ERROR HANDLING');
  lines.push('');
  lines.push('All errors are written to stderr. Exit codes:');
  lines.push('- `0`: Success');
  lines.push('- `1`: Error (auth failure, not found, validation error, network error)');
  lines.push('');
  lines.push('Common errors:');
  lines.push('- "No active context": Run `context use <name>` first');
  lines.push('- "Not authenticated": Run `auth set-token <token>` first');
  lines.push('- "Record not found": The requested ID does not exist');
  lines.push('');

  return {
    fileName: 'AGENTS.md',
    content: lines.join('\n'),
  };
}

export function getCliMcpTools(
  tables: CleanTable[],
  customOperations: CleanOperation[],
  toolName: string,
): McpTool[] {
  const tools: McpTool[] = [];

  tools.push({
    name: `${toolName}_context_create`,
    description: 'Create a named API context pointing at a GraphQL endpoint',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Context name' },
        endpoint: { type: 'string', description: 'GraphQL endpoint URL' },
      },
      required: ['name', 'endpoint'],
    },
  });

  tools.push({
    name: `${toolName}_context_list`,
    description: 'List all configured API contexts',
    inputSchema: { type: 'object', properties: {} },
  });

  tools.push({
    name: `${toolName}_context_use`,
    description: 'Set the active API context',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Context name to activate' },
      },
      required: ['name'],
    },
  });

  tools.push({
    name: `${toolName}_context_current`,
    description: 'Show the currently active API context',
    inputSchema: { type: 'object', properties: {} },
  });

  tools.push({
    name: `${toolName}_context_delete`,
    description: 'Delete an API context',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Context name to delete' },
      },
      required: ['name'],
    },
  });

  tools.push({
    name: `${toolName}_auth_set_token`,
    description: 'Store a bearer token for the current context',
    inputSchema: {
      type: 'object',
      properties: {
        token: { type: 'string', description: 'Bearer token value' },
      },
      required: ['token'],
    },
  });

  tools.push({
    name: `${toolName}_auth_status`,
    description: 'Show authentication status for all contexts',
    inputSchema: { type: 'object', properties: {} },
  });

  tools.push({
    name: `${toolName}_auth_logout`,
    description: 'Remove credentials for the current context',
    inputSchema: { type: 'object', properties: {} },
  });

  for (const table of tables) {
    const { singularName } = getTableNames(table);
    const kebab = toKebabCase(singularName);
    const pk = getPrimaryKeyInfo(table)[0];
    const scalarFields = getScalarFields(table);
    const editableFields = getEditableFields(table);

    tools.push({
      name: `${toolName}_${kebab}_list`,
      description: `List all ${table.name} records`,
      inputSchema: { type: 'object', properties: {} },
    });

    tools.push({
      name: `${toolName}_${kebab}_get`,
      description: `Get a single ${table.name} record by ${pk.name}`,
      inputSchema: {
        type: 'object',
        properties: {
          [pk.name]: {
            type: gqlTypeToJsonSchemaType(pk.gqlType),
            description: `${table.name} ${pk.name}`,
          },
        },
        required: [pk.name],
      },
    });

    const createProps: Record<string, unknown> = {};
    for (const f of editableFields) {
      createProps[f.name] = {
        type: gqlTypeToJsonSchemaType(f.type.gqlType),
        description: `${table.name} ${f.name}`,
      };
    }
    tools.push({
      name: `${toolName}_${kebab}_create`,
      description: `Create a new ${table.name} record`,
      inputSchema: {
        type: 'object',
        properties: createProps,
        required: editableFields.map((f) => f.name),
      },
    });

    const updateProps: Record<string, unknown> = {
      [pk.name]: {
        type: gqlTypeToJsonSchemaType(pk.gqlType),
        description: `${table.name} ${pk.name}`,
      },
    };
    for (const f of editableFields) {
      updateProps[f.name] = {
        type: gqlTypeToJsonSchemaType(f.type.gqlType),
        description: `${table.name} ${f.name}`,
      };
    }
    tools.push({
      name: `${toolName}_${kebab}_update`,
      description: `Update an existing ${table.name} record`,
      inputSchema: {
        type: 'object',
        properties: updateProps,
        required: [pk.name],
      },
    });

    tools.push({
      name: `${toolName}_${kebab}_delete`,
      description: `Delete a ${table.name} record by ${pk.name}`,
      inputSchema: {
        type: 'object',
        properties: {
          [pk.name]: {
            type: gqlTypeToJsonSchemaType(pk.gqlType),
            description: `${table.name} ${pk.name}`,
          },
        },
        required: [pk.name],
      },
    });

    tools.push({
      name: `${toolName}_${kebab}_fields`,
      description: `List available fields for ${table.name}`,
      inputSchema: { type: 'object', properties: {} },
      _meta: {
        fields: scalarFields.map((f) => ({
          name: f.name,
          type: f.type.gqlType,
          editable: editableFields.some((ef) => ef.name === f.name),
          primaryKey: f.name === pk.name,
        })),
      },
    });
  }

  for (const op of customOperations) {
    const kebab = toKebabCase(op.name);
    const props: Record<string, unknown> = {};
    const required: string[] = [];

    for (const arg of op.args) {
      const isRequired = arg.type.kind === 'NON_NULL';
      const baseType = isRequired && arg.type.ofType ? arg.type.ofType : arg.type;
      props[arg.name] = {
        type: gqlTypeToJsonSchemaType(baseType.name ?? 'String'),
        description: arg.description || arg.name,
      };
      if (isRequired) {
        required.push(arg.name);
      }
    }

    tools.push({
      name: `${toolName}_${kebab}`,
      description: op.description || op.name,
      inputSchema: {
        type: 'object',
        properties: props,
        ...(required.length > 0 ? { required } : {}),
      },
    });
  }

  return tools;
}

export function generateSkills(
  tables: CleanTable[],
  customOperations: CleanOperation[],
  toolName: string,
): GeneratedDocFile[] {
  const files: GeneratedDocFile[] = [];

  files.push({
    fileName: 'skills/context.md',
    content: buildSkillFile({
      name: `${toolName}-context`,
      description: `Manage API endpoint contexts for ${toolName}`,
      usage: [
        `${toolName} context create <name> --endpoint <url>`,
        `${toolName} context list`,
        `${toolName} context use <name>`,
        `${toolName} context current`,
        `${toolName} context delete <name>`,
      ],
      examples: [
        {
          description: 'Create and activate a context',
          code: [
            `${toolName} context create production --endpoint https://api.example.com/graphql`,
            `${toolName} context use production`,
          ],
        },
        {
          description: 'List all contexts',
          code: [`${toolName} context list`],
        },
      ],
    }),
  });

  files.push({
    fileName: 'skills/auth.md',
    content: buildSkillFile({
      name: `${toolName}-auth`,
      description: `Manage authentication tokens for ${toolName}`,
      usage: [
        `${toolName} auth set-token <token>`,
        `${toolName} auth status`,
        `${toolName} auth logout`,
      ],
      examples: [
        {
          description: 'Authenticate with a token',
          code: [`${toolName} auth set-token eyJhbGciOiJIUzI1NiIs...`],
        },
        {
          description: 'Check auth status',
          code: [`${toolName} auth status`],
        },
      ],
    }),
  });

  for (const table of tables) {
    const { singularName } = getTableNames(table);
    const kebab = toKebabCase(singularName);
    const pk = getPrimaryKeyInfo(table)[0];
    const editableFields = getEditableFields(table);

    files.push({
      fileName: `skills/${kebab}.md`,
      content: buildSkillFile({
        name: `${toolName}-${kebab}`,
        description: `CRUD operations for ${table.name} records via ${toolName} CLI`,
        usage: [
          `${toolName} ${kebab} list`,
          `${toolName} ${kebab} get --${pk.name} <value>`,
          `${toolName} ${kebab} create ${editableFields.map((f) => `--${f.name} <value>`).join(' ')}`,
          `${toolName} ${kebab} update --${pk.name} <value> ${editableFields.map((f) => `[--${f.name} <value>]`).join(' ')}`,
          `${toolName} ${kebab} delete --${pk.name} <value>`,
        ],
        examples: [
          {
            description: `List all ${singularName} records`,
            code: [`${toolName} ${kebab} list`],
          },
          {
            description: `Create a ${singularName}`,
            code: [
              `${toolName} ${kebab} create ${editableFields.map((f) => `--${f.name} "value"`).join(' ')}`,
            ],
          },
          {
            description: `Get a ${singularName} by ${pk.name}`,
            code: [`${toolName} ${kebab} get --${pk.name} <value>`],
          },
          {
            description: `Update a ${singularName}`,
            code: [
              `${toolName} ${kebab} update --${pk.name} <value> --${editableFields[0]?.name || 'field'} "new-value"`,
            ],
          },
          {
            description: `Delete a ${singularName}`,
            code: [`${toolName} ${kebab} delete --${pk.name} <value>`],
          },
        ],
      }),
    });
  }

  for (const op of customOperations) {
    const kebab = toKebabCase(op.name);
    const usage =
      op.args.length > 0
        ? `${toolName} ${kebab} ${op.args.map((a) => `--${a.name} <value>`).join(' ')}`
        : `${toolName} ${kebab}`;

    files.push({
      fileName: `skills/${kebab}.md`,
      content: buildSkillFile({
        name: `${toolName}-${kebab}`,
        description: op.description || `Execute the ${op.name} ${op.kind}`,
        usage: [usage],
        examples: [
          {
            description: `Run ${op.name}`,
            code: [usage],
          },
        ],
      }),
    });
  }

  return files;
}
