/**
 * Comment model for ORM client
 * @generated by @constructive-io/graphql-codegen
 * DO NOT EDIT - changes will be overwritten
 */
import { OrmClient } from '../client';
import {
  QueryBuilder,
  buildFindManyDocument,
  buildFindFirstDocument,
  buildFindOneDocument,
  buildCreateDocument,
  buildUpdateByPkDocument,
  buildDeleteByPkDocument,
} from '../query-builder';
import type {
  ConnectionResult,
  FindManyArgs,
  FindFirstArgs,
  CreateArgs,
  UpdateArgs,
  DeleteArgs,
  InferSelectResult,
  StrictSelect,
} from '../select-types';
import type {
  Comment,
  CommentWithRelations,
  CommentSelect,
  CommentFilter,
  CommentsOrderBy,
  CreateCommentInput,
  UpdateCommentInput,
  CommentPatch,
} from '../input-types';
import { connectionFieldsMap } from '../input-types';
export class CommentModel {
  constructor(private client: OrmClient) {}
  findMany<S extends CommentSelect>(
    args: FindManyArgs<S, CommentFilter, CommentsOrderBy> & {
      select: S;
    } & StrictSelect<S, CommentSelect>
  ): QueryBuilder<{
    comments: ConnectionResult<InferSelectResult<CommentWithRelations, S>>;
  }> {
    const { document, variables } = buildFindManyDocument(
      'Comment',
      'comments',
      args.select,
      {
        where: args?.where,
        orderBy: args?.orderBy as string[] | undefined,
        first: args?.first,
        last: args?.last,
        after: args?.after,
        before: args?.before,
        offset: args?.offset,
      },
      'CommentFilter',
      'CommentsOrderBy',
      connectionFieldsMap
    );
    return new QueryBuilder({
      client: this.client,
      operation: 'query',
      operationName: 'Comment',
      fieldName: 'comments',
      document,
      variables,
    });
  }
  findFirst<S extends CommentSelect>(
    args: FindFirstArgs<S, CommentFilter> & {
      select: S;
    } & StrictSelect<S, CommentSelect>
  ): QueryBuilder<{
    comments: {
      nodes: InferSelectResult<CommentWithRelations, S>[];
    };
  }> {
    const { document, variables } = buildFindFirstDocument(
      'Comment',
      'comments',
      args.select,
      {
        where: args?.where,
      },
      'CommentFilter',
      connectionFieldsMap
    );
    return new QueryBuilder({
      client: this.client,
      operation: 'query',
      operationName: 'Comment',
      fieldName: 'comments',
      document,
      variables,
    });
  }
  findOne<S extends CommentSelect>(
    args: {
      id: string;
      select: S;
    } & StrictSelect<S, CommentSelect>
  ): QueryBuilder<{
    comment: InferSelectResult<CommentWithRelations, S> | null;
  }> {
    const { document, variables } = buildFindManyDocument(
      'Comment',
      'comments',
      args.select,
      {
        where: {
          id: {
            equalTo: args.id,
          },
        },
        first: 1,
      },
      'CommentFilter',
      'CommentsOrderBy',
      connectionFieldsMap
    );
    return new QueryBuilder({
      client: this.client,
      operation: 'query',
      operationName: 'Comment',
      fieldName: 'comment',
      document,
      variables,
      transform: (data: {
        comments?: {
          nodes?: InferSelectResult<CommentWithRelations, S>[];
        };
      }) => ({
        comment: data.comments?.nodes?.[0] ?? null,
      }),
    });
  }
  create<S extends CommentSelect>(
    args: CreateArgs<S, CreateCommentInput['comment']> & {
      select: S;
    } & StrictSelect<S, CommentSelect>
  ): QueryBuilder<{
    createComment: {
      comment: InferSelectResult<CommentWithRelations, S>;
    };
  }> {
    const { document, variables } = buildCreateDocument(
      'Comment',
      'createComment',
      'comment',
      args.select,
      args.data,
      'CreateCommentInput',
      connectionFieldsMap
    );
    return new QueryBuilder({
      client: this.client,
      operation: 'mutation',
      operationName: 'Comment',
      fieldName: 'createComment',
      document,
      variables,
    });
  }
  update<S extends CommentSelect>(
    args: UpdateArgs<
      S,
      {
        id: string;
      },
      CommentPatch
    > & {
      select: S;
    } & StrictSelect<S, CommentSelect>
  ): QueryBuilder<{
    updateComment: {
      comment: InferSelectResult<CommentWithRelations, S>;
    };
  }> {
    const { document, variables } = buildUpdateByPkDocument(
      'Comment',
      'updateComment',
      'comment',
      args.select,
      args.where.id,
      args.data,
      'UpdateCommentInput',
      'id',
      'patch',
      connectionFieldsMap
    );
    return new QueryBuilder({
      client: this.client,
      operation: 'mutation',
      operationName: 'Comment',
      fieldName: 'updateComment',
      document,
      variables,
    });
  }
  delete<S extends CommentSelect>(
    args: DeleteArgs<
      {
        id: string;
      },
      S
    > & {
      select: S;
    } & StrictSelect<S, CommentSelect>
  ): QueryBuilder<{
    deleteComment: {
      comment: InferSelectResult<CommentWithRelations, S>;
    };
  }> {
    const { document, variables } = buildDeleteByPkDocument(
      'Comment',
      'deleteComment',
      'comment',
      args.where.id,
      'DeleteCommentInput',
      'id',
      args.select,
      connectionFieldsMap
    );
    return new QueryBuilder({
      client: this.client,
      operation: 'mutation',
      operationName: 'Comment',
      fieldName: 'deleteComment',
      document,
      variables,
    });
  }
}
